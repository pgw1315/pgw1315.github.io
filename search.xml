<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>.gitignore文件的配置使用</title>
      <link href="/2022/06/26/gitignore%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/26/gitignore%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在使用Git的过程中，有的文件比如日志，临时文件，编译的中间文件等不要提交到代码仓库，这时就要设置相应的忽略规则，来忽略这些文件的提交。简单来说一个场景：在你使用git add .的时候，遇到了把你不想提交的文件也添加到了缓存中去的情况，比如项目的本地配置信息，如果你上传到Git中去其他人pull下来的时候就会和他本地的配置有冲突，所以这样的个性化配置文件我们一般不把它推送到git服务器中，但是又为了偷懒每次添加缓存的时候都想用git add .而不是手动一个一个文件添加，该怎么办呢？很简单，git为我们提供了一个.gitignore文件，只要在这个文件中声明哪些文件你不希望添加到git中去，这样当你使用git add .的时候这些文件就会被自动忽略掉。</p><h3 id="Git忽略文件的原则"><a href="#Git忽略文件的原则" class="headerlink" title="Git忽略文件的原则"></a>Git忽略文件的原则</h3><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如产生的.log日志文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul><h3 id="gitignore文件的使用方法"><a href="#gitignore文件的使用方法" class="headerlink" title=".gitignore文件的使用方法"></a>.gitignore文件的使用方法</h3><p>首先，在你的工作区新建一个名称为.gitignore的文件。 然后，把要忽略的文件名填进去，Git就会自动忽略这些文件。不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a>。</p><pre><code class="bash"># dir 不需要提交的目录/node_modules​# file 不需要提交的文件config.ini​# log 不需要提交的任意包含后缀名为log的文件*.log​# Package Files 不需要提交的任意包含后缀名为jar的文件*.jar</code></pre><p>.gitignore注释用’#’, *表示匹配0个或多个任意字符，所以上面的模式就是要忽略所有的xml文件,log文件和apk文件。<br>.gitignore配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为版本管理带来很大的便利。<br>如果有些文件已经被忽略了，当使用<code>git add</code>时是无法添加的。需要加上<code>-f</code>参数才能强制添加到git中去，这样就能强制添加到缓存中去了。</p><pre><code class="bash">git add -f node_modules/jquery/dist/jquery.min.js</code></pre><p>如果我们意外的将想要忽略的文件添加到缓存中去了，我们可以使用<code>rm</code>命令将其从中移除：</p><pre><code class="bash">git rm --cached test.js </code></pre><h3 id="gitignore忽略规则的优先级"><a href="#gitignore忽略规则的优先级" class="headerlink" title=".gitignore忽略规则的优先级"></a>.gitignore忽略规则的优先级</h3><pre><code class="bash">在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：1、从命令行中读取可用的忽略规则2、当前目录定义的规则3、父级目录定义的规则，依次递推4、$GIT_DIR/info/exclude 文件中定义的规则5、core.excludesfile中定义的全局规则</code></pre><h3 id="gitignore忽略规则的匹配语法"><a href="#gitignore忽略规则的匹配语法" class="headerlink" title=".gitignore忽略规则的匹配语法"></a>.gitignore忽略规则的匹配语法</h3><pre><code class="bash">在 .gitignore 文件中，每一行的忽略规则的语法如下：1、空格不匹配任意文件，可作为分隔符，可用反斜杠转义2、以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。3、可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。4、以斜杠&quot;/&quot;开头表示目录；&quot;/&quot;结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；&quot;/&quot;开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。5、以星号&quot;*&quot;通配多个字符，即匹配多个任意字符；使用两个星号&quot;**&quot; 表示匹配任意中间目录，比如a/**/z可以匹配 a/z, a/b/z 或 a/b/c/z等。6、以问号&quot;?&quot;通配单个字符，即匹配一个任意字符；7、以方括号&quot;[]&quot;包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。8、以叹号&quot;!&quot;表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用&quot;!&quot;规则是不起作用的。也就是说&quot;!&quot;开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用&quot;!&quot;也不会再次被包含。可以使用反斜杠进行转义。</code></pre><h3 id="需要谨记："><a href="#需要谨记：" class="headerlink" title="需要谨记："></a>需要谨记：</h3><p>git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p><h3 id="十分重要："><a href="#十分重要：" class="headerlink" title="十分重要："></a>十分重要：</h3><p>如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。简单来说出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。所以大家一定要养成在项目开始就创建.gitignore文件的习惯，否则一单push，处理起来会非常麻烦。</p><pre><code class="bash">#               表示此为注释,将被Git忽略*.a             表示忽略所有 .a 结尾的文件!lib.a          表示但lib.a除外/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin:           表示忽略根目录下的bin文件/*.c:           表示忽略cat.c，不忽略 build/cat.cdebug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo:         表示忽略/foo,a/foo,a/b/foo等a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh    表示不忽略bin目录下的run.sh文件*.log:          表示忽略所有 .log 文件config.php:     表示忽略当前路径的 config.php 文件 /mtk/           表示过滤整个文件夹*.zip           表示过滤所有.zip文件/mtk/do.c       表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容； /*!.gitignore!/fw/ /fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。</code></pre><p>如果你已经把不想上传的文件上传到了git仓库，那么你必须先从远程仓库删了它，我们可以从远程仓库直接删除然后pull代码到本地仓库这些文件就会本删除，或者从本地删除这些文件并且在.gitignore文件中添加这些你想忽略的文件，然后再push到远程仓库。</p><h3 id="gitignor忽略规则查看"><a href="#gitignor忽略规则查看" class="headerlink" title="gitignor忽略规则查看"></a>gitignor忽略规则查看</h3><p>如果你发下.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：</p><pre><code class="bash">git check-ignore -v xxx.js</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/52885189" target="_blank" rel="noopener">[Git].gitignore文件的配置使用</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>油猴脚本编写教程</title>
      <link href="/2022/06/24/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B-SegmentFault%E6%80%9D%E5%90%A6/"/>
      <url>/2022/06/24/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B-SegmentFault%E6%80%9D%E5%90%A6/</url>
      
        <content type="html"><![CDATA[<p>油猴脚本（Tampermonkey）是一个非常流行的浏览器扩展，它可以运行由广大社区编写的扩展脚本，来实现各式各样的功能，常见的去广告、修改样式文件、甚至是下载视频。今天我们就来看看如何编写自己的油猴脚本。当然为了运行油猴脚本，你应该在浏览器中安装油猴插件。</p><h3 id="安装油猴插件"><a href="#安装油猴插件" class="headerlink" title="安装油猴插件"></a>安装油猴插件</h3><p>安装油猴插件非常简单，直接在浏览器的扩展商店中安装即可。国产浏览器的话一般可以通过下载扩展文件手动拖动的方式来安装。下图是微软新版Edge浏览器的扩展商店，直接搜索Tampermonkey即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/3843056900-8983f8db535e19d8_fix732.png" alt="新版Edge扩展商店" title="">                </div>                <div class="image-caption">新版Edge扩展商店</div>            </figure><h3 id="新建脚本"><a href="#新建脚本" class="headerlink" title="新建脚本"></a>新建脚本</h3><p>首先在浏览器右上角找到并点击油猴插件，选择添加新脚本。</p><ul><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/3094194886-b721a19ba853294b_fix732.png" alt="添加新脚本" title="">                </div>                <div class="image-caption">添加新脚本</div>            </figure></li></ul><p>然后就会打开如图所示的编辑器窗口，我们就可以在其中编辑自己的脚本文件了。如果你喜欢的话，还可以将脚本内容复制到合适的编辑器中编辑，完成之后再复制回来。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/4224078242-f7656f879d3066fa_fix732.png" alt="编辑脚本文件" title="">                </div>                <div class="image-caption">编辑脚本文件</div>            </figure><p>如果你点击开发者菜单的话，可以选择ES6模板，然后就可以在脚本中使用新版JavaScript的特性了，它会有Babel转译回ES5。不过这个模板貌似有点问题，用了它就没办法使用代码纠错功能了。所以这里我还是选择了默认的ES5模板。</p><h3 id="脚本编写方法"><a href="#脚本编写方法" class="headerlink" title="脚本编写方法"></a>脚本编写方法</h3><h4 id="功能注释"><a href="#功能注释" class="headerlink" title="功能注释"></a>功能注释</h4><p>首先来看看脚本的内容，上面是一大排注释，这些注释可以非常有用的，它表明了脚本的各个属性。下面来简单介绍一下。</p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>油猴脚本的名字</td></tr><tr><td>namespace</td><td>命名空间，类似于Java的包名，用来区分相同名称的脚本，一般写成作者名字或者网址就可以了</td></tr><tr><td>version</td><td>脚本版本，油猴脚本的更新会读取这个版本号</td></tr><tr><td>description</td><td>描述，用来告诉用户这个脚本是干什么用的</td></tr><tr><td>author</td><td>作者名字</td></tr><tr><td>match</td><td>只有匹配的网址才会执行对应的脚本，例如<code>*</code>、<code>http://*</code>、<code>http://www.baidu.com/*</code>等，参见<a href="https://developer.chrome.com/docs/extensions/mv3/match_patterns/" target="_blank" rel="noopener">谷歌开发者文档</a></td></tr><tr><td></td><td></td></tr><tr><td>grant</td><td>指定脚本运行所需权限，如果脚本拥有相应的权限，就可以调用油猴扩展提供的API与浏览器进行交互。如果设置为<code>none</code>的话，则不使用沙箱环境，脚本会直接运行在网页的环境中，这时候无法使用大部分油猴扩展的API。如果不指定的话，油猴会默认添加几个最常用的API</td></tr><tr><td>require</td><td>如果脚本依赖其他js库的话，可以使用require指令，在运行脚本之前先加载其他库，常见用法是加载jquery</td></tr><tr><td>connect</td><td>当用户使用<a href="https://www.tampermonkey.net/documentation.php?version=4.9&ext=dhdg&show=dhdg#GM_xmlhttpRequest" target="_blank" rel="noopener">GM_xmlhttpRequest</a>请求远程数据的时候，需要使用connect指定允许访问的域名，支持域名、子域名、IP地址以及<code>*</code>通配符</td></tr><tr><td>updateURL</td><td>脚本更新网址，当油猴扩展检查更新的时候，会尝试从这个网址下载脚本，然后比对版本号确认是否更新</td></tr></tbody></table><h4 id="脚本权限"><a href="#脚本权限" class="headerlink" title="脚本权限"></a>脚本权限</h4><p>下面简单介绍一下grant指令那里可以填写的一些权限，详情请查看<a href="https://www.tampermonkey.net/documentation.php" target="_blank" rel="noopener">油猴脚本文档</a>。这里就简单介绍几个常用的，可以调用的函数全部以GM_作为开头。</p><table><thead><tr><th>权限名</th><th>功能</th></tr></thead><tbody><tr><td>unsafeWindow</td><td>允许脚本可以完整访问原始页面，包括原始页面的脚本和变量。</td></tr><tr><td>GM_getValue(name,defaultValue)</td><td>从油猴扩展的存储中访问数据。可以设置默认值，在没成功获取到数据的时候当做初始值。如果保存的是日期等类型的话，取出来的数据会变成文本，需要自己转换一下。</td></tr><tr><td>GM_setValue(name,value)</td><td>将数据保存到存储中</td></tr><tr><td>GM_xmlhttpRequest(details)</td><td>异步访问网页数据的API，这个方法比较复杂，有大量参数和回调，详情请参考官方文档。</td></tr><tr><td>GM_setClipboard(data, info)</td><td>将数据复制到剪贴板中，第一个参数是要复制的数据，第二个参数是MIME类型，用于指定复制的数据类型。</td></tr><tr><td>GM_log(message)</td><td>将日志打印到控制台中，可以使用F12开发者工具查看。</td></tr><tr><td>GM_addStyle(css)</td><td>像网页中添加自己的样式表。</td></tr><tr><td>GM_notification(details, ondone), GM_notification(text, title, image, onclick)</td><td>设置网页通知，请参考文档获取用法。</td></tr><tr><td>GM_openInTab(url, loadInBackground)</td><td>在浏览器中打开网页，可以设置是否在后台打开等几个选项</td></tr></tbody></table><p>还有一些API没有介绍，请大家直接查看官方文档吧。</p><h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>编写脚本就很简单了，编写到<code>// Your code here ..</code>那里即可。可以编写函数，然后在最后调用这几个函数，这样的模块化编写方法写出来的脚本比较容易维护。</p><h4 id="等vagrant更新时候提醒我的脚本"><a href="#等vagrant更新时候提醒我的脚本" class="headerlink" title="等vagrant更新时候提醒我的脚本"></a>等vagrant更新时候提醒我的脚本</h4><p>前段时间了解了vagrant这个东西，感觉很有意思，准备研究一下，但是照着官网教程运行的时候，第一步就发生了错误。我上网一搜，原来我更新的virtualbox比较新，vagrant恰好不支持。但是如今几个月过去了，vagrant还是没有更新，所以我要写一个脚本，等到vagrant更新的时候，给我网页上弹出一个对话框。</p><p>首先访问<a href="https://www.vagrantup.com/" target="_blank" rel="noopener">vagrant官网</a>，然后就可以看到中间下载按钮上大大的版本号2.2.6了。因为版本肯定是不会倒退的，所以只要判断一下版本号不是2.2.6，就可以弹出提示了。通过F12开发者工具可以看到，这三个按钮其实都是链接，只不过显示成了按钮的样子，而且他们恰好都位于<code>header</code>标签之中。如果如果可以的话，直接用选择器就可以非常轻松的获取到版本号。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/3073214562-a785d8e2c4712cef_fix732.png" alt="vagrant官网" title="">                </div>                <div class="image-caption">vagrant官网</div>            </figure><p>为了能在更新的时候及时获取到提示，我需要脚本在所有网站上生效，来检测版本。但是这样做会导致另外一个问题，那就是每次打开一个网页都会运行一次检查vagrant的脚本，而这是完全不必要的。所以需要一个额外的判断，这就需要利用油猴提供的API来保存当前日期，只有每天第一次的时候才会执行检查代码。本来我想的很复杂，需要一个日期变量，然后还要额外一个变量保存是否是今天第一次更新。后来我发现我想的太多了，做法其实很简单。每天先获取一次日期，然后和事先保存的日期比较，如果不一样的话才执行脚本，并将日期设置为今天的日期；如果日期一样的话无事发生。</p><p>最后一个问题就是如何来判断版本号，有两种方法：第一种就是上面提到的，直接解析HTML代码并找到版本号；第二种是更直接的办法， 因为vagrant也是Github上开源的项目，所以可以直接调用Github的API来获取最新发布的版本号。可惜的是，第二种办法我试了一下居然不成功，不知为何，没办法获取到发布信息，但是换成其他项目就可以。所以最后没办法只好采用第一种办法。有兴趣的同学可以自己试一下第二种方法。</p><p>好了，所有相关的坑我都已经解释完毕了，相信大家应该很容易就可以看懂下面的代码，我就不介绍了。虽然看着简单，但是我其实还是踩了不少的坑，就这点代码花了我好几天的时间。而且确实这个代码写的也并不是很好，因为ajax取回来的代码是完整一个html页面，貌似用原版DOM API没办法解析，最后只好用jQuery的<code>parseHTML</code>方法解析的。而且我还因为原生方法和jQuery之间的方法名搞混了，浪费了很多时间。</p><pre><code class="js">// ==UserScript==// @name         remind_me_vagrant_update// @namespace    https://github.com/techstay/myscripts// @version      0.1// @description  remind me if vagrant support virtualbox// @author       techstay// @match        *// @require      https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js// @connect vagrantup.com// @grant GM_setValue// @grant GM_getValue// @grant GM_setClipboard// @grant GM_log// @grant GM_xmlhttpRequest// @grant unsafeWindow// @grant window.close// @grant window.focus// ==/UserScript==(function () {    &#39;use strict&#39;;    const CHECKED_DATE = &#39;checkedDate&#39;;    function checkDateEquals(a, b) {        return a.getFullYear() === b.getFullYear() &amp;&amp;            a.getMonth() === b.getMonth() &amp;&amp;            a.getDate() === b.getDate();    }    function checkVagrantVersion() {        GM_setValue(CHECKED_DATE, new Date());        GM_xmlhttpRequest({            &quot;method&quot;: &quot;GET&quot;,            &quot;url&quot;: &quot;https://www.vagrantup.com/&quot;,            &quot;headers&quot;: {                &quot;user-agent&quot;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#39;            },            &quot;onload&quot;: function (result) {                var list = jQuery.parseHTML(result.response);                jQuery.each(list, function (i, el) {                    if (el.nodeName == &#39;HEADER&#39;) {                        var header = jQuery.parseXML(el.innerHTML);                        var version = header.getElementsByTagName(&#39;a&#39;)[1].textContent.replace(&#39;Download &#39;, &#39;&#39;);                        if (version != &#39;2.2.6&#39;) {                            alert(&#39;Vagrant update!&#39;);                        }                        return false;                    }                });            }        });    }    var today = new Date();    var lastCheckedDay = new Date(GM_getValue(CHECKED_DATE, new Date(&#39;2006-1-1&#39;)));    if (!checkDateEquals(lastCheckedDay, today)) {        checkVagrantVersion();    }})();</code></pre><h4 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h4><p>编写脚本很难一次成功，大部分时间都花在了调试上面。调试油猴脚本的话有几种调试方法。</p><p>第一种方法就是最原始的打印日志，可以利用<code>console.log</code>和<code>GM_log</code>来将关键信息打印出来，上面的脚本就是我靠打印日志一点点发现各种参数错误的。说实话这种办法有点笨。</p><p>第二种就是利用浏览器的调试功能，在脚本需要调试的地方插入<code>debugger;</code>语句，然后在打开F12开发者工具的情况下刷新页面，就会发现网页已经暂停在相应位置上。这样就可以利用F12开发者工具进行单步调试、监视变量等操作了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/2630308594-5ea670883f9dcd05_fix732.png" alt="调试脚本" title="">                </div>                <div class="image-caption">调试脚本</div>            </figure><h4 id="将文章同步复制到Csdn和思否编辑器的脚本"><a href="#将文章同步复制到Csdn和思否编辑器的脚本" class="headerlink" title="将文章同步复制到Csdn和思否编辑器的脚本"></a>将文章同步复制到Csdn和思否编辑器的脚本</h4><p>我的文章一般都是简书首发，然后复制粘贴到Csdn中，但是后来我发现每次手动操作太蠢了，为什么不用脚本来自动化呢？所以我又写了个脚本帮忙完成自动化工作。本来以为这个脚本应该比较简单，不过还是踩了很多坑才凑合把功能写出来。</p><p>首先是数据的保存，利用油猴提供的<code>GM_setValue</code>倒是可以很简单的将文章标题和内容保存起来。不过问题来了，如何在不同页面之间共享呢？有几种方案：第一种最简单粗暴，直接复制两份，对应页面首先判断是否存在数据，存在的话才执行复制操作，然后清空数据。这种方案最简单，而且如果自己直接新建文章的话也不会出问题。第二种就是数据只保存一份，通过几个变量来确定什么时候复制完成，清空数据，但是这样比较复杂，要理清逻辑顺序很麻烦。所以最后我就采用了第一种办法。</p><p>然后又遇到一个问题，那就是如果编辑器自带了保存和恢复功能，很可能会把我复制过去的文章给覆盖了，所以需要等页面加载完之后，延迟一段时间才进行复制操作。然后我又谷歌了一番，差不多解决了这个问题。</p><p>然后遇到了一个非常棘手的问题，就是SF的编辑器设计比较复杂，没办法通过直接填充<code>value</code>或者<code>text</code>属性的方式来写入文章，我想了很久也没有想出来怎么解决。没办法只好改用剪贴板的方式来糊弄了，也就是将文章内容复制到剪贴板里头，然后手动粘贴到编辑器中。</p><p>最后一个问题就是简书上这个复制按钮应该如何实现，其实简书编辑器的工具栏倒是空了一些部分，我本来想把按钮直接加到那个上面。但是我发现貌似一旦添加东西，那个工具栏会自动重载取消更改，所以水平所限没做到，只好利用jQueryUI加了一个很丑的浮动按钮，而且因为拖动的时候会触发单击，没办法把按钮改成了双击触发。</p><p>最后的脚本就是下面这样的。相比第一个脚本多了几个打开新页面、删除变量、访问剪贴板的API。</p><pre><code class="js">// ==UserScript==// @name         copy_jianshu_to_csdn_and_segmentfault// @namespace    https://github.com/techstay/myscripts// @version      0.1// @description  将简书文章复制到csdn和思否编辑器中// @author       techstay// @match        https://editor.csdn.net/md/// @match https://segmentfault.com/write// @match https://www.jianshu.com/writer*// @require      https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js// @require      https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.min.js// @grant GM_setValue// @grant GM_getValue// @grant GM_deleteValue// @grant unsafeWindow// @grant GM_setClipboard// @grant window.close// @grant window.focus// @grant GM_openInTab// ==/UserScript==(function () {    &#39;use strict&#39;;    const SF_URL = &#39;https://segmentfault.com/write&#39;    const CSDN_URL = &#39;https://editor.csdn.net/md/&#39;    const SF_TITLE = &#39;sf_title&#39;    const SF_CONTENT = &#39;sf_content&#39;    const CSDN_TITLE = &#39;csdn_title&#39;    const CSDN_CONTENT = &#39;csdn_content&#39;    function saveArticle() {        GM_setValue(CSDN_TITLE, $(&#39;._24i7u&#39;).val())        GM_setValue(CSDN_CONTENT, $(&#39;#arthur-editor&#39;).val())        GM_setValue(SF_TITLE, $(&#39;._24i7u&#39;).val())        GM_setValue(SF_CONTENT, $(&#39;#arthur-editor&#39;).val())    }    function copyToCsdn() {        var title = GM_getValue(CSDN_TITLE, &#39;&#39;)        var content = GM_getValue(CSDN_CONTENT, &#39;&#39;)        if (title != &#39;&#39; &amp;&amp; content != &#39;&#39;) {            $(&#39;.article-bar__title&#39;).delay(2000).queue(function () {                $(&#39;.article-bar__title&#39;).val(title)                $(&#39;.editor__inner&#39;).text(content)                GM_deleteValue(CSDN_TITLE)                GM_deleteValue(CSDN_CONTENT)                $(this).dequeue()            })        }    }    function copyToSegmentFault() {        $(document).ready(function () {            var title = GM_getValue(SF_TITLE, &#39;&#39;)            var content = GM_getValue(SF_CONTENT, &#39;&#39;)            if (title != &#39;&#39; &amp;&amp; content != &#39;&#39;) {                $(&#39;#title&#39;).delay(2000).queue(function () {                    $(&#39;#title&#39;).val(title)                    GM_setClipboard(content, &#39;text&#39;)                    GM_deleteValue(SF_TITLE)                    GM_deleteValue(SF_CONTENT)                    $(this).dequeue()                })            }        })    }    function addCopyButton() {        $(&#39;body&#39;).append(&#39;&lt;div id=&quot;copyToCS&quot;&gt;双击复制到CSDN和思否&lt;/div&gt;&#39;)        $(&#39;#copyToCS&#39;).css(&#39;width&#39;, &#39;200px&#39;)        $(&#39;#copyToCS&#39;).css(&#39;position&#39;, &#39;absolute&#39;)        $(&#39;#copyToCS&#39;).css(&#39;top&#39;, &#39;70px&#39;)        $(&#39;#copyToCS&#39;).css(&#39;left&#39;, &#39;350px&#39;)        $(&#39;#copyToCS&#39;).css(&#39;background-color&#39;, &#39;#28a745&#39;)        $(&#39;#copyToCS&#39;).css(&#39;color&#39;, &#39;white&#39;)        $(&#39;#copyToCS&#39;).css(&#39;font-size&#39;, &#39;large&#39;)        $(&#39;#copyToCS&#39;).css(&#39;z-index&#39;, 100)        $(&#39;#copyToCS&#39;).css(&#39;border-radius&#39;, &#39;25px&#39;)        $(&#39;#copyToCS&#39;).css(&#39;text-align&#39;, &#39;center&#39;)        $(&#39;#copyToCS&#39;).dblclick(function () {            saveArticle()            GM_openInTab(SF_URL, true)            GM_openInTab(CSDN_URL, true)        })        $(&#39;#copyToCS&#39;).draggable()    }    $(document).ready(function () {        if (window.location.href.startsWith(&#39;https://www.jianshu.com&#39;)) {            addCopyButton()        } else if (window.location.href.startsWith(SF_URL)) {            copyToSegmentFault()        } else if (window.location.href.startsWith(CSDN_URL)) {            copyToCsdn()        }    })})()</code></pre><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><h4 id="脚本编写流程"><a href="#脚本编写流程" class="headerlink" title="脚本编写流程"></a>脚本编写流程</h4><p>踩了几天坑，最后总结一下编写油猴脚本的一点步骤。首先要思考脚本的实现方式，需要用到什么API和权限，然后填写好脚本的注释信息。</p><p>然后将功能封装成函数的形式，最后在脚本末尾调用实现的函数。写的差不多的时候复制到浏览器中尝试运行。</p><p>遇到困难的时候，可能需要直接在F12开发者工具里进行调试。有些网页不用jQuery，为了方便，我们需要自己将jQuery导入到页面中，可以将下面的代码复制到浏览器控制台中。</p><pre><code class="js">var jq = document.createElement(&#39;script&#39;);jq.src = &quot;https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js&quot;;document.getElementsByTagName(&#39;head&#39;)[0].appendChild(jq);</code></pre><h4 id="发布脚本"><a href="#发布脚本" class="headerlink" title="发布脚本"></a>发布脚本</h4><h5 id="更新URL"><a href="#更新URL" class="headerlink" title="更新URL"></a>更新URL</h5><p>脚本做完了，自然是要共享出来让大家一起使用的。当然既然要发布，自然要支持更新方便日后维护。方法也很简单，直接在上面的注释部分添加<code>updateURL</code>即可，然后设置脚本访问地址。例如我要将脚本发布到Github上，就添加下面的注释。</p><pre><code class="js">// @updateURL https://raw.githubusercontent.com/techstay/myscripts/master/tampermonkey/remind_me_vagrant_update.js</code></pre><h5 id="上传脚本"><a href="#上传脚本" class="headerlink" title="上传脚本"></a>上传脚本</h5><p>油猴脚本支持好几个网站，其中目前最主流的是<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">GreasyFork</a>，登录这个网站注册一个账号，然后进入用户页面选择提交脚本，然后填写脚本代码和各项信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/3346250129-51af0aada1db5227_fix732.png" alt="提交脚本" title="">                </div>                <div class="image-caption">提交脚本</div>            </figure><p>这样脚本就提交上去了，其他人也可以搜索到并安装脚本了！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/2044765339-3bf40f378ab7c24b_fix732.png" alt="提交脚本完成" title="">                </div>                <div class="image-caption">提交脚本完成</div>            </figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://segmentfault.com/a/1190000021654926" target="_blank" rel="noopener">油猴脚本编写教程-SegmentFault思否</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 油猴脚本 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode中使用git合并分支</title>
      <link href="/2022/06/20/vscode%E4%B8%AD%E4%BD%BF%E7%94%A8git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/"/>
      <url>/2022/06/20/vscode%E4%B8%AD%E4%BD%BF%E7%94%A8git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>首先我们有两个分支，一个是test分支，一个是main分支。我们现在要把test分支合并到main分支里面去。（就是说，test分支是比main分支早一个版本的）<br>另外，<strong>我们默认本地分支和线上分支版本是一样的</strong>，如果不一样要先pull一下。</p><p>test分支的内容 </p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719182820105.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>main分支的内容 </p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719182844500.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-把分支切换到本地的main分支"><a href="#1-把分支切换到本地的main分支" class="headerlink" title="1.把分支切换到本地的main分支"></a>1.把分支切换到本地的main分支</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719182939631.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意，本地的main分支是没有origin开头的。</p><h3 id="2-点击合并分支"><a href="#2-点击合并分支" class="headerlink" title="2. 点击合并分支"></a>2. 点击合并分支</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719183028248.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="3-选择开发的分支"><a href="#3-选择开发的分支" class="headerlink" title="3. 选择开发的分支"></a>3. 选择开发的分支</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719183138645.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里需要选择分支，我们选择本地的test分支。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719183234835.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后，我们看到main分支里面，就会出现刚刚test的内容了。而这时，只是本地的main分支合并了，线上的main分支还没被合并。我们需要再推送一下。</p><h3 id="4-将main分支推送到线上"><a href="#4-将main分支推送到线上" class="headerlink" title="4. 将main分支推送到线上"></a>4. 将main分支推送到线上</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719183358597.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="5-合并完成"><a href="#5-合并完成" class="headerlink" title="5.合并完成"></a>5.合并完成</h3><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/weixin_44004835/article/details/118908695" target="_blank" rel="noopener">vscode中使用git合并分支</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YAML中多行字符串的配置方法</title>
      <link href="/2022/06/18/YAML%E4%B8%AD%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
      <url>/2022/06/18/YAML%E4%B8%AD%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>有时候我们会在配置文件中配置一段文字说明，这种时候通常会出现两种需求：</p><ul><li>文字中可能出现段落，希望在配置中按段落方式编写，显示打印的时候也能出现段落换行。</li><li>文字很长，为方便编辑，可能在配置文件中分段写，但是显示的时候不喜欢出现配置中的段落换行。</li></ul><p>简单的说，就是：</p><ul><li>配置与显示，都严格按段落展示</li><li>配置按段落，显示不需要按段落</li></ul><p>假设，我们需要配置这样一段文字：</p><pre><code class="yaml">I am a coder.My blog is didispace.com.复制代码</code></pre><p>下面，就针对上面的两种情况来看看可以怎么来实现：</p><h3 id="配置与显示，都严格按段落展示"><a href="#配置与显示，都严格按段落展示" class="headerlink" title="配置与显示，都严格按段落展示"></a>配置与显示，都严格按段落展示</h3><p>这个需求下，我们希望配置和显示都按句子换行，就是这样：</p><pre><code class="yaml">I am a coder.My blog is didispace.com.复制代码</code></pre><h4 id="方法一：直接使用-n来换行"><a href="#方法一：直接使用-n来换行" class="headerlink" title="方法一：直接使用\n来换行"></a>方法一：直接使用<code>\n</code>来换行</h4><p>这样写：</p><pre><code class="yaml">string: &quot;I am a coder.\n\         My blog is didispace.com.&quot;复制代码</code></pre><p>最终输出：</p><pre><code class="yaml">I am a coder.My blog is didispace.com.复制代码</code></pre><p>通过<code>\n</code>在显示的时候换行，通过配置行末的<code>\</code>让这个字符串换行继续写（这个必须有，如果没有第二行行首会多一个空格）。</p><p><strong>注意</strong>：这里必须使用双引号来定义字符串，不能用单引号。因为单引号是不支持<code>\n</code>换行的。</p><h4 id="方法二：使用｜、｜-、｜"><a href="#方法二：使用｜、｜-、｜" class="headerlink" title="方法二：使用｜、｜+、｜-"></a>方法二：使用<code>｜</code>、<code>｜+</code>、<code>｜-</code></h4><p>在方法一种，其实我们在文字中加入了几个转义符号，其实对于阅读并不方便。在方法二中，将介绍更适合阅读的几种形式：</p><pre><code class="yaml">string: |  I am a coder.  My blog is didispace.com.string: |+  I am a coder.  My blog is didispace.com.string: |-  I am a coder.  My blog is didispace.com.复制代码</code></pre><p>如上面一共有三种配置都会自动按配置中所写的换行来换行，但是在文末会有一些区别，有的会增加一个空行，有的不会，有的会新增两个空行，具体说明如下：</p><ul><li><p><code>|</code>：文中自动换行 + 文末新增一空行</p></li><li><p><code>|+</code>：文中自动换行 + 文末新增两空行</p></li><li><p><code>|-</code>：文中自动换行 + 文末不新增行</p></li></ul><h3 id="配置按段落，显示不需要按段落"><a href="#配置按段落，显示不需要按段落" class="headerlink" title="配置按段落，显示不需要按段落"></a>配置按段落，显示不需要按段落</h3><p>这个需求下，我们希望配置里是按行写的，但是显示是如下面这样在一行的：</p><pre><code class="yaml">I am a coder.My blog is didispace.com.复制代码</code></pre><h4 id="方法一：直接在字符串中换行写"><a href="#方法一：直接在字符串中换行写" class="headerlink" title="方法一：直接在字符串中换行写"></a>方法一：直接在字符串中换行写</h4><p>最粗暴的写法，反正不用换行，那就直接写了：</p><pre><code class="yaml">string: &#39;I am a coder.         My blog is didispace.com.&#39;复制代码</code></pre><p>这里不论用双引号还是单引号都是可以的。因为不存在需要转移的内容，所以总体还算清晰。</p><h4 id="方法二：使用-gt-、-gt-、-gt"><a href="#方法二：使用-gt-、-gt-、-gt" class="headerlink" title="方法二：使用&gt;、&gt;+、&gt;-"></a>方法二：使用<code>&gt;</code>、<code>&gt;+</code>、<code>&gt;-</code></h4><p>比较好的表述方式就是使用<code>&gt;</code>、<code>&gt;+</code>、<code>&gt;-</code>来定义，比如下面这几种：</p><pre><code class="yaml">string: &gt;  I am a coder.  My blog is didispace.com.string: &gt;+  I am a coder.  My blog is didispace.com.string: &gt;-  I am a coder.  My blog is didispace.com.复制代码</code></pre><p>这三种都不会对配置中的换行进行实际换行，但是依然在文末的处理会有一些小区别，具体如下：</p><ul><li><p><code>&gt;</code>：文中不自动换行 + 文末新增一空行</p></li><li><p><code>&gt;+</code>：文中不自动换行 + 文末新增两空行</p></li><li><p><code>&gt;-</code>：文中不自动换行 + 文末不新增行</p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.cn/post/6844903972688363534" target="_blank" rel="noopener">YAML中多行字符串的配置方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YAML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-版本发布</title>
      <link href="/2022/06/18/Git-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"/>
      <url>/2022/06/18/Git-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h3 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20210707101238633.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20210707101247180.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="github-release"><a href="#github-release" class="headerlink" title="github release"></a>github release</h3><p>查看releases，会有很多版本，这些版本其实就是Git中的标签。<br>Git标签可以将现有或过去的提交点（Commit Point）打上标签，这个标签<br>可能是项目的一个里程碑或者一个重要节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20181213180038917.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>创建Github一个版本发布：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20181213180111885.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>-a 证明这个标签是注解的</li><li>-m 标签消息</li></ul><pre><code class="bash">git tag -a v1.0.1 -m &#39;msg&#39;</code></pre><p>在本地打上标签后，还要推送到远程库中，在Git术语中称之为Sharing Tag<br>使用命令<code>git show v1.0.0</code>（v1.0.0是标签名），来查看某标签的信息</p><pre><code class="bash">git show v1.0.0</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20181213194224114.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>确认无误后，可以将其通过<code>git push origin v1.0.0</code>命令推送到远程库，当然，较为罕见的情况，<br>你需要推送多个标签 <code>git push origin --tags</code>来代替</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20181213194503568.png" alt="git同步远程库标签" title="">                </div>                <div class="image-caption">git同步远程库标签</div>            </figure><pre><code class="bash">git push origin v1.0.0</code></pre><h3 id="删除标签并推送到远端"><a href="#删除标签并推送到远端" class="headerlink" title="删除标签并推送到远端"></a>删除标签并推送到远端</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/201812132001379.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><pre><code class="bash">git tag -d v1.0.0 git push origin :refs/tags/v1.0.0</code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/qq_33745102/article/details/84992778" target="_blank" rel="noopener">Git-版本发布</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xpath_详解</title>
      <link href="/2022/06/12/Xpath_%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/12/Xpath_%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Xpath？"><a href="#什么是-Xpath？" class="headerlink" title="什么是 Xpath？"></a>什么是 Xpath？</h2><p>Xpath 是一种用在 XML 文档中定位元素的语言，同样也支持 HTML 元素的解析。</p><p>所谓 Xpath，是指 XML path language。path 就是路径，那么 Xpath 主要是通过路径来查找元素。</p><p>我们通过下面一张小图来了解一下 HTML 中的结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-1d5d648e03370891.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>HTML 的结构就是树形结构，HTML 是根节点，所有的其他元素节点都是从根节点发出的。其他的元素都是这棵树上的节点<code>Node</code>，每个节点还可能有属性和文本。</p><ul><li>而路径就是指某个节点到另一个节点的路线。</li></ul><p>节点之间存在各种关系：</p><ul><li><p>父节点(Parent)： HTML 是 body 和 head 节点的父节点；</p></li><li><p>子节点(Child)：head 和 body 是 HTML 的子节点；</p></li><li><p>兄弟节点(Sibling)：拥有相同的父节点，head 和 body 就是兄弟节点。title 和 div 不是兄弟，因为他们不是同一个父节点。</p></li><li><p>祖先节点(Ancestor)：body 是 form 的祖先节点，爷爷辈及以上👴；</p></li><li><p>后代节点(Descendant)：form 是 HTML 的后代节点，孙子辈及以下👶。</p></li></ul><p>Xpath 中的绝对路径从 HTML 根节点开始算，相对路径从任意节点开始。</p><p>通过开发者工具，我们可以拷贝到 Xpath 的绝对路径和相对路径代码：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-3ce3a8737955cffe.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但是由于拷贝出来的代码缺乏灵活性，也不全然准确。大部分情况下，都需要自己定义 Xpath 语句，因此 Xpath 语法还是有必要学习。</p><h2 id="绝对路径："><a href="#绝对路径：" class="headerlink" title="绝对路径："></a>绝对路径：</h2><p>Xpath 中最直观的定位策略就是绝对路径。</p><p>以百度中的输入框和按钮为例，通过拷贝出来的 full Xpath：</p><pre><code class="python">/html/body/div[2]/div/div/div/div/form/span/input</code></pre><p>这就是一个绝对路径我们可以看出，绝对路径是从根节点<code>/html</code>开始往下，一层层的表示出来直到需要的节点为止。</p><p>这明显不是理智的选项，因此了解以下即可，不用往心里去。</p><h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>除了绝对路径，Xpath 中更常用的方式是相对路径定位方法，以“//”开头。</p><p>相对路径可以从任意节点开始，一般我们会选取一个可以唯一定位到的元素开始写，可以增加查找的准确性。</p><p>相对路径可以通过以下的方式来定位元素：</p><h3 id="基本定位语法"><a href="#基本定位语法" class="headerlink" title="基本定位语法"></a>基本定位语法</h3><p>定位语法主要依赖于以下特殊符号：</p><table><thead><tr><th>表达式</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>/</code></td><td>从根节点开始选取</td><td>/html/div/span</td></tr><tr><td><code>//</code></td><td>从任意节点开始选取</td><td>//input</td></tr><tr><td><code>.</code></td><td>选取当前节点</td><td></td></tr><tr><td><code>..</code></td><td>选取当前节点的父节点</td><td>//input/.. 会选取 input 的父节点</td></tr><tr><td><code>@</code></td><td>选取属性，或者根据属性选取</td><td>//input[@data] 选取具备 data 属性的 input 元素 //@data 选取所有 data 属性</td></tr><tr><td><code>*</code></td><td>通配符，表示任意节点或任意属性</td><td></td></tr></tbody></table><h3 id="元素属性定位"><a href="#元素属性定位" class="headerlink" title="元素属性定位"></a>元素属性定位</h3><p>属性定位是通过 @ 符号指定需要使用的属性。</p><ul><li>根据元素是否具备某个属性查找元素</li></ul><pre><code class="python">//*[@data-recordid]</code></pre><p>选取包含data-recordid属性的所有节点。可以定位到以下元素：</p><pre><code class="python">&lt;tr role=&quot;row&quot; data-boundview=&quot;gridview-1029&quot; data-recordid=&quot;B36BCA33&quot; &gt;&lt;/tr&gt;</code></pre><ul><li>根据属性是否等于某值查找元素</li></ul><pre><code class="python">//span[@role=&#39;img&#39;]</code></pre><p>选取属性 role 的属性值为 img 的所有节点。可以定位到以下元素：</p><pre><code class="python">&lt;span role=&quot;img&quot; class=&quot;x-btn-icon-el&quot; unselectable=&quot;on&quot; style=&quot;&quot;&gt;&lt;/span&gt;</code></pre><p>注意，属性值必须要加引号，单双引号都可以。</p><h3 id="层级属性结合定位"><a href="#层级属性结合定位" class="headerlink" title="层级属性结合定位"></a>层级属性结合定位</h3><p>遇到某些元素无法精确定位的时候，可以查找其父级及其祖先节点，找到有确定的祖先节点后通过层级依次向下定位。</p><p>以下面的结构为例：</p><ul><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-1187d4bb553f53c6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><pre><code class="python">&lt;form action=&quot;search&quot; id=&quot;form&quot; method=&quot;post&quot;&gt;    &lt;span class=&quot;bg&quot;&gt;        &lt;span class=&quot;soutu&quot;&gt;搜索&lt;/span&gt;    &lt;/span&gt;    &lt;span class=&quot;soutu&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;key&quot; id=&quot;su&quot;&gt;    &lt;/span&gt;&lt;/form&gt;</code></pre><ul><li>根据层级向下找，从 form 找到绿色的 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span/span</code></pre><ul><li>查找某元素内部的所有元素，选取 form 元素内部的所有 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]//span</code></pre><p>第二个双斜杠，表示选取内部所有的 span，不管层级关系</p><ul><li>使用星号找不特定的元素</li></ul><pre><code class="python">//*[@id=&quot;form&quot;]//*[@type=&quot;text&quot;]</code></pre><p>选取 id 属性为 form 的任意属性内部，并且 type 属性为 text 的任意元素。这里会找到 input。</p><ul><li>使用<code>..</code>从下往上找，根据 input 查找其父节点 span：</li></ul><pre><code class="python">//input[@name=&quot;key&quot;]/..</code></pre><p>注意最后的两个点，找到 input 节点的上级节点，如果还要再往上再加 <code>/..</code></p><ul><li>找同级节点：</li><li>比如我们想通过第一个 span 标签去 找 div 标签。树形结构中，兄弟节点之间的关系是通过父节点建立起来的。所以可以先找到父节点，再通过父节点找同级节点。</li></ul><pre><code class="python">//span[@class=&quot;bg&quot;]/../div</code></pre><p>先通过<code>/..</code>找到 span 的父节点，再通过父节点找到 div。</p><h3 id="使用谓语定位"><a href="#使用谓语定位" class="headerlink" title="使用谓语定位"></a>使用谓语定位</h3><p>谓语是 Xpath 中用于描述元素位置。主要有数字下标、最后一个子元素<code>last()</code>、元素下标函数<code>position()</code>。</p><ul><li>使用下标的方式，从 form 找到 input ：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span[2]/input</code></pre><p>Xpath 中的下标从 <code>1</code> 开始。</p><ul><li>查找最后一个子元素，选取 form 下的最后一个 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span[last()]</code></pre><ul><li>查找倒数第几个子元素，选取 form 下的倒数第一个 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span[last()-1]</code></pre><ul><li>使用 position() 函数，选取 from 下第二个 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span[position()=2]</code></pre><ul><li>使用 position() 函数，选取下标大于 2 的 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span[position()&gt;2]</code></pre><h3 id="使用逻辑运算符"><a href="#使用逻辑运算符" class="headerlink" title="使用逻辑运算符"></a>使用逻辑运算符</h3><p>如果元素的某个属性无法精确定位到这个元素，我们还可以用逻辑运算符 and 连接多个属性进行定位，以百度输入框为例。</p><ul><li>使用 <code>and</code> ：</li></ul><pre><code class="python">//*[@name=&#39;wd&#39; and @class=&#39;s_ipt&#39;]</code></pre><p>查找 name 属性为 wd 并且 class 属性为 s_ipt 的任意元素</p><ul><li>使用 <code>or</code>：</li></ul><pre><code class="python">//*[@name=&#39;wd&#39; or @class=&#39;s_ipt&#39;]</code></pre><p>查找 name 属性为 wd 或者 class 属性为 s_ipt 的任意元素，取其中之一满足即可。</p><ul><li>使用<code>|</code>，同时查找多个路径，取或：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]//span | //form[@id=&quot;form&quot;]//input</code></pre><p>选取 form 下所有的 span 和所有的 input。</p><h3 id="使用文本定位"><a href="#使用文本定位" class="headerlink" title="使用文本定位"></a>使用文本定位</h3><p>使用文本定位，是 Xpath 中的一大特色。在自动化测试中，为了让代码的可读性更高，可以使用文本的方式。</p><p>以下一个案例：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-466743dbeb77cb6f.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>部分网页结构如下：</p><pre><code class="python">&lt;tr&gt;  &lt;td valign=&quot;top&quot;&gt;    &lt;input type=&quot;radio&quot; name=&quot;payment&quot; value=&quot;1&quot; checked=&quot;&quot; iscod=&quot;0&quot;&gt;  &lt;/td&gt;  &lt;td valign=&quot;top&quot;&gt;    &lt;strong&gt;支付宝&lt;/strong&gt;  &lt;/td&gt;&lt;/tr&gt;</code></pre><p>其实我们需要点的是前的单选框，但是单选框没有任何特殊的标识，不够灵活。我们可以通过后面的名称，如(支付宝、余额支付等)来找到其对应行的 radio，再去点击。</p><p>我们就需要先通过文本定位到“支付宝”，再去找其同一行(tr)的 input 节点。如果理不清楚，我们可以先画一个结构图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-443ad23bb513cce3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>红色箭头表示查找路径，先定位到“支付宝”所在的 strong，再定位 <code>td -&gt; tr -&gt; td - &gt;input</code> 。那么要定位“支付宝”文本，就需要用到 Xpath 中的函数 <code>text()</code> 或 <code>string()</code>，注意是函数，所以括号不能少。</p><p><code>text()</code>：当前元素节点包含的文本内容；</p><ul><li>表达式<code>//div[text()=&quot;文本&quot;]</code>，能找到：</li></ul><pre><code class="python">&lt;div&gt;文本&lt;/div&gt;</code></pre><p>不能找到：</p><pre><code class="python">&lt;div&gt;&lt;span&gt;文本&lt;/span&gt;&lt;/div&gt;</code></pre><p><code>string()</code>：当前元素节点内部所有节点元素的文本内容。表达式<code>//div[string()=&quot;文本&quot;]</code>上述两种情况都能找到。</p><p>好，接着写上面的内容。先通过 <code>//strong[text()=&quot;支付宝&quot;]</code>定位到“支付宝”所在的元素 strong，再找上级 td -&gt; tr，再向下找：</p><pre><code class="python">//strong[text()=&quot;支付宝&quot;]/../../td[1]/input</code></pre><p>也可以写为：</p><pre><code class="python">//td[string()=&quot;支付宝&quot;]/../td[1]/input</code></pre><h3 id="使用部分匹配函数"><a href="#使用部分匹配函数" class="headerlink" title="使用部分匹配函数"></a>使用部分匹配函数</h3><p>Xpath 中有提供了几个函数，用来进行部分匹配。</p><table><thead><tr><th>函数</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>contains</td><td>选取属性或者文本包含某些字符</td><td>//div[contains(@id, ‘data’)] 选取 id 属性包含 data 的 div 元素  //div[contains(string(), ‘支付宝’)] 选取内部文本包含“支付宝”的 div 元素</td></tr><tr><td>starts-with</td><td>选取属性或者文本以某些字符开头</td><td>//div[starts-with(@id, ‘data’)] 选取 id 属性以 data 开头的 div 元素  //div[starts-with(string(), ‘银联’)] 选取内部文本以“银联”开头的 div 元素</td></tr><tr><td>ends-with</td><td>选取属性或者文本以某些字符开头</td><td>//div[ends-with(@id, ‘require’)] 选取 id 属性以 require 结尾的 div 元素  //div[ends-with(string(), ‘支付’)] 选取内部文本以“支付”结尾的 div 元素</td></tr></tbody></table><h2 id="验证-Xpath"><a href="#验证-Xpath" class="headerlink" title="验证 Xpath"></a>验证 Xpath</h2><p>验证 xpath 有两种方法：</p><ul><li>在开发者工具的 Elements 中按<code>Ctrl + F</code>，在搜索框中输入 Xpath：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-a9ed19d1dffab883.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>在开发者工具的 Console 中使用 <code>$x()</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-1d6c86e9e1723c6a.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/6a0dbb4e246a" target="_blank" rel="noopener">Xpath_详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Xpath </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最完美方案！模拟浏览器如何正确隐藏特征</title>
      <link href="/2022/06/10/%E6%9C%80%E5%AE%8C%E7%BE%8E%E6%96%B9%E6%A1%88%EF%BC%81%E6%A8%A1%E6%8B%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%9A%90%E8%97%8F%E7%89%B9%E5%BE%81/"/>
      <url>/2022/06/10/%E6%9C%80%E5%AE%8C%E7%BE%8E%E6%96%B9%E6%A1%88%EF%BC%81%E6%A8%A1%E6%8B%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%9A%90%E8%97%8F%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>在前天的公众号文章<a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&mid=2648979700&idx=1&sn=ec98a4dd7ad660ad8af664942c25072f&scene=21#wechat_redirect" target="_blank" rel="noopener">《别去送死了。Selenium 与 Puppeteer 能被网站探测的几十个特征》</a>中，我们提到目前网上的反检测方法几乎都是掩耳盗铃，因为模拟浏览器有几十个特征可以被检测，仅仅隐藏 webdriver 这一个值是没有任何意义的。</p><p>今天我们就来说说应该如何正确解决这个问题。我们首先给出解决方案。然后再说明这个解决方案，我是通过什么方式找到的。<br>解决这个问题的关键，就是一个 js 文件，叫做<code>stealth.min.js</code>。稍后我会说明如何生成这个文件。<br>我们需要设定，让 Selenium 或者 Pyppeteer 在打开任何页面<strong>之前</strong>，先运行这个 Js 文件。具体的做法和原理，大家可以参考我这两篇文章：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&mid=2648978304&idx=1&sn=bff6a1f03b29702f2393a9fef9a50452&scene=21#wechat_redirect" target="_blank" rel="noopener">（最新版）如何正确移除Selenium中的 window.navigator.webdriver</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&mid=2648978312&idx=1&sn=516564fbb02aca47a1e8b19e1ed9a167&chksm=f2506e68c527e77eca1c987af90c427bdb1c746f0bff6973d1f1a8dcb7d41c814b74af745c87&token=465047301&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">（最新版）如何正确移除 Pyppeteer 中的window.navigator.webdriver</a><br>这里，我以 Selenium 为例来说明如何操作，我们编写如下代码：</p><pre><code class="python">import timefrom selenium.webdriver import Chromefrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument(&quot;--headless&quot;)chrome_options.add_argument(&#39;user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#39;)driver = Chrome(&#39;./chromedriver&#39;, options=chrome_options)with open(&#39;/Users/kingname/test_pyppeteer/stealth.min.js&#39;) as f:    js = f.read()driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, {  &quot;source&quot;: js})driver.get(&#39;https://bot.sannysoft.com/&#39;)time.sleep(5)driver.save_screenshot(&#39;walkaround.png&#39;)# 你可以保存源代码为 html 再双击打开，查看完整结果source = driver.page_sourcewith open(&#39;result.html&#39;, &#39;w&#39;) as f:    f.write(source)  </code></pre><p>运行截图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/最完美方案！模拟浏览器如何正确隐藏特征/1654940870.049451.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以看到，虽然我使用的是无头模式，但是能够被识别的特征都被成功隐藏。大家还可以双击打开保存下来的 html 文件，看看是不是结果跟普通浏览器几乎一样。<br>如果你使用的是 Pyppeteer，那么可以根据我上面文章中给出的方法，试着加载一下这个 js 文件，看看是不是也能成功隐藏特征。<br>那么，这个<code>stealth.min.js</code>文件是怎么来的呢？这就要说到<code>puppeteer</code>了。我们知道，Python 版本的<code>pyppeteer</code>已经很久没有人维护了，但是Node.js 版本的 <code>puppeteer</code>持续有人维护，并且在持续更新，生态也越来越好。<br>有开发者给 puppeteer 写了一套插件，叫做<code>puppeteer-extra</code>。其中，就有一个插件叫做puppeteer-extra-plugin-stealth[1]。这个东西，就来专门用来让 puppeteer 隐藏模拟浏览器的指纹特征。<br>这个东西是专门给 puppeteer 用的。所以，如果你使用的是 puppeteer，那么你可以根据它的 Readme说明，直接使用。<br>那么，我们用 Python 的人怎么办呢？实际上也有办法。就是把其中的隐藏特征的脚本提取出来，做成一个单独的 js 文件。然后让 Selenium 或者 Pyppeteer 在打开任意网页之前，先运行一下这个 js 文件里面的内容。<br>puppeteer-extra-plugin-stealth的作者还写了另外一个工具，叫做extract-stealth-evasions[2]。这个东西就是用来生成<code>stealth.min.js</code>文件的。<br>如果你在国外，并且网速足够快的话。那么你根据它的 Readme，首先安装 Node.js，然后安装 Npm，接着运行如下命令：</p><pre><code class="bash">npx extract-stealth-evasions </code></pre><p>就会在你执行命令的文件夹下面生成一个<code>stealth.min.js</code>文件。然后你就可以正常使用了。<br>如果你在国内，那么执行这个命令的过程中，会有一个下载 Chromium 的过程，速度非常慢，虽然只有130MB，但是可能会下载好几个小时。<br>此时，你需要把它的<code>package.json</code>和<code>index.js</code>两个文件保存到本地。然后打开<code>package.json</code>文件，修改其中的<code>dependencies</code>这一项，把里面的<code>puppeteer</code>改成<code>puppeteer-core</code>，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/最完美方案！模拟浏览器如何正确隐藏特征/1654940870.356005.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后修改<code>index.js</code>，给<code>.launch()</code>函数增加一个参数<code>executablePath</code>，指向你电脑上的 Chrome 浏览器，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/最完美方案！模拟浏览器如何正确隐藏特征/1654940870.654757.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>修改完成以后。首先执行<code>yarn install</code>安装依赖包。然后执行<code>node index.js</code>运行程序。1秒钟以后就会生成<code>stealth.min.js</code>了。<br>如果你对 Node.js 的工具链不熟悉，不知道如何使用。那么你可以关注公众号未闻 Code，回复<code>stealth</code>获取这个 js 文件。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&mid=2648979719&idx=1&sn=71fe9932ae38f2f630f9c817033401dd&chksm=f25064e7c527edf17d617ef28928982c7df6e248d8980758c22a9e0cac67993d51f42da21031&cur_album_id=1318368205836189696&scene=189#wechat_redirect" target="_blank" rel="noopener">最完美方案！模拟浏览器如何正确隐藏特征</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_运维必会的150个常用命令，你都会用吗？</title>
      <link href="/2022/06/10/Linux_%E8%BF%90%E7%BB%B4%E5%BF%85%E4%BC%9A%E7%9A%84150%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BD%A0%E9%83%BD%E4%BC%9A%E7%94%A8%E5%90%97%EF%BC%9F/"/>
      <url>/2022/06/10/Linux_%E8%BF%90%E7%BB%B4%E5%BF%85%E4%BC%9A%E7%9A%84150%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BD%A0%E9%83%BD%E4%BC%9A%E7%94%A8%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>linux 命令是对 Linux 系统进行管理的命令。对于 Linux 系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件， Linux 系统管理的命令是它正常运行的核心，与之前的 DOS 命令类似。linux 命令在系统中有两种类型：内置 Shell 命令和 Linux 命令。</p><h3 id="线上查询及帮助命令-2-个"><a href="#线上查询及帮助命令-2-个" class="headerlink" title="线上查询及帮助命令 (2 个)"></a>线上查询及帮助命令 (2 个)</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>man</td><td>查看命令帮助，命令的词典，更复杂的还有 info，但不常用。</td></tr><tr><td>help</td><td>查看 Linux 内置命令的帮助，比如 cd 命令。</td></tr></tbody></table><h3 id="文件和目录操作命令-18-个"><a href="#文件和目录操作命令-18-个" class="headerlink" title="文件和目录操作命令 (18 个)"></a>文件和目录操作命令 (18 个)</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>ls</td><td>全拼 list，功能是列出目录的内容及其内容属性信息。</td></tr><tr><td>cd</td><td>全拼 change directory，功能是从当前工作目录切换到指定的工作目录。</td></tr><tr><td>cp</td><td>全拼 copy，其功能为复制文件或目录。</td></tr><tr><td>find</td><td>查找的意思，用于查找目录及目录下的文件。</td></tr><tr><td>mkdir</td><td>全拼 make directories，其功能是创建目录。</td></tr><tr><td>mv</td><td>全拼 move，其功能是移动或重命名文件。</td></tr><tr><td>pwd</td><td>全拼 print working directory，其功能是显示当前工作目录的绝对路径。</td></tr><tr><td>rename</td><td>用于重命名文件。</td></tr><tr><td>rm</td><td>全拼 remove，其功能是删除一个或多个文件或目录。</td></tr><tr><td>rmdir</td><td>全拼 remove empty directories，功能是删除空目录。</td></tr><tr><td>touch</td><td>创建新的空文件，改变已有文件的时间戳属性。</td></tr><tr><td>tree</td><td>功能是以树形结构显示目录下的内容。</td></tr><tr><td>basename</td><td>显示文件名或目录名。</td></tr><tr><td>dirname</td><td>显示文件或目录路径。</td></tr><tr><td>chattr</td><td>改变文件的扩展属性。</td></tr><tr><td>lsattr</td><td>查看文件扩展属性。</td></tr><tr><td>file</td><td>显示文件的类型。</td></tr><tr><td>md5sum</td><td>计算和校验文件的 MD5 值。</td></tr></tbody></table><h3 id="查看文件及内容处理命令（21-个）"><a href="#查看文件及内容处理命令（21-个）" class="headerlink" title="查看文件及内容处理命令（21 个）"></a>查看文件及内容处理命令（21 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>cat</td><td>全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。</td></tr><tr><td>tac</td><td>tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。</td></tr><tr><td>more</td><td>分页显示文件内容。</td></tr><tr><td>less</td><td>分页显示文件内容，more 命令的相反用法。</td></tr><tr><td>head</td><td>显示文件内容的头部。</td></tr><tr><td>tail</td><td>显示文件内容的尾部。</td></tr><tr><td>cut</td><td>将文件的每一行按指定分隔符分割并输出。</td></tr><tr><td>split</td><td>分割文件为不同的小片段。</td></tr><tr><td>paste</td><td>按行合并文件内容。</td></tr><tr><td>sort</td><td>对文件的文本内容排序。</td></tr><tr><td>uniq</td><td>去除重复行。oldboy</td></tr><tr><td>wc</td><td>统计文件的行数、单词数或字节数。</td></tr><tr><td>iconv</td><td>转换文件的编码格式。</td></tr><tr><td>dos2unix</td><td>将 DOS 格式文件转换成 UNIX 格式。</td></tr><tr><td>diff</td><td>全拼 difference，比较文件的差异，常用于文本文件。</td></tr><tr><td>vimdiff</td><td>命令行可视化文件比较工具，常用于文本文件。</td></tr><tr><td>rev</td><td>反向输出文件内容。</td></tr><tr><td>grep/egrep</td><td>过滤字符串，三剑客老三。</td></tr><tr><td>join</td><td>按两个文件的相同字段合并。</td></tr><tr><td>tr</td><td>替换或删除字符。</td></tr><tr><td>vi/vim</td><td>命令行文本编辑器。</td></tr></tbody></table><h3 id="文件压缩及解压缩命令（4-个）"><a href="#文件压缩及解压缩命令（4-个）" class="headerlink" title="文件压缩及解压缩命令（4 个）"></a>文件压缩及解压缩命令（4 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>tar</td><td>打包压缩。oldboy</td></tr><tr><td>unzip</td><td>解压文件。</td></tr><tr><td>gzip</td><td>gzip 压缩工具。</td></tr><tr><td>zip</td><td>压缩工具。</td></tr></tbody></table><h3 id="信息显示命令（11-个）"><a href="#信息显示命令（11-个）" class="headerlink" title="信息显示命令（11 个）"></a>信息显示命令（11 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>uname</td><td>显示操作系统相关信息的命令。</td></tr><tr><td>hostname</td><td>显示或者设置当前系统的主机名。</td></tr><tr><td>dmesg</td><td>显示开机信息，用于诊断系统故障。</td></tr><tr><td>uptime</td><td>显示系统运行时间及负载。</td></tr><tr><td>stat</td><td>显示文件或文件系统的状态。</td></tr><tr><td>du</td><td>计算磁盘空间使用情况。</td></tr><tr><td>df</td><td>报告文件系统磁盘空间的使用情况。</td></tr><tr><td>top</td><td>实时显示系统资源使用情况。</td></tr><tr><td>free</td><td>查看系统内存。</td></tr><tr><td>date</td><td>显示与设置系统时间。</td></tr><tr><td>cal</td><td>查看日历等时间信息。</td></tr></tbody></table><h3 id="搜索文件命令（4-个）"><a href="#搜索文件命令（4-个）" class="headerlink" title="搜索文件命令（4 个）"></a>搜索文件命令（4 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>which</td><td>查找二进制命令，按环境变量 PATH 路径查找。</td></tr><tr><td>find</td><td>从磁盘遍历查找文件或目录。</td></tr><tr><td>whereis</td><td>查找二进制命令，按环境变量 PATH 路径查找。</td></tr><tr><td>locate</td><td>从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。</td></tr></tbody></table><h3 id="用户管理命令（10-个）"><a href="#用户管理命令（10-个）" class="headerlink" title="用户管理命令（10 个）"></a>用户管理命令（10 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>useradd</td><td>添加用户。</td></tr><tr><td>usermod</td><td>修改系统已经存在的用户属性。</td></tr><tr><td>userdel</td><td>删除用户。</td></tr><tr><td>groupadd</td><td>添加用户组。</td></tr><tr><td>passwd</td><td>修改用户密码。</td></tr><tr><td>chage</td><td>修改用户密码有效期限。</td></tr><tr><td>id</td><td>查看用户的 uid,gid 及归属的用户组。</td></tr><tr><td>su</td><td>切换用户身份。</td></tr><tr><td>visudo</td><td>编辑 / etc/sudoers 文件的专属命令。</td></tr><tr><td>sudo</td><td>以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。</td></tr></tbody></table><h3 id="基础网络操作命令（11-个）"><a href="#基础网络操作命令（11-个）" class="headerlink" title="基础网络操作命令（11 个）"></a>基础网络操作命令（11 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>telnet</td><td>使用 TELNET 协议远程登录。</td></tr><tr><td>ssh</td><td>使用 SSH 加密协议远程登录。</td></tr><tr><td>scp</td><td>全拼 secure copy，用于不同主机之间复制文件。</td></tr><tr><td>wget</td><td>命令行下载文件。</td></tr><tr><td>ping</td><td>测试主机之间网络的连通性。</td></tr><tr><td>route</td><td>显示和设置 linux 系统的路由表。</td></tr><tr><td>ifconfig</td><td>查看、配置、启用或禁用网络接口的命令。</td></tr><tr><td>ifup</td><td>启动网卡。</td></tr><tr><td>ifdown</td><td>关闭网卡。</td></tr><tr><td>netstat</td><td>查看网络状态。</td></tr><tr><td>ss</td><td>查看网络状态。</td></tr></tbody></table><h3 id="深入网络操作命令（9-个）"><a href="#深入网络操作命令（9-个）" class="headerlink" title="深入网络操作命令（9 个）"></a>深入网络操作命令（9 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>nmap</td><td>网络扫描命令。</td></tr><tr><td>lsof</td><td>全名 list open files，也就是列举系统中已经被打开的文件。</td></tr><tr><td>mail</td><td>发送和接收邮件。</td></tr><tr><td>mutt</td><td>邮件管理命令。</td></tr><tr><td>nslookup</td><td>交互式查询互联网 DNS 服务器的命令。</td></tr><tr><td>dig</td><td>查找 DNS 解析过程。</td></tr><tr><td>host</td><td>查询 DNS 的命令。</td></tr><tr><td>traceroute</td><td>追踪数据传输路由状况。</td></tr><tr><td>tcpdump</td><td>命令行的抓包工具。</td></tr></tbody></table><h3 id="有关磁盘与文件系统的命令（16-个）"><a href="#有关磁盘与文件系统的命令（16-个）" class="headerlink" title="有关磁盘与文件系统的命令（16 个）"></a>有关磁盘与文件系统的命令（16 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>mount</td><td>挂载文件系统。</td></tr><tr><td>umount</td><td>卸载文件系统。</td></tr><tr><td>fsck</td><td>检查并修复 Linux 文件系统。</td></tr><tr><td>dd</td><td>转换或复制文件。</td></tr><tr><td>dumpe2fs</td><td>导出 ext2/ext3/ext4 文件系统信息。</td></tr><tr><td>dump</td><td>ext2/3/4 文件系统备份工具。</td></tr><tr><td>fdisk</td><td>磁盘分区命令，适用于 2TB 以下磁盘分区。</td></tr><tr><td>parted</td><td>磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。</td></tr><tr><td>mkfs</td><td>格式化创建 Linux 文件系统。</td></tr><tr><td>partprobe</td><td>更新内核的硬盘分区表信息。</td></tr><tr><td>e2fsck</td><td>检查 ext2/ext3/ext4 类型文件系统。</td></tr><tr><td>mkswap</td><td>创建 Linux 交换分区。</td></tr><tr><td>swapon</td><td>启用交换分区。</td></tr><tr><td>swapoff</td><td>关闭交换分区。</td></tr><tr><td>sync</td><td>将内存缓冲区内的数据写入磁盘。</td></tr><tr><td>resize2fs</td><td>调整 ext2/ext3/ext4 文件系统大小。</td></tr></tbody></table><h3 id="系统权限及用户授权相关命令（4-个）"><a href="#系统权限及用户授权相关命令（4-个）" class="headerlink" title="系统权限及用户授权相关命令（4 个）"></a>系统权限及用户授权相关命令（4 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>chmod</td><td>改变文件或目录权限。</td></tr><tr><td>chown</td><td>改变文件或目录的属主和属组。</td></tr><tr><td>chgrp</td><td>更改文件用户组。</td></tr><tr><td>umask</td><td>显示或设置权限掩码。</td></tr></tbody></table><h3 id="查看系统用户登陆信息的命令（7-个）"><a href="#查看系统用户登陆信息的命令（7-个）" class="headerlink" title="查看系统用户登陆信息的命令（7 个）"></a>查看系统用户登陆信息的命令（7 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>whoami</td><td>显示当前有效的用户名称，相当于执行 id -un 命令。</td></tr><tr><td>who</td><td>显示目前登录系统的用户信息。</td></tr><tr><td>w</td><td>显示已经登陆系统的用户列表，并显示用户正在执行的指令。</td></tr><tr><td>last</td><td>显示登入系统的用户。</td></tr><tr><td>lastlog</td><td>显示系统中所有用户最近一次登录信息。</td></tr><tr><td>users</td><td>显示当前登录系统的所有用户的用户列表。</td></tr><tr><td>finger</td><td>查找并显示用户信息。</td></tr></tbody></table><h3 id="内置命令及其它（19-个）"><a href="#内置命令及其它（19-个）" class="headerlink" title="内置命令及其它（19 个）"></a>内置命令及其它（19 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>echo</td><td>打印变量，或直接输出指定的字符串</td></tr><tr><td>printf</td><td>将结果格式化输出到标准输出。</td></tr><tr><td>rpm</td><td>管理 rpm 包的命令。</td></tr><tr><td>yum</td><td>自动化简单化地管理 rpm 包的命令。</td></tr><tr><td>watch</td><td>周期性的执行给定的命令，并将命令的输出以全屏方式显示。</td></tr><tr><td>alias</td><td>设置系统别名。</td></tr><tr><td>unalias</td><td>取消系统别名。</td></tr><tr><td>date</td><td>查看或设置系统时间。</td></tr><tr><td>clear</td><td>清除屏幕，简称清屏。</td></tr><tr><td>history</td><td>查看命令执行的历史纪录。</td></tr><tr><td>eject</td><td>弹出光驱。</td></tr><tr><td>time</td><td>计算命令执行时间。</td></tr><tr><td>nc</td><td>功能强大的网络工具。</td></tr><tr><td>xargs</td><td>将标准输入转换成命令行参数。</td></tr><tr><td>exec</td><td>调用并执行指令的命令。</td></tr><tr><td>export</td><td>设置或者显示环境变量。</td></tr><tr><td>unset</td><td>删除变量或函数。</td></tr><tr><td>type</td><td>用于判断另外一个命令是否是内置命令。</td></tr><tr><td>bc</td><td>命令行科学计算器</td></tr></tbody></table><h3 id="系统管理与性能监视命令-9-个"><a href="#系统管理与性能监视命令-9-个" class="headerlink" title="系统管理与性能监视命令 (9 个)"></a>系统管理与性能监视命令 (9 个)</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>chkconfig</td><td>管理 Linux 系统开机启动项。</td></tr><tr><td>vmstat</td><td>虚拟内存统计。</td></tr><tr><td>mpstat</td><td>显示各个可用 CPU 的状态统计。</td></tr><tr><td>iostat</td><td>统计系统 IO。</td></tr><tr><td>sar</td><td>全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。</td></tr><tr><td>ipcs</td><td>用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。</td></tr><tr><td>ipcrm</td><td>用来删除一个或更多的消息队列、信号量集或者共享内存标识。</td></tr><tr><td>strace</td><td>用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</td></tr><tr><td>ltrace</td><td>命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。</td></tr></tbody></table><h3 id="关机-重启-注销和查看系统信息的命令（6-个）"><a href="#关机-重启-注销和查看系统信息的命令（6-个）" class="headerlink" title="关机 / 重启 / 注销和查看系统信息的命令（6 个）"></a>关机 / 重启 / 注销和查看系统信息的命令（6 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>shutdown</td><td>关机。</td></tr><tr><td>halt</td><td>关机。</td></tr><tr><td>poweroff</td><td>关闭电源。</td></tr><tr><td>logout</td><td>退出当前登录的 Shell。</td></tr><tr><td>exit</td><td>退出当前登录的 Shell。</td></tr><tr><td>Ctrl+d</td><td>退出当前登录的 Shell 的快捷键。</td></tr></tbody></table><h3 id="进程管理相关命令（15-个）"><a href="#进程管理相关命令（15-个）" class="headerlink" title="进程管理相关命令（15 个）"></a>进程管理相关命令（15 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>bg</td><td>将一个在后台暂停的命令，变成继续执行  （在后台执行）。</td></tr><tr><td>fg</td><td>将后台中的命令调至前台继续运行。</td></tr><tr><td>jobs</td><td>查看当前有多少在后台运行的命令。</td></tr><tr><td>kill</td><td>终止进程。</td></tr><tr><td>killall</td><td>通过进程名终止进程。</td></tr><tr><td>pkill</td><td>通过进程名终止进程。</td></tr><tr><td>crontab</td><td>定时任务命令。</td></tr><tr><td>ps</td><td>显示进程的快照。</td></tr><tr><td>pstree</td><td>树形显示进程。</td></tr><tr><td>nice/renice</td><td>调整程序运行的优先级。</td></tr><tr><td>nohup</td><td>忽略挂起信号运行指定的命令。</td></tr><tr><td>pgrep</td><td>查找匹配条件的进程。</td></tr><tr><td>runlevel</td><td>查看系统当前运行级别。</td></tr><tr><td>init</td><td>切换运行级别。</td></tr><tr><td>service</td><td>启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</td></tr></tbody></table><p>Linux，全称GNU/Linux，是一套免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年第一次释出，它主要受到Minix和Unix思想的启发，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://z.itpub.net/article/detail/E8C122A4CA07F3EC5952EE9F0B233DD4" target="_blank" rel="noopener">Linux_运维必会的150个常用命令，你都会用吗？</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium超级详细的教程</title>
      <link href="/2022/06/09/Selenium%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%99%E7%A8%8B/"/>
      <url>/2022/06/09/Selenium%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信搞过Python的人绝大部分都会一点点爬虫技能，但是很多时候爬虫也不是万能的，这个时候就需要我们的自动化测试框架了，于是Selenium就应运而生了，它可以算的上是自动化测试框架中的佼佼者，因为它解决了大多数用来爬取页面的模块的一个永远的痛，那就是Ajax异步加载，今天小编就带大家来好好了解下这个Selenium 。</p><h2 id="一、安装与导入"><a href="#一、安装与导入" class="headerlink" title="一、安装与导入"></a>一、安装与导入</h2><p>这里我们需要安装三个东西，一个是Selenium框架，还有一个浏览器，最后就是驱动。这里小编选择了谷歌浏览器。然后Selenium框架嘛，大家都会下的啦，PIP就搞定了，最后就是要下载个Chrome浏览器的驱动程序，为了让Selenium和浏览器之间产生关联的一个东西，下载地址：<a href="https://registry.npmmirror.com/binary.html?path=chromedriver/" target="_blank" rel="noopener">https://registry.npmmirror.com/binary.html?path=chromedriver/</a>。安装好浏览器后，将浏览器驱动放在浏览器同级目录下，这样前期工作就算都预备好了。<br>注：不要随便乱下浏览器和驱动，每个浏览器和驱动器的版本都必须是一一对应的，不是通用的。</p><h2 id="二、与浏览器建立连接"><a href="#二、与浏览器建立连接" class="headerlink" title="二、与浏览器建立连接"></a>二、与浏览器建立连接</h2><p>做好前面的准备工作，我们只需要写入几行Python代码即可与浏览器进行交互，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的驱动，并启动Chrome浏览器c.get(&#39;https://www.baidu.com&#39;)#打开百度</code></pre><h2 id="三、查找元素"><a href="#三、查找元素" class="headerlink" title="三、查找元素"></a>三、查找元素</h2><p>对于操作浏览器中的页面的自动化测试框架来说，肯定少不了 去发现网页中的元素，你只有发现那些元素实时存在了才能做出下一步的操作。Selenium中提供了众多的方法供我们去找到网页中的元素，这给我们带来了很大的便利，那么都有哪些方法了，我们可以通过Python快速获取到这些方法：</p><pre><code class="python">find_element                         #通过指定方法查找指定的一个元素(需指定两个参数)find_element_by_class_name           #通过Class name查找指定的一个元素find_element_by_css_selector         #通过CSS选择器查找指定的一个元素find_element_by_id                   #通过ID查找指定的一个元素find_element_by_link_text            #通过链接文本获取指定的一个超链接(精确匹配)find_element_by_name                 #通过Name查找指定的一个元素find_element_by_partial_link_text    #通过链接文本获取指定的一个超链接(模糊匹配)find_element_by_tag_name             #通过标签名查找指定的一个元素find_element_by_xpath                #通过Xpath语法来指定的一个元素find_elements                        #通过指定方法查找所有元素(需指定两个参数)find_elements_by_class_name          #通过Class name查找所有元素find_elements_by_css_selector        #通过CSS选择器查找所有元素find_elements_by_id                  #通过ID查找所有元素find_elements_by_link_text           #通过链接文本获取所有超链接(精确匹配)find_elements_by_name                #通过Name查找所有元素find_elements_by_partial_link_text   #通过链接文本获取所有超链接(模糊匹配)find_elements_by_tag_name            #通过标签名查找所有元素find_elements_by_xpath               #通过Xpath语法来查找所有元素</code></pre><p>可以看到输入框的ID为KW，Name为WD，这里我们选择ID，选择ID有三种方法，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byc=webdriver.Chrome(executable_path=r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)c.get(&#39;https://www.baidu.com&#39;)kw1=c.find_element(By.ID,&#39;kw&#39;)kw2=c.find_element_by_id(&#39;kw&#39;)kw3=c.find_elements_by_id(&#39;kw&#39;)[0]print(kw1)print(kw2)print(kw3)</code></pre><p>可以看到我们成功使用三种方法获取到了这个元素，其它方法差不多，都是一通百通，喜欢哪种方法就使用哪种方法。</p><h2 id="四、浏览器操作"><a href="#四、浏览器操作" class="headerlink" title="四、浏览器操作"></a>四、浏览器操作</h2><h3 id="1-获取本页面URL"><a href="#1-获取本页面URL" class="headerlink" title="1.获取本页面URL"></a>1.获取本页面URL</h3><pre><code class="python">c.current_url</code></pre><h3 id="2-获取日志"><a href="#2-获取日志" class="headerlink" title="2.获取日志"></a>2.获取日志</h3><pre><code class="python">c.log_types  #获取当前日志类型c.get_log(&#39;browser&#39;)#浏览器操作日志c.get_log(&#39;driver&#39;) #设备日志c.get_log(&#39;client&#39;) #客户端日志c.get_log(&#39;server&#39;) #服务端日志</code></pre><h3 id="3-窗口操作"><a href="#3-窗口操作" class="headerlink" title="3.窗口操作"></a>3.窗口操作</h3><pre><code class="python">c.maximize_window()#最大化c.fullscreen_window() #全屏c.minimize_window() #最小化c.get_window_position() #获取窗口的坐标c.get_window_rect()#获取窗口的大小和坐标c.get_window_size()#获取窗口的大小c.set_window_position(100,200)#设置窗口的坐标c.set_window_rect(100,200,32,50)    #设置窗口的大小和坐标c.set_window_size(400,600)#设置窗口的大小c.current_window_handle   #返回当前窗口的句柄c.window_handles         #返回当前会话中的所有窗口的句柄</code></pre><h3 id="4-设置延时"><a href="#4-设置延时" class="headerlink" title="4.设置延时"></a>4.设置延时</h3><pre><code class="python">c.set_script_timeout(5) #设置脚本延时五秒后执行c.set_page_load_timeout(5)#设置页面读取时间延时五秒</code></pre><h3 id="5-关闭"><a href="#5-关闭" class="headerlink" title="5.关闭"></a>5.关闭</h3><pre><code class="python">c.close() #关闭当前标签页c.quit() #关闭浏览器并关闭驱动</code></pre><h3 id="6-打印网页源代码"><a href="#6-打印网页源代码" class="headerlink" title="6.打印网页源代码"></a>6.打印网页源代码</h3><pre><code class="python">c.page_source</code></pre><h3 id="7-屏幕截图操作"><a href="#7-屏幕截图操作" class="headerlink" title="7.屏幕截图操作"></a>7.屏幕截图操作</h3><pre><code class="python">c.save_screenshot(&#39;1.png&#39;)#截图，只支持PNG格式c.get_screenshot_as_png() #获取当前窗口的截图作为二进制数据c.get_screenshot_as_base64() #获取当前窗口的截图作为base64编码的字符串</code></pre><h3 id="8-前进后退刷新"><a href="#8-前进后退刷新" class="headerlink" title="8.前进后退刷新"></a>8.前进后退刷新</h3><pre><code class="python">c.forward() #前进c.back()  #后退c.refresh()#刷新</code></pre><h3 id="9-执行JS代码"><a href="#9-执行JS代码" class="headerlink" title="9.执行JS代码"></a>9.执行JS代码</h3><p>在Selenium中也可以自定义JS代码并带到当前页面中去执行，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.get(&#39;https://www.baidu.com&#39;)kw1=c.find_element(By.ID,&#39;kw&#39;)c.execute_script(&quot;alert(&#39;hello&#39;)&quot;)time.sleep(3)c.quit()</code></pre><p>这里我使用一个JS中的函数来执行屏幕提示的功能，成功被执行。</p><h3 id="10-Cookies操作"><a href="#10-Cookies操作" class="headerlink" title="10.Cookies操作"></a>10.Cookies操作</h3><pre><code class="python">c.get_cookie(&#39;BAIDUID&#39;) #获取指定键的Cookiesc.get_cookies()         #获取所有的Cookiesfor y in c.get_cookies():   x=y   if x.get(&#39;expiry&#39;):       x.pop(&#39;expiry&#39;)        c.add_cookie(x) #添加Cookies  c.delete_cookie(&#39;BAIDUID&#39;) #删除指定键的Cookies内容c.delete_all_cookies() #删除所有cookies</code></pre><h3 id="11-获取标题内容"><a href="#11-获取标题内容" class="headerlink" title="11.获取标题内容"></a>11.获取标题内容</h3><pre><code class="python">c.title</code></pre><h3 id="12-获取当前浏览器名"><a href="#12-获取当前浏览器名" class="headerlink" title="12.获取当前浏览器名"></a>12.获取当前浏览器名</h3><pre><code class="python">c.name</code></pre><h3 id="13-全局超时时间"><a href="#13-全局超时时间" class="headerlink" title="13.全局超时时间"></a>13.全局超时时间</h3><pre><code class="python">c.implicitly_wait(5)</code></pre><h2 id="五、元素操作"><a href="#五、元素操作" class="headerlink" title="五、元素操作"></a>五、元素操作</h2><p>对我们找到的元素进行二次操作，不仅可以再次选择子元素还可以进行其它操作。如下：</p><pre><code class="python">kw1.clear()        #清除元素的值kw1.click()        #点击元素kw1.id             #Selenium所使用的内部IDkw1.get_property(&#39;background&#39;) #获取元素的属性的值kw1.get_attribute(&#39;id&#39;) #获取元素的属性的值kw1.location       #不滚动获取元素的坐标kw1.location_once_scrolled_into_view  #不滚动且底部对齐并获取元素的坐标kw1.parent         #父元素kw1.send_keys(&#39;&#39;)  #向元素内输入值kw1.size           #大小kw1.submit         #提交kw1.screenshot(&#39;2.png&#39;) #截取元素形状并保存为图片kw1.tag_name       #标签名kw1.text           #内容，如果是表单元素则无法获取kw1.is_selected()  #判断元素是否被选中kw1.is_enabled()   #判断元素是否可编辑kw1.is_displayed   #判断元素是否显示kw1.value_of_css_property(&#39;color&#39;) #获取元素属性的值kw1._upload(&#39;2.png&#39;) #上传文件</code></pre><h2 id="六、键盘鼠标操作"><a href="#六、键盘鼠标操作" class="headerlink" title="六、键盘鼠标操作"></a>六、键盘鼠标操作</h2><h3 id="1-模拟键盘输入和按键"><a href="#1-模拟键盘输入和按键" class="headerlink" title="1.模拟键盘输入和按键"></a>1.模拟键盘输入和按键</h3><pre><code class="python">from selenium.webdriver.common.keys import Keysc.find_element(By.ID,&#39;kw&#39;).send_keys(&#39;python&#39;)#输出Pythonc.find_element(By.ID,&#39;kw&#39;).send_keys(Keys.ENTER)#回车键c.find_element(By.ID,&#39;kw&#39;).click()#点击</code></pre><p>这里列举出了一个最简单的键盘输入和鼠标点击的例子，不过我们在Selenium中可以使用更为高逼格的操作，那么是什么了？当然是咱们的鼠标键盘监听事件来触发事件啦，而且它里面的方法的确也很多样化，满足小编日常的骚操作不在话下，如下所示：</p><pre><code class="python">click(on_element=None)                 #鼠标左键单击click_and_hold(on_element=None)        #单击鼠标左键，不松开context_click(on_element=None)         #单击鼠标右键double_click(on_element=None)          #双击鼠标左键drag_and_drop(source,target)           #拖拽到某个元素然后松开drag_and_drop_by_offset(source,xoffset,yoffset) #拖拽到某个坐标然后松开key_down(value,element=None)     #按下键盘上的某个键key_up(value, element=None)      #松开键盘上的某个键move_by_offset(xoffset, yoffset)  #鼠标从当前位置移动到某个坐标move_to_element(to_element)        #鼠标移动到某个元素move_to_element_with_offset(to_element, xoffset, yoffset) #移动到距某个元素（左上角坐标）多少距离的位置pause(seconds)                  #暂停所有输入(指定持续时间以秒为单位)perform()                       #执行所有操作reset_actions()                 #结束已经存在的操作并重置release(on_element=None)       #在某个元素位置松开鼠标左键send_keys(*keys_to_send)        #发送某个键或者输入文本到当前焦点的元素send_keys_to_element(element, *keys_to_send) #发送某个键到指定元素</code></pre><p>以上就是咱们鼠标和键盘的全部操作了，小编将用一个例子带大家零基础入门。如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.common.action_chains import ActionChainsc=webdriver.Chrome(executable_path=r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)c.get(&#39;https://www.baidu.com&#39;)a=ActionChains(c)kw1=c.find_element(By.ID,&#39;kw&#39;)tj=c.find_element(By.ID,&#39;su&#39;)tj.send_keys(Keys.CONTROL,&#39;c&#39;) #复制a.drag_and_drop(kw1,tj).perform()#从输入框拖动到搜索按钮kw1.send_keys(Keys.CONTROL,&#39;v&#39;)#粘贴tj.send_keys(Keys.ENTER)time.sleep(3)c.close()c.quit()</code></pre><p>这里我们通过对事件的监控，进行复制和粘贴，这里涉及到一个组合键的知识，大家注意。</p><h2 id="七、选项操作"><a href="#七、选项操作" class="headerlink" title="七、选项操作"></a>七、选项操作</h2><p>我们可以通过给当前操作的对象一些选项来增强交互能力，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.chrome.options import Optionso=Options()o.add_argument(&#39;--headless&#39;)#无界面浏览from selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;),options=o) #获取chrome浏览器的c.get(&#39;https://www.baidu.com&#39;)kw1=c.find_element(By.ID,&#39;kw&#39;)print(c.title)time.sleep(3)c.close()c.quit()</code></pre><p>这个时候就实现了咱们的无界面浏览了，也就是不用打开浏览器即可自动返回执行的结果。不过你可别以为选项就那么一两个，那可是多到你怀疑人生的，例如：</p><pre><code class="python">o.add_argument(&#39;--window-size=600,600&#39;) #设置窗口大小o.add_argument(&#39;--incognito&#39;) #无痕模式o.add_argument(&#39;--disable-infobars&#39;) #去掉chrome正受到自动测试软件的控制的提示o.add_argument(&#39;user-agent=&quot;XXXX&quot;&#39;) #添加请求头o.add_argument(&quot;--proxy-server=http://200.130.123.43:3456&quot;)#代理服务器访问o.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])#开发者模式o.add_experimental_option(&quot;prefs&quot;,{&quot;profile.managed_default_content_settings.images&quot;: 2})#禁止加载图片o.add_experimental_option(&#39;prefs&#39;,{&#39;profile.default_content_setting_values&#39;:{&#39;notifications&#39;:2}}) #禁用浏览器弹窗o.add_argument(&#39;blink-settings=imagesEnabled=false&#39;)  #禁止加载图片o.add_argument(&#39;lang=zh_CN.UTF-8&#39;) #设置默认编码为utf-8o.add_extension(create_proxyauth_extension(           proxy_host=&#39;host&#39;,           proxy_port=&#39;port&#39;,           proxy_username=&quot;username&quot;,           proxy_password=&quot;password&quot;       ))# 设置有账号密码的代理o.add_argument(&#39;--disable-gpu&#39;)  # 这个属性可以规避谷歌的部分bugo.add_argument(&#39;--disable-javascript&#39;)  # 禁用javascripto.add_argument(&#39;--hide-scrollbars&#39;)  # 隐藏滚动条o.binary_location=r&quot;C:\Users\Administrator\AppData\Local\Google\Chrome\Application&quot; #指定浏览器位置o.add_argument(&#39;--no-sandbox&#39;)  #解决DevToolsActivePort文件不存在的报错</code></pre><p>其实选项的添加无非就是分为以下这几种，如下：</p><pre><code class="python">o.set_headless()          #设置启动无界面化o.binary_location(value)  #设置chrome二进制文件位置o.add_argument(arg)               #添加启动参数o.add_extension(path)                #添加指定路径下的扩展应用o.add_encoded_extension(base64)      #添加经过Base64编码的扩展应用o.add_experimental_option(name,value)         #添加实验性质的选项o.debugger_address(value)                #设置调试器地址 o.to_capabilities()                    #获取当前浏览器的所有信息</code></pre><p>虽然选项很多，但是我们真正能用到的不多，一般就是无痕模式或者禁用JavaScript和图片来快速获取到相关信息。虽然我们上面使用的是Options方法，但是在实际应用中建议大家使用的ChromeOptions方法。</p><h2 id="八、框架操作-Frame-IFrame"><a href="#八、框架操作-Frame-IFrame" class="headerlink" title="八、框架操作(Frame/IFrame)"></a>八、框架操作(Frame/IFrame)</h2><p>我们还可以操作框架里的东西，比如IFrame，Frame等等，虽然都是框架，但是这两者操作起来还是有很大差别的。下面我们就来看看吧，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;https://hao.360.com/?a1004&#39;)#ss=c.find_element(By.CLASS_NAME,&#39;NEWS_FEED_VIDEO_1595850774217HPA70&#39;)#不容易找到标签c.switch_to.frame(0)#索引c.switch_to.frame(&#39;NEWS_FEED_VIDEO_1595850774217HPA70-VideoIframe&#39;) #IDc.switch_to.frame(&#39;NEWS_FEED_VIDEO_1595850774217HPA70&#39;)#Classc.switch_to.frame(c.find_element_by_tag_name(&quot;iframe&quot;))#标签time.sleep(3)c.close()c.quit()</code></pre><p>这里小编是以360浏览器的主页为例子，对它里面的IFrame进行访问，最有效的方法一般就是我上面提到的四种了。这里我们有时候因为这个框架需要加载才可以出来，所以很多时候是无法获取到的，因此我们只有使用滑动加载到出现这个标签或者ID，Class为可以获取到，这在刚才小编是说了的，大家可以往前看看，不过这个方法不推荐使用，为啥？因为开发者文档上是这样写的。我们的Frame由于是IFrame里的子集，所以上面的方法便是可以层层遍历的好方法，但是如果我们遍历到最后了如何返回主框架了，可以这样做，如下所示：</p><pre><code class="python">c.switch_to.default_content()</code></pre><p>这样就可以回到主框架继续进行操作了。如果我们由里往外遍历的话，那么可以这样来做，如下：</p><pre><code class="python">c.switch_to.parent_frame()</code></pre><h2 id="九、Alert"><a href="#九、Alert" class="headerlink" title="九、Alert"></a>九、Alert</h2><p>在弹窗处理中，我们会遇到三种情况，如下：<br>浏览器弹出框</p><ul><li>新窗口弹出框</li><li>人为弹出框<br>那么我们该怎么分辨了？下面跟我一起看看吧。</li></ul><h3 id="1-浏览器弹出框"><a href="#1-浏览器弹出框" class="headerlink" title="1.浏览器弹出框"></a>1.浏览器弹出框</h3><p>首先说说浏览器弹出框，想必大家对JavaScript中的Alert，Confirm，Prompt应该不是很陌生，就是弹出框，确认框，输入框；基本方法我们来看下，如下：</p><pre><code class="python">from selenium.webdriver.common.alert import Alertfrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;https://www.baidu.com&#39;)a1=Alert(c)a1.accept() #确定a1.dismiss() #取消a1.authenticate(username,password) #用户身份验证a1.send_keys(&#39;&#39;) #输入文本或按键a1.text  #获取弹窗内容</code></pre><p>这里我们应对每种情况它上面的方法的对应位置都是会有所变化的，所以我们需要根据具体情况来进行操作，而且还可以使用另一种方法，如下：</p><pre><code class="python">from selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;https://www.baidu.com&#39;)a1=c.switch_to_alert()a1.accept() #确定a1.dismiss() #取消a1.authenticate(username,password) #用户身份验证a1.send_keys(&#39;&#39;) #输入文本或按键a1.text  #获取弹窗内容</code></pre><p>注：该类方法必须在有弹框的情况下才有作用，如没有会报错。</p><h3 id="2-新窗口弹出框"><a href="#2-新窗口弹出框" class="headerlink" title="2.新窗口弹出框"></a>2.新窗口弹出框</h3><p>上面就是浏览器弹出框的处理方法了，如果是新窗口弹出的话那么就不一样了，我们需要通过句柄来定位，前面我们提到过这两个方法。下面我们来看看它们的具体用法，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;https://www.baidu.com&#39;)kw1=c.find_element(By.ID,&#39;kw&#39;)tj=c.find_element(By.ID,&#39;su&#39;)hwnd=c.window_handles #所有窗口句柄for h in hwnd:   if h !=c.current_window_handle:  #如果句柄不是当前窗口句柄则切换                          c.switch_to_window(h)  #切换窗口   else:       print(&#39;无需切换窗口&#39;) time.sleep(3)c.close()c.quit()</code></pre><p>注：如果有多个窗口，当你关闭了当前窗口想切换到另一个窗口，你需要把没关闭的窗口切换成当前活动窗口，因为Selenium是不会为你做这件事的。</p><h3 id="3-人为弹出框"><a href="#3-人为弹出框" class="headerlink" title="3.人为弹出框"></a>3.人为弹出框</h3><p>这类弹出框是我们自己开发的，一般都是使用Div包裹一些其它的元素标签然后形成一个整体，当我们触发某个事件的时候就会出现，否则消失。这种弹出框使用我们的众多Find前缀的方法就能遍历到，很方便，这里不一一细说。</p><h2 id="十、判断"><a href="#十、判断" class="headerlink" title="十、判断"></a>十、判断</h2><p>在Selenium中我们在做自动化测试时常无法判断一个元素是否真的显示出来了，因此会各种报错，接下来我们对这些操作进行判断，如果显示出了我们预期的值，那么就进行下一步操作，否则就关闭或者暂停几秒然后再判断，这里我要跟大家说Selenium中的一个模块—–Expected_Conditions，简称为EC，如下所示：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;https://baidu.com&#39;)t=EC.title_is(&#39;百度一下，你就知道&#39;)print(t(c))time.sleep(3)c.close()c.quit()</code></pre><p>这里其实就是判断当前页面的标题是否是我们给定的文本，可以看出这里为True，说明是。它不光就一个方法哦，还有其它的，小编在这里大致说下，如下所示：</p><pre><code class="python">EC.title_contains(&#39;&#39;)(c)#判断页面标题是否包含给定的字符串EC.presence_of_element_located(&#39;&#39;)(c) #判断某个元素是否加载到dom树里，该元素不一定可见EC.url_contains(&#39;&#39;)(c) #判断当前url是否包含给定的字符串EC.url_matches(&#39;&#39;)(c) #匹配URLEC.url_to_be(&#39;&#39;)(c)  #精确匹配EC.url_changes(&#39;&#39;)(c) #不完全匹配EC.visibility_of_element_located(&#39;&#39;)(c) #判断某个元素是否可见,可见代表元素非隐藏元素EC.visibility_of(&#39;&#39;)(c)   #跟上面一样，不过是直接传定位到的elementEC.presence_of_all_elements_located(&#39;&#39;)(c) #判断是否至少有1个元素存在于dom树中EC.visibility_of_any_elements_located(&#39;&#39;)(c) #判断是否至少一个元素可见，返回列表EC.visibility_of_all_elements_located(&#39;&#39;)(c) #判断是否所有元素可见，返回列表EC.text_to_be_present_in_element(&#39;&#39;)(c) #判断元素中的text是否包含了预期的字符串EC.text_to_be_present_in_element_value(&#39;&#39;)(c)#判断元素中value属性是否包含预期的字符串EC.frame_to_be_available_and_switch_to_it(&#39;&#39;)(c) # 判断该frame是否可以switch进去EC.invisibility_of_element_located(&#39;&#39;)(c) #判断某个元素是否不存在于dom树或不可见EC.element_to_be_clickable(&#39;&#39;)(c) #判断某个元素中是否可见并且可点击EC.staleness_of(&#39;&#39;)(c)  #等某个元素从dom树中移除EC.element_to_be_selected(&#39;&#39;)(c)  #判断某个元素是否被选中了,一般用在下拉列表EC.element_located_to_be_selected(&#39;&#39;)(c) #判断元组中的元素是否被选中EC.element_selection_state_to_be(&#39;&#39;)(c) #判断某个元素的选中状态是否符合预期EC.element_located_selection_state_to_be(&#39;&#39;)(c) #跟上面一样，只不过是传入locatedEC.number_of_windows_to_be(&#39;&#39;)(c)  #判断窗口中的数字是否符合预期EC.new_window_is_opened(&#39;&#39;)(c)  #判断新的窗口是否打开EC.alert_is_present(&#39;&#39;)(c)  #判断页面上是否存在alert</code></pre><p>这就是它全部的方法了，简直不要多简单。</p><h2 id="十一、选择"><a href="#十一、选择" class="headerlink" title="十一、选择"></a>十一、选择</h2><p>刚刚讲过判断，现在我们来说说选择，选择无非就是挑好的扔烂的，顺着思路来不会错，总体来讲还是挺简单的，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.select import Selectimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;http://www.juliwz.cn/forum.php&#39;)s=Select(c.find_element_by_id(&#39;ls_fastloginfield&#39;))#实例化res=s.all_selected_options#全部选中子项res1=s.options#全部子项print(res)print(res1)time.sleep(3)c.close()c.quit()</code></pre><p>发觉主流网站都没有Select这个标签，于是找了个很冷门的网站，就一个Select。Select里面的方法也是相当多的，如下：</p><pre><code class="python">s.first_selected_option  #第一个选中的子项s.select_by_index(index) #根据索引选择s.select_by_value(value)   #根据值来选择s.select_by_visible_text(text)  #根据选项可见文本s.deselect_by_index(index)   #根据索引来取消选择s.deselect_by_value(value)   #根据值来取消选择s.deselect_by_visible_text(text)  #根据可见文本来取消选择s.deselect_all()                #取消所有选择</code></pre><h2 id="十二、显示等待和隐式等待"><a href="#十二、显示等待和隐式等待" class="headerlink" title="十二、显示等待和隐式等待"></a>十二、显示等待和隐式等待</h2><p>想必大家应该听过这个概念，显示等待就是浏览器在我们设置的时间内不断寻找，等到元素后才继续执行，如果没在规定时间内找到，也会抛异常；而隐式等待则是我们设置时间，然后程序去找元素，期间会不断刷新页面，到了时间仍然没找到就抛异常。这里有个常用的模块专门用来实现显示等待和隐式等待的，它就是”wait“,我们来看看吧。如下：</p><pre><code class="python">from selenium.webdriver.support.ui import WebDriverWaitfrom selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.get(&#39;https://www.baidu.com/&#39;)su=WebDriverWait(c,10).until(lambda x:x.find_element_by_id(&#39;su&#39;)) su.location_once_scrolled_into_viewprint(su.get_attribute(&#39;value&#39;))time.sleep(3)c.close()c.quit()</code></pre><p>隐式等待很简单，就一行代码，如下：</p><pre><code class="python">c.implicitly_wait(10)</code></pre><p>它的等待时间适用于全局的环境，也就是任何地方找不到某个元素，它都将发挥作用，如果找得到，则不会产生作用。</p><h2 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h2><p>Selenium的内容其实还是挺丰富的，它还有手机端的自动化测试框架，不过小编先把WEB端讲完就可以了，毕竟也写了这么多了，日后有时间再慢慢了解。大家如果是对触摸活动事件感兴趣的也可以看看“touch_actions”这个模块。这个模块里集成的都是关于触摸屏的操作，里面也有很多的方法，小编之所以能把Selenium一天学完，还是Selenium模块中的文档比较给力，主要是介绍的比较好，让人能轻松联想到方法的使用，感激开源作者的无私奉献。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/343948620" target="_blank" rel="noopener">Selenium超级详细的教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议的基础</title>
      <link href="/2022/06/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/06/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>小编是一个非典型面试官，对于HTTP协议的第一个问题，一般人会问常用的状态码有哪些。小编不这么问，小编的问题是HTTP的全称是什么，把英语给我说出来！</p><h3 id="HTTP的全称是什么？"><a href="#HTTP的全称是什么？" class="headerlink" title="HTTP的全称是什么？"></a>HTTP的全称是什么？</h3><p>超文本传输协议，HyperText Transfer Protocol，这几个单词可别发走音了。所谓的超文本就是带标记的文本，刚开始的时候是指HTML。现在HTTP协议传输的东西可不只是HTML了，什么表单啊JSON啊XML啊文件啊都可以传输。</p><h3 id="HTTP常用的状态码有哪些？"><a href="#HTTP常用的状态码有哪些？" class="headerlink" title="HTTP常用的状态码有哪些？"></a>HTTP常用的状态码有哪些？</h3><p>大部分同学都知道200、404、500、302状态码。如果连404都不知道，是要被小编鄙视的。500错误为什么这么常见呢，因为在开发的时候老是出bug，一个大异常抛出来，浏览器就500了。500表示InternalServerError，也就是内部服务器错误，如果不是bug，一般就是数据库挂了。</p><p>再多问几个状态码很多人就不知道了，因为大多数公司的软件服务没有走标准的HTTP状态码，很多状态码从来就不会出现，同学们自然也不会知道。</p><p>400 Bad Request 用于参数验证，少了一个参数或者参数类型错误之类的。</p><p>502 Bad Gateway 后端服务挂掉或者压力过大的时候， Nginx接到的请求无法及时传递给后端的服务进行处理，这个时候就会出现502错误。这个也非常常见，知乎豆瓣网站经常开小差的时候发生的错误就是这个。</p><p>304 Not Modified 极少人知道这个状态码，因为大部分后端开发者的前端Javascript开发经验都严重不足。当你用Chrome打开一个经常访问的网站，看看Network传输的静态资源就可以看到很多304状态码。它表示该资源被浏览器缓存了不需要重新请求服务器。</p><p>401 Unauthorized 权限不足，这个很好理解，就是资源存在但是不让你访问。</p><p>403 Forbidden 资源禁止访问，如果你的IP列为黑名单了，就会发生这种错误。</p><p>其实还有很多状态码，小编也没去好好研究了，因为实在不会在工作中用到。感兴趣的请继续阅读维基百科</p><h3 id="HTTP有哪些Method？"><a href="#HTTP有哪些Method？" class="headerlink" title="HTTP有哪些Method？"></a>HTTP有哪些Method？</h3><p>GET 不解释，如果读者不知道，建议别在IT圈混了。</p><p>POST 一般用于创建或者修改资源，在RESTFUL规范里面POST只用来创建资源，并返回201 Created状态码表示创建成功。不过大多数网站都不遵循严格的RESTFUL规范，POST拿来做修改资源的事也是非常常见的。</p><p>PUT 对应于POST表示创建资源，PUT用于修改资源，PUT的参数必须是对象的全部属性，修改是覆盖式全部修改。</p><p>PATCH 对应于PUT的参数是对象的全部属性，PATCH的参数是部分属性，修改是局部字段修改。</p><p>DELETE 用于删除资源。</p><p>HEAD 不常用，跟GET差不多，区别就是不返回Body内容，只返回HTTP头信息。一般用于获取资源的元信息，比如长度，修改时间等</p><p>OPTIONS 跨域相关，后面再讲。</p><p>TRACE 小编没用过。</p><p>CONNECT 小编没用过。</p><p>后面三个感兴趣的去阅读一下RPC规范。小编大概看了一下，表示没怎么看懂，你行你上去挑战一下。</p><h3 id="HTTP协议格式是怎样的？"><a href="#HTTP协议格式是怎样的？" class="headerlink" title="HTTP协议格式是怎样的？"></a>HTTP协议格式是怎样的？</h3><p>HTTP的请求和响应的消息协议是一样的，分为三个部分，起始行、消息头和消息体。这三个部分以CRLF作为分隔符。最后一个消息头有两个CRLF，用来表示消息头部的结束。</p><p><img src="/images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/1654942891.695849.webp"></p><p>HTTP请求的起始行称为请求行，形如GET /index.html HTTP/1.1</p><p>HTTP响应的起始行称为状态行，形如200 ok</p><p>消息头部有很多键值对组成，多个键值对之间使用CRLF作为分隔符，也可以完全没有键值对。形如Content-Encoding: gzip</p><p>消息体是一个字符串，字符串的长度是由消息头部的Content-Length键指定的。如果没有Content-Length字段说明没有消息体，譬如GET请求就是没有消息体的，POST请求的消息体一般用来放置表单数据。GET请求的响应返回的页面内容也是放在消息体里面的。我们平时调用API返回的JSON内容都是放在消息体里面的。</p><h3 id="什么是分块传送？"><a href="#什么是分块传送？" class="headerlink" title="什么是分块传送？"></a>什么是分块传送？</h3><p>当浏览器向服务器请求一个资源时，这个资源是一个动态资源，服务器无法提前预知资源的大小，这个时候就可以使用分块传输。</p><p>服务器先生成一个thunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到全部资源传送完成。</p><p>分块传送需要在请求头增加一个特殊的键值对transfer-encoding: thunked，那么消息体的内容便是分块传送的。</p><p><img src="/images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/1654942891.876003.webp"><br>chunked传输格式如图所示，由一段一段的分块组合而成，每个块由一个长度行和一个分块体组成，最后一个分块长度为0表示结束。</p><h3 id="持久连接的机制是怎样的？"><a href="#持久连接的机制是怎样的？" class="headerlink" title="持久连接的机制是怎样的？"></a>持久连接的机制是怎样的？</h3><p>HTTP早期版本中每个请求都会发起一个连接，一个网页除了页面的HTML之外还会有很多静态资源以及诸多的API调用，如果每个请求都一个连接，势必网页的一次加载就会和服务器创建多次连接，这是非常浪费服务器资源的，同时也让客户端的访问速度慢了不少。HTTP1.0之后引入了Keep-Alive持久连接，在HTTP1.1版本中成为默认选项。它使得HTTP的一个连接可以连续服务多个请求，有效节省了资源，增加了客户端页面的加载速度。</p><p>持久连接也不宜一直保持，毕竟每个连接都会占用服务器资源，如果打开网页的人太多，那服务器资源也会紧张，所以一般服务器都会配置一个KeepAlive Timeout参数和KeepAlive Requests参数限制单个连接持续时长和最多服务的请求次数。</p><p>如果服务器设置的timeout时长为0，就退化到非持久连接。非持久连接会在响应头部增加一个头信息Connection: Close通知客户端在接受完当前响应后连接需要立即关闭。</p><p>同样浏览器也不会因为服务器将KeepAlive Timeout配置了无限长就不管不问一直持续保持连接。每个浏览器都有它自己的内置限制，具体限制浏览器厂商各有不同。</p><h3 id="什么叫Pipeline管线化？"><a href="#什么叫Pipeline管线化？" class="headerlink" title="什么叫Pipeline管线化？"></a>什么叫Pipeline管线化？</h3><p>HTTP1.0不支持管线化，同一个连接处理请求的顺序是逐个应答模式，处理一个请求就需要耗费一个TTL，也就是客户端到服务器的往返时间，处理N个请求就是N个TTL时长。当页面的请求非常多时，页面加载速度就会非常缓慢。</p><p><img src="/images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/1654942892.10225.webp"></p><p>从HTTP1.1开始要求服务器支持管线化，可以同时将多个请求发送到服务器，然后逐个读取响应。这个管线化和Redis的管线化原理是一样的，响应的顺序必须和请求的顺序保持一致。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/HTTP协议的基础/1654942892.30924.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="如何理解HTTP协议的无状态性？"><a href="#如何理解HTTP协议的无状态性？" class="headerlink" title="如何理解HTTP协议的无状态性？"></a>如何理解HTTP协议的无状态性？</h3><p>所谓HTTP协议的无状态性是指服务器的协议层无需为不同的请求之间建立任何相关关系，它特指的是协议层的无状态性。但是这并不代表建立在HTTP协议之上的应用程序就无法维持状态。应用层可以通过会话Session来跟踪用户请求之间的相关性，服务器会为每个会话对象绑定一个唯一的会话ID，浏览器可以将会话ID记录在本地缓存LocalStorage或者Cookie，在后续的请求都带上这个会话ID，服务器就可以为每个请求找到相应的会话状态。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/6844903581431103502" target="_blank" rel="noopener">天下无难试之HTTP协议面试刁难大全（上）</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鲜为人知的HTTP协议头字段详解大全「原创」</title>
      <link href="/2022/06/09/%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE%E5%A4%B4%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3%E5%A4%A7%E5%85%A8%E3%80%8C%E5%8E%9F%E5%88%9B%E3%80%8D/"/>
      <url>/2022/06/09/%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE%E5%A4%B4%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3%E5%A4%A7%E5%85%A8%E3%80%8C%E5%8E%9F%E5%88%9B%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>继上篇讲了<a href="/2022/06/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/">HTTP协议的基础</a>之后，本篇重点介绍一下HTTP常用的Header。</p><p>HTTP Header非常之多，很少有人能完全分清这些Header到底是干什么的。鉴于RFC文件规范艰深晦涩难懂，本文对协议规范中列出的HTTP Header进行了梳理，用通俗的语言进行表达，便于读者吃透HTTP协议。</p><p>作者在阅读RFC文档的时候发现了很多以前没注意到的知识，估计做web开发的小伙伴们也大多忽视了这些知识，阅读文本会给你们带来很多意外的惊喜。</p><p>免责声明：如果下面有那句话有不对的地方，还请喷少点口水。</p><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p>表示客户端期望服务器返回的媒体格式。客户端期望的资源类型服务器可能没有，所以客户端会期望多种类型，并且设置优先级，服务器根据优先级寻找相应的资源返回给客户端。</p><pre><code class="bash">### 注意：先逗号分割类型，再分号分割属性Accept: audio/*; q=0.2, audio/basic</code></pre><p>表示audio/basic类型的资源优先，如果没有，就随便其它什么格式的audio资源都可以。q的取值范围是(0-1]，其具体值并没有意义，它仅用来排序优先级，如果没有q，默认q=1，也就是最高优先级。</p><h3 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h3><p>表示客户端期望服务器返回的内容的编码格式。它同Accept头一样，也可以指定多个编码，以q值代表优先级。</p><pre><code class="bash">### 注意：先逗号分割类型，再分号分割属性Accept-Charset: utf8, gbk; q=0.6</code></pre><p>表示utf8编码优先，如果不行，就拿gbk编码返回.</p><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p>Content-Type是服务器向客户端发送的头，代表内容的媒体类型和编码格式，是对Accept头和Accept-Charset头的统一应答。</p><pre><code class="bash">Content-Type: text/html; charset=utf8</code></pre><p>表示返回的Body是个html文本，编码为utf8</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/162586bc251399fb~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h3><p>表示客户端期望服务器返回的内容的语言。很多大型互联网公司是全球化的，它的技术文档一般有有多种语言，通过这个字段可以实现文档的本地化，对国内用户呈现简体中文文档，对英语系用户呈现英文文档。</p><pre><code class="bash">Accept-Language:zh-CN,en-US;q=0.8,zh-TW;q=0.6</code></pre><p>表示大陆简体中文优先，其次英语，再其次台湾繁体中文</p><h3 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h3><p>这个头字段内容是对Accept-Language的应答。服务器通过此字段告知客户端返回的Body信息的语言是什么。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/162586d170635751~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><p>表示传输的请求／响应的Body的长度。GET请求因为没有Body，所以不需要这个头。携带Body的并且可以提前知道Body长度的请求／响应必须带上这个字段，以便对方可以方便的分辨出报文的边界，也就是Body数据何时结束。如果Body太大，需要边计算边传输，不到最后计算结束是无法知道整个Body大小的，这个时候可以使用http分块传输，这个时候也是不需要Content-Length字段的。</p><h3 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h3><p>当客户端请求的资源在服务器有多个地址时，服务器可以通过Content-Location字段告知客户端其它的可选地址。这个字段比较少见。</p><h3 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h3><p>在Header中提供这个信息是用来做Body内容校验。它表示Body信息被md5算法处理后的base64字符串。这个字段也比较少见。因为校验机制在TCP层已经有实现了，再来一层校验并没有多大意义。另外资源的md5值往往用来放在后面的ETag头信息中作为资源的唯一标识来使用。</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>如果服务器没有缓存，那么Date就是响应的即时生成时间。如果服务器设有缓存，那么Date就是响应内容被缓存的时间。它必须符合规范里定义的特定格式，这种格式叫着HTTP-Date，不支持随意定义自己的时间格式。</p><pre><code class="bash">Date: Tue, 15 Nov 1994 08:12:31 GMT</code></pre><h3 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h3><p>表示资源缓存的年龄，也就是资源自缓存以来到现在已经过去了多少时间，单位是秒。</p><pre><code class="bash">Age: 86400</code></pre><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>服务器使用Expect头来告知对方资源何时失效。如果它的值等于Date头的值，就表示资源已经实效。</p><pre><code class="bash">Expires: Thu, 01 Dec 1994 16:00:00 GMT</code></pre><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>资源标签，每个资源可以提供多个标签信息。它一般用来和下面的If-Match和If-None-Match配合使用，用来判断缓存资源的有效性。比较常见的标签是资源的版本号，比如可以拿资源数据的md5校验码作为版本号。</p><h3 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h3><p>If-Match的值一般是上面提到的ETag的值，它常用于HTTP的乐观锁。所谓HTTP乐观锁，是指客户端先GET这个资源得到ETag中的版本号，然后发起一个资源修改请求PUT|PATCH时通过If-Match头来指定资源的版本号，如果服务器资源满足If-Match中指定的版本号，请求就会被执行。如果不满足，说明资源被并发修改了，就需要返回状态码为412 Precondition failed 的错误。客户端可以选择放弃或者重试整个过程。</p><h3 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h3><p>类似于If-Match，只是条件相反。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/162586e758846bfa~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h3><p>表示资源支持访问的HTTP Method类型。它是服务器对客户端的建议，告知对方请使用Allow中提到的Method来访问资源。</p><pre><code class="bash">Allow: GET, HEAD, PUT</code></pre><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>当客户端和服务器需要协商连接的属性时，可以使用Connection头部。比较常用的一个值是close，用来通知对方在当前请求结束后关闭连接。</p><pre><code class="bash">Connection: close</code></pre><h3 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h3><p>用于请求发送之前向服务器询问许可。譬如要向服务器发送一个很大的文件而不确定是否超出限制，就可以在请求头里携带一个Expect头部</p><pre><code class="bash">Expect: 100-continue</code></pre><p>如果服务器说不行，就会返回417 Expectation Failed错误告知客户端放弃。如果可以那就返回100 continue状态码告知客户端放马过来吧，于是客户端就会继续上传Body内容。如果服务器提前收到Body内容就会放弃返回100 continue响应。</p><h3 id="From"><a href="#From" class="headerlink" title="From"></a>From</h3><p>该字段一般用来标记请求发起者的邮件地址，相当于给请求赋予一个责任人。如果服务器发现请求存在问题，就会通过此字段联系到发起人进行处理。因为邮件地址涉及到隐私信息，所以请求携带From头需要征得用户的同意。RFC协议建议所有的机器人代理发起的请求应该携带此头部，以免遇到问题时可以找到责任人。不过如果是恶意的机器人，估计这样的建议也只是耳边风而已。</p><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>RFC协议规定所有的HTTP请求必须携带Host头，即使Host没有值，也必须带上这个Host头附加一个空串，如果不满足，应用服务器应该抛出400 Bad Request。协议虽然这样规定，不过大部分网关或者服务器都比较仁慈，既然没有指定Host字段，那就给你默认加上一个。<br>网关代理可以根据不同的Host值转发到不同的upstream服务节点，它常用于虚拟主机服务业务。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/162586f22829c30a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>标记资源的最近修改时间，它和Date比较类似，区别是Last-Modified代表修改时间，而Date是创建时间。</p><h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p>浏览器向服务器请求静态资源时，如果浏览器本地已经有了缓存，就会携带If-Modified-Since头，值为资源的Last-Modified时间，询问服务器该资源自从这个Last-Modified时间之后有没有被修改。如果没有修改过，就会向浏览器返回304 Not Modified通知浏览器可以放心使用缓存内的资源。如果资源修改过，那就像正常的GET请求一样，携带资源的内容返回200 OK。</p><h3 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h3><p>类似于If-Modified-Since，意义相反。区别是当服务器资源条件不满足时，不是返回304 Not Modified，而是返回412 Precondition Failed。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/162586fbf1ce6825~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>支持断点续传的服务器必须处理Range头，它表示客户端请求资源的一部分时指定的请求字节范围。它是客户端向服务器发送的请求头。</p><pre><code class="bash">Range: bytes=500-999</code></pre><h3 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h3><p>针对上面的Range头，服务器响应客户端时也需提供相应的Content-Range头，表示传输的Body数据在整体资源块中的字节范围。比如下面的例子表示该资源总共有47022字节，当前响应的内容是21010-47021字节之间的内容。</p><pre><code class="bash">Content-Range: bytes 21010-47021/47022</code></pre><p>之所以是47021而不是47022是因为offset是以0开始的，47021就是最后一个字节。</p><h3 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h3><p>在断点续传时，为确保连续2个请求之间服务器资源本身没有发生变化，需要If-Range头带上ETag的资源版本号。服务器资源根据这个版本号来判定资源是否改变了。如果没变，就返回206 Partial Content将部分资源返回。如果资源变了，那就相当于一个普通的GET请求，返回200 OK和整个资源内容。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/16258703f0d9dbfe~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>服务器向客户端发送302跳转的时候，总会携带Location头信息，它的值为目标URL。</p><pre><code class="bash">HTTP/1.1 302 Temporary RedirectLocation: https://www-temp.example.org/</code></pre><h3 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h3><p>用来限定网关或者代理的层数，也就是最大转发次数。HTTP每经过一个网关或者代理层，Max-Forwards值就要减1。如果nginx接收到前端请求的时候Max-Forwards已经等于0，那么它就不应该再将请求转发到upstream指定的服务节点上。</p><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>这个头是比较常见的，在前端开发模式下经常会加上这个头部。</p><pre><code class="bash">Pragma: no-cache</code></pre><p>当网关收到一个带有这样请求的头部时，即使内部存在该请求资源的缓存并且有效也不可以直接发送给客户端，而必须转发给后面的upstream进行处理。<br>不过如果真的所有的网关都遵循这个协议的话，攻击是很容易构造的，所以它一般仅用于开发模式，防止静态资源修改后前端得不到即时更新。其它值的pragma值没有遇到过。</p><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><p>Referer是非常常用的头，它表示请求的发起来源URI，也就是当前页面资源的父页面。如果你从A页面跳转到B页面，那么请求B页面的请求头里面就会有Referer信息，它的值就是A页面的访问地址。通过追踪Referer，可得出资源页面之间复杂的跳转链，它非常适合用于网页的数据分析和路径优化。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/16257fe9b60eb4c0~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h3><p>服务器升级时，来自客户端的请求会直接给予503(Service Unavailable)错误，通过在返回头里面加入Retry-After字段告知客户端何时服务可以恢复正常访问。Retry-After的头可以是HTTP-Date，也可以是整数，表示多少秒后服务可以恢复正常访问。浏览器在拿到这个值之后可以考虑增加一个定时器在未来的某个时间进行重试。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>用于返回服务器相关的软件信息，来告知客户端当前的HTTP服务是由某某软件提供的，可以看成是一种软件广告。<br>RFC协议里对这个头信息做了警告：暴露出服务器信息可能会导致黑客更易于攻击你的服务，建议谨慎使用。</p><h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><p>携带当前的用户代理信息，一般包含浏览器、浏览器内核和操作系统的版本型号信息。它和Server头是对应的，一个是表达服务器信息，一个是表达客户端信息。服务器可以根据用户代理信息统计出网页服务的浏览器、操作系统的使用占比情况，服务器也可以根据UA的信息来定制不一样的内容。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/16257d74bf4f123a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h3><p>传送Body信息时需要对Body数据采取何种变换。当HTTP对Body进行分块传送时，需要增加下面的头部信息才可以进行分块传送。其它类型目前没有遇到过。</p><pre><code class="bash">Transfer-Encoding: chunked</code></pre><h3 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h3><p>服务器建议客户端升级传输协议。比如当客户端使用HTTP/1.0发送请求时，服务器就可以建议客户端升级到HTTP/1.1。<br>这个时候就可以使用Upgrade头。客户端收到这个Upgrade后就会将后续请求转成HTTP/1.1格式继续进行交流。可以支持多个参数，使用逗号分割即可。</p><pre><code class="bash">Upgrade: HTTP/1.1</code></pre><p>当客户端要和服务器进行Websocket进行通讯时，在握手阶段服务器也会向客户端发送Upgrade头部信息，提示客户端将协议切换到Websocket。</p><pre><code class="bash">Upgrade: WebSocket</code></pre><h3 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h3><p>该头部用于缓存控制。对于一些缓存服务器，我们在请求里加入Vary参数可以告知缓存服务器对不同的Vary参数的响应使用不同的缓存单元。比如Vary参数里放入编码参数，那么不同编码的网页就会有不同的缓存。Vary的值可以有多个，只要任意一个值不一样就会有不同的缓存。<br>比如下面的这个例子告知缓存服务器对不同语言和不同编码的网页响应使用不同的缓存单元。</p><pre><code class="bash">Vary: Accept-Encoding,Accept-Language</code></pre><h3 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h3><p>该字段用来标识一个请求经过的网关路由节点。如果这个请求经过了多个代理层，Via头部就会有多个网关信息。</p><h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><p>用于在响应中添加一些附加的警告信息，警告信息包含一个错误码和错误说明。通用的一些错误码在RFC协议中有具体规定。比如111号错误码表示缓存服务器的缓存项目已经过期，并且尝试reload资源，但是reload失败了，所以只好返回了旧的已经过期的内容，这个时候就需要通过warning头反馈客户端。</p><pre><code class="bash">Warning: 111 Revalidation failed</code></pre><h3 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h3><p>WWW-Authenticate是401 Unauthorized错误码返回时必须携带的头，该头会携带一个问题Challenge给客户端，告知客户端需要携带这个问题的答案来请求服务器才可以继续访问目标资源。这种问题Challenge可以自定义，比较常见的是Basic认证。</p><pre><code class="bash">WWW-Authenticate: Basic realm=xxx</code></pre><p>Basic指代base64加密算法(不安全)，realm指代认证范围/场合/情景名称。</p><h3 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h3><p>对于某些需要特殊权限才能访问的资源需要客户端在请求里提供用户名密码的认证信息。它是对WWW-Authenticate的应答。</p><pre><code class="bash">### value = base64(user_name:password)Authorization: Basic YWRtaW46YWRtaW4xMjM=</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/1625870c7cc549fb~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h3><p>同WWW-Authorization头部，用于代理服务器认证。</p><h3 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h3><p>同Authorization头部，用于代理服务器认证。</p><h3 id="ETag-vs-Last-Modified-vs-Expires"><a href="#ETag-vs-Last-Modified-vs-Expires" class="headerlink" title="ETag vs Last-Modified vs Expires"></a>ETag vs Last-Modified vs Expires</h3><p>ETag一般携带的是资源的版本号，协议没有具体规定版本号是什么。它可以是资源的md5校验码，也可以是uuid，甚至可以是自增的数字，也可以是资源的修改时间。它的匹配方式是相等/不相等。因为服务器需要维护版本号，取决的版本号是什么，这可能是一个存储和计算的负担。</p><p>Last-Modified携带的资源的修改时间。它的匹配方式是大于/小于。如果是静态资源文件，一般就是操作系统记录的文件修改时间。</p><p>Expires是服务器告知客户端资源的过期时间。客户端缓存的资源在这个时间之后自动过期，而不需要非得向服务器确认一下是不是304 Not Modified才认为没过期。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>这可能是HTTP头里面最复杂的一个头了。这个头既可以用于请求，也可以用于响应。在请求和响应的取值不一样，分别代表了不同的意思。</p><ul><li><p>no-cache 如果no-cache没有指定值，那就表示不允许缓存。对于请求来说，服务器不得使用缓存内容直接返回。对于响应来说，客户端不得缓存响应的资源内容。如果no-cache指定了值，那就表示值对应的头信息不得使用缓存，其它的信息还是可以缓存的。告知对方我只要新鲜刚出浴的数据。</p></li><li><p>no-store 告知对方不要持久化请求/响应数据到其它地方，这种信息是敏感的，要保持它的易失性。告知对方记在心里(memory)就行，别写在纸上(disk)。</p></li><li><p>no-transform 告知对方不要转换数据。比如客户端上传了raw图像数据，服务器一般都会选择性压缩图像数据进行存储。no-transform告知对方保留原始数据信息，不要进行任何转换。告知对方不要乱动我发过来的东西。</p></li><li><p>only-if-cached 用于请求头，告知服务器只要那些已经缓存的内容，不要去reload。如果没有缓存内容就返回504 Gateway Timeout错误。表示客户端不想太麻烦服务器，有就给，没就算了。</p></li><li><p>max-age 用于请求头。限制缓存内容的年龄，如果超过max-age年龄的，需要服务器去reload内容资源。这叫客户端的年龄歧视。</p></li><li><p>max-stale 用于请求头。客户端允许服务器返回缓存已过期的资源内容，但是限定了最大过期时间。表示客户端虽然很宽容，那是也是有限度的。</p></li><li><p>min-fresh 用于请求头。客户端限制服务器不要那些即将过期的资源内容。就好比我们去超市买牛奶，如果牛奶快过期了虽然还在保质期内咱们也就不会考虑。</p></li><li><p>public 用于响应头。表示允许客户端缓存响应信息，并可以给别人使用。比如代理服务器缓存静态资源供所有代理用户使用。</p></li><li><p>private 用于响应头。表示仅允许客户端缓存响应信息给自己使用，不得分享给别人。这样是为了禁止代理服务器进行缓存，而允许客户端自己缓存资源内容。意思是你个人留着用就行，别借给别人用。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>virtualenvwrapper：Python_环境管理工具</title>
      <link href="/2022/06/08/virtualenvwrapper%EF%BC%9APython_%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/06/08/virtualenvwrapper%EF%BC%9APython_%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>在使用 Python 开发的过程中，工程一多，难免会碰到不同的工程依赖不同版本的库的问题；亦或者是在开发过程中不想让物理环境里充斥各种各样的库，引发未来的依赖灾难。如果我们要同时开发多个应用程序，那这些应用程序都会共用一个 Python，就是安装在系统的 Python 3。如果应用 A 需要  jinja 2.7，而应用 B 需要 jinja 2.6 怎么办？此时，我们需要对于不同的工程使用不同的虚拟环境来保持开发环境以及宿主环境的清洁。为了不污染全局环境，通常都会使用环境隔离管理工具 <code>virtualenv</code> 与 <code>virtualenvwrapper</code>。<br><code>virtualenv</code> 是在项目底下执行生成 <code>venv</code> 环境目录以此来进行管理，这非常适合使用诸如 <code>VSCode</code> 这种集成环境配置的开发工具；那么当通过 shell 来运行 <code>virtualenv</code> 时便会显得非常麻烦，因为每次 shell 关闭再打开后都需要重新配置环境参数。<br><code>virtualenv</code> 需要每次使用 source 命令导入虚拟机运行环境，这一点非常麻烦，另外开发者还有可能忘记虚拟环境目录的建立位置，<code>virtualenvwrapper</code> 这一命令行工具就是通过对 <code>virtualenv</code> 进行封装，解决了上述问题。<code>virtualenvwrapper</code> 是将所有的 Python 项目虚拟环境环境都存放在一起，在使用 shell 配合小型开发工具就会非常方便。</p><h2 id="virtualenvwrapper-安装配置（Mac）"><a href="#virtualenvwrapper-安装配置（Mac）" class="headerlink" title="virtualenvwrapper 安装配置（Mac）"></a>virtualenvwrapper 安装配置（Mac）</h2><p>使用 pip3 安装，<code>virtualenv</code> 也会在此期间安装完毕</p><pre><code class="bash">$ sudo pip3 install virtualenvwrapper</code></pre><p>新建存放环境目录</p><pre><code class="bash">$ mkdir -p ~/.virtualenvs</code></pre><p>配置 <code>virtualenvwrapper</code> 环境（使用 python 3），打开 .zshrc，执行 <code>vim ~/.zshrc</code> 并写入(如果有安装<code>item2</code>与<code>oh-my-zsh</code>)</p><pre><code class="bash"># 设置virtualenvwrapper    export WORKON_HOME=&quot;~/.virtualenvs&quot;    export VIRTUALENVWRAPPER_PYTHON=&quot;/usr/local/bin/python3&quot;    # 打开终端自动启用    source /usr/local/bin/virtualenvwrapper.sh</code></pre><p>使配置生效</p><pre><code class="bash">$ source ~/.zshrc</code></pre><h2 id="virtualenvwrapper-使用"><a href="#virtualenvwrapper-使用" class="headerlink" title="virtualenvwrapper 使用"></a>virtualenvwrapper 使用</h2><p>新建虚拟环境 <code>Test</code> 并指定 Python 版本为 Python3：</p><pre><code class="bash">$ mkvirtualenv Test --python=python3</code></pre><p>执行 <code>lsvirtualenv</code> 指令查看所有环境，环境 <code>Test</code> 位于 ~/Envs/test</p><pre><code class="bash">$ lsvirtualenv    Test    ==== </code></pre><p>在项目底下激活虚拟环境 <code>Test</code>：</p><pre><code class="bash">$ workon Test</code></pre><p>其他指令：</p><pre><code class="bash">## 退出环境 Test    deactivate    ## 删除环境 Test    rmvirtualenv test    ## 更多指令可以在 shell 中输入 virtualenv 回车会有提示</code></pre><h2 id="在-VSCode-中使用虚拟环境"><a href="#在-VSCode-中使用虚拟环境" class="headerlink" title="在 VSCode 中使用虚拟环境"></a>在 VSCode 中使用虚拟环境</h2><p>进入工作环境设置文件 <code>settings.json</code>，加入如下配置： </p><pre><code class="bash">&quot;python.venvPath&quot;: &quot;~/.virtualenvs&quot;</code></pre><p>具体操作界面如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/virtualenvwrapper：Python_环境管理工具/1654943943.082001.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>重启 <code>VSCode</code> 即可看到配置已经成功被识别，便可以选择刚才新建的虚拟环境 <code>Test</code>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/virtualenvwrapper：Python_环境管理工具/1654943943.202436.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/70389886" target="_blank" rel="noopener">virtualenvwrapper：Python_环境管理工具</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux用netstat查看服务及监听端口详解</title>
      <link href="/2022/06/07/Linux%E7%94%A8netstat%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%8F%8A%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/07/Linux%E7%94%A8netstat%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%8F%8A%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在Linux使用过程中，需要了解当前系统开放了哪些端口，并且要查看开放这些端口的具体进程和用户，可以通过netstat命令进行简单查询</p><h3 id="netstat命令各个参数说明如下："><a href="#netstat命令各个参数说明如下：" class="headerlink" title="netstat命令各个参数说明如下："></a>netstat命令各个参数说明如下：</h3><ul><li>-a   或–all                             显示所有连线中的Socket。</li><li> -A                                       &lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。</li><li> -c   或–continuous               持续列出网络状态。</li><li> -C 或–cache                       显示路由器配置的快取信息。</li><li> -e  或–extend                     显示网络其他相关信息。</li><li> -F  或 –fib                          显示FIB。</li><li> -g  或–groups                     显示多重广播功能群组组员名单。</li><li> -h  或–help                        在线帮助。</li><li> -i   或–interfaces                 显示网络界面信息表单。</li><li> -l  或–listening                    显示监控中的服务器的Socket。</li><li> -M   或–masquerade           显示伪装的网络连线。</li><li> -n  或–numeric                   直接使用IP地址，而不通过域名服务器。</li><li> -N   或–netlink或–symbolic  显示网络硬件外围设备的符号连接名称。</li><li> -o  或–timers                      显示计时器。</li><li> -p   或–programs                显示正在使用Socket的程序识别码和程序名称。</li><li> -r  或–route                        显示 Routing Table。</li><li> -s  或–statistice 显示网络工作信息统计表。</li><li> -t  或–tcp 显示TCP 传输协议的连线状况。</li><li> -u或–udp 显示UDP传输协议的连线状况。</li><li> -v或–verbose 显示指令执行过程。</li><li> -V 或–version 显示版本信息。</li><li> -w或–raw 显示RAW传输协议的连线状况。</li><li> -x或–unix 此参数的效果和指定”-A unix”参数相同。</li><li> –ip或–inet 此参数的效果和指定”-A inet”参数相同。</li></ul><p>即可显示当前服务器上所有端口及进程服务，于grep结合可查看某个具体端口及服务情况：</p><pre><code class="bash">[root@localhost ~]# netstat -ntlp   //查看当前所有tcp端口·[root@localhost ~]# netstat -ntulp |grep 80   //查看所有80端口使用情况·[root@localhost ~]# netstat -an | grep 3306   //查看所有3306端口使用情况·[root@localhost ~]# netstat -nlp |grep LISTEN   //查看当前所有监听端口·</code></pre><h3 id="查看当前所有tcp端口使用情况："><a href="#查看当前所有tcp端口使用情况：" class="headerlink" title="查看当前所有tcp端口使用情况："></a>查看当前所有tcp端口使用情况：</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Linux用netstat查看服务及监听端口详解/1654944231.708832.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里解释一下：</p><ul><li>1、0.0.0.0代表本机上可用的任意地址。 比如0.0.0.0:135 表示本机上所有地址的135端口，这样多ip计算机就不用重复显示了。</li><li> 2、TCP 0.0.0.0:80表示在所有的可用接口上监听TCP80端口 </li><li> 3、0.0.0.0为默认路由，即要到达不再路由表里面的网段的包都走0.0.0.0这条规则</li></ul><p>然后127.0.0.1就是表示你本机ip地址的意思了。</p><p>然后[::]:21这又是什么鬼？</p><p>这个表示ipv6的21号端口的意思。</p><p>还有UDP的外部链接怎么都是*:*呢？</p><p><em>：</em>是网址的通配符，就是192.168.15.12，这个类型的整体描述。</p><p>解释一下状态（state）了</p><ul><li>LISTEN：(Listening for a connection.)侦听来自远方的TCP端口的连接请求</li><li>SYN-SENT：(Active; sent SYN. Waiting for a matching connection request after having sent a connection request.)再发送连接请求后等待匹配的连接请求</li><li>SYN-RECEIVED：(Sent and received SYN. Waiting for a confirming connection request acknowledgment after having both received and sent connection requests.)再收到和发送一个连接请求后等待对方对连接请求的确认</li><li>ESTABLISHED：(Connection established.)代表一个打开的连接</li><li>FIN-WAIT-1：(Closed; sent FIN.)等待远程TCP连接中断请求，或先前的连接中断请求的确认</li><li>FIN-WAIT-2：(Closed; FIN is acknowledged; awaiting FIN.)从远程TCP等待连接中断请求</li><li>CLOSE-WAIT：(Received FIN; waiting to receive CLOSE.)等待从本地用户发来的连接中断请求</li><li>CLOSING：(Closed; exchanged FIN; waiting for FIN.)等待远程TCP对连接中断的确认</li><li>LAST-ACK：(Received FIN and CLOSE; waiting for FIN ACK.)等待原来的发向远程TCP的连接中断请求的确认</li><li>TIME-WAIT：(In 2 MSL (twice the maximum segment length) quiet wait after close. )等待足够的时间以确保远程TCP接收到连接中断请求的确认</li><li>CLOSED：(Connection is closed.)没有任何连接状态</li></ul><p>例如要查看当前Mysql默认端口80是否启动可以做如下操作</p><p><img src="/images/Linux%E7%94%A8netstat%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%8F%8A%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E8%AF%A6%E8%A7%A3/1654944231.880319.jpg"></p><p>netstat -ano来显示协议统计信息和TCP/IP网络连接</p><p>netstat -t/-u/-l/-r/-n【显示网络相关信息,-t:TCP协议,-u:UDP协议,-l:监听,-r:路由,-n:显示IP地址和端口号】</p><p>netstat -tlun【查看本机监听的端口】</p><p>netstat -an【查看本机所有的网络】</p><p>netstat -rn【查看本机路由表】</p><p>列出所有端口：netstat -a </p><p>列出所有的TCP端口：netstat -at </p><p>列出所有的UDP端口：netstat -au </p><p>列出所有处于监听状态的socket：netstat -l </p><p>列出所有监听TCP端口的socket：netstat -lt </p><p>列出所有监听UDP端口的socket：netstat -lu </p><p>找出程序运行的端口：netstat -ap | grep ssh </p><p>找出运行在指定端口的进程：netstat -an | grep ‘:80’</p><p>几个有用查找：</p><pre><code class="bash">1.查找请求数前20个IP（常用于查找攻来源）：netstat -anlp|grep 80|grep tcp|awk &#39;{print $5}&#39;|awk -F: &#39;{print $1}&#39;|sort|uniq -c|sort -nr|head -n20 netstat -ant |awk &#39;/:80/{split($5,ip,”:”);++A[ip[1]]}END{for(i in A) print A[i],i}&#39; |sort -rn|head -n20 2.用tcpdump嗅探80端口的访问看看谁最高tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F”.” &#39;{print $1″.”$2″.”$3″.”$4}&#39; | sort | uniq -c | sort -nr |head -20 3.查找较多time_wait连接netstat -n|grep TIME_WAIT|awk &#39;{print $5}&#39;|sort|uniq -c|sort -rn|head -n20 4.找查较多的SYN连接netstat -an | grep SYN | awk &#39;{print $5}&#39; | awk -F: &#39;{print $1}&#39; | sort | uniq -c | sort -nr | more 5.根据端口列进程netstat -ntlp | grep 80 | awk &#39;{print $7}&#39; | cut -d/ -f1</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/wade3015/article/details/90779669" target="_blank" rel="noopener">Linux用netstat查看服务及监听端口详解</a></p><p> </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>systemctl命令介绍和使用</title>
      <link href="/2022/06/06/systemctl%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/06/systemctl%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Systemd程序"><a href="#Systemd程序" class="headerlink" title="Systemd程序"></a>Systemd程序</h3><p>Systemd其实是Linux系统用来管理系统的一个程序，用来代替原来的init进程(用来管理启动系统其它的服务进程)，现在很多Linux发行版都已经自带Systemd程序了。</p><h3 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h3><h4 id="1-Unit"><a href="#1-Unit" class="headerlink" title="1. Unit"></a>1. Unit</h4><p>systemctl命令是Systemd中最重要的一个命令，用于对服务进行启动，停止等操作，在Systemd中有Unit的概念，每个进程都是一个Unit，总共有十二种Unit类型。</p><ul><li>Service unit，系统服务</li><li>Target unit，多个 Unit 构成的一个组</li><li>Device Unit，硬件设备</li><li>Mount Unit，文件系统的挂载点</li><li>Automount Unit，自动挂载点</li><li>Path Unit，文件或路径</li><li>Scope Unit，不是由 Systemd 启动的外部进程</li><li>Slice Unit，进程组</li><li>Snapshot Unit，Systemd 快照，可以切回某个快照</li><li>Socket Unit，进程间通信的 socket</li><li>Swap Unit，swap 文件</li><li>Timer Unit，定时器</li></ul><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><pre><code class="bash"># 列出正在运行的Unitsystemctl list-units，可以直接使用systemctl# 列出所有Unit，包括没有找到配置文件的或者启动失败的systemctl list-units --all# 列出所有没有运行的 Unitsystemctl list-units --all --state=inactive# 列出所有加载失败的 Unitsystemctl list-units --failed# 列出所有正在运行的、类型为service的Unitsystemctl list-units --type=service# 显示某个 Unit 是否正在运行systemctl is-active application.service# 显示某个 Unit 是否处于启动失败状态systemctl is-failed application.service# 显示某个 Unit 服务是否建立了启动链接systemctl is-enabled application.service# 立即启动一个服务sudo systemctl start apache.service# 立即停止一个服务sudo systemctl stop apache.service# 重启一个服务sudo systemctl restart apache.service# 重新加载一个服务的配置文件sudo systemctl reload apache.service# 重载所有修改过的配置文件sudo systemctl daemon-reload</code></pre><h3 id="systemctl中Unit的配置文件"><a href="#systemctl中Unit的配置文件" class="headerlink" title="systemctl中Unit的配置文件"></a>systemctl中Unit的配置文件</h3><p>上面说了每个服务都是一个Unit，那每个Unit都会有它的配置文件，这样启动的时候才知道要按照什么方式去启动。Systemd默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在那个目录。</p><h4 id="1-查看Unit的配置文件"><a href="#1-查看Unit的配置文件" class="headerlink" title="1. 查看Unit的配置文件"></a>1. 查看Unit的配置文件</h4><p>可以使用<code>systemctl cat</code>命令来查看服务的配置文件，下面是Mysql的配置文件，很多软件已经支持Systemd程序了，安装的时候会自动配置它的Unit配置文件，例如Mysql和Nginx等等。</p><pre><code class="bash">[root@VM_0_11_centos ~]# systemctl cat mysqld# /usr/lib/systemd/system/mysqld.service[Unit]Description=MySQL ServerDocumentation=man:mysqld(8)Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.htmlAfter=network.targetAfter=syslog.target[Install]WantedBy=multi-user.target[Service]User=mysqlGroup=mysqlType=forkingPIDFile=/var/run/mysqld/mysqld.pid# Disable service start and stop timeout logic of systemd for mysqld service.TimeoutSec=0# Execute pre and post scripts as rootPermissionsStartOnly=true# Needed to create system tablesExecStartPre=/usr/bin/mysqld_pre_systemd# Start main serviceExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS# Use this to switch malloc implementationEnvironmentFile=-/etc/sysconfig/mysql# Sets open_files_limitLimitNOFILE = 5000Restart=on-failureRestartPreventExitStatus=1PrivateTmp=false</code></pre><h4 id="2-Unit配置文件的含义"><a href="#2-Unit配置文件的含义" class="headerlink" title="2. Unit配置文件的含义"></a>2. Unit配置文件的含义</h4><pre><code class="bash">可以看到Unit配置文件有很多标签，不同的标签都代表了不同的意思，这里只列出部分介绍，可以去官网查看Unit配置文件文档介绍，https://www.freedesktop.org/software/systemd/man/systemd.unit.html。- Unit   - Description，服务的描述   - Documentation，文档介绍   - After，该服务要在什么服务启动之后启动，比如Mysql需要在network和syslog启动之后再启动- Install   - WantedBy，值是一个或多个Target，当前Unit激活时(enable)符号链接会放入/etc/systemd/system目录下面以Target名+.wants后缀构成的子目录中   - RequiredBy，它的值是一个或多个Target，当前Unit激活(enable)时，符号链接会放入/etc/systemd/system目录下面以Target名+.required后缀构成的子目录中   - Alias，当前Unit可用于启动的别名   - Also，当前Unit激活(enable)时，会被同时激活的其他Unit- Service   - Type，定义启动时的进程行为。它有以下几种值。   - Type=simple，默认值，执行ExecStart指定的命令，启动主进程   - Type=forking，以 fork 方式从父进程创建子进程，创建后父进程会立即退出   - Type=oneshot，一次性进程，Systemd 会等当前服务退出，再继续往下执行   - Type=dbus，当前服务通过D-Bus启动   - Type=notify，当前服务启动完毕，会通知Systemd，再继续往下执行   - Type=idle，若有其他任务执行完毕，当前服务才会运行   - ExecStart，启动当前服务的命令   - ExecStartPre，启动当前服务之前执行的命令   - ExecStartPost，启动当前服务之后执行的命令   - ExecReload，重启当前服务时执行的命令   - ExecStop，停止当前服务时执行的命令   - ExecStopPost，停止当其服务之后执行的命令   - RestartSec，自动重启当前服务间隔的秒数   - Restart，定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog   - TimeoutSec，定义 Systemd 停止当前服务之前等待的秒数   - Environment，指定环境变量</code></pre><h3 id="自定义服务启动"><a href="#自定义服务启动" class="headerlink" title="自定义服务启动"></a>自定义服务启动</h3><p>既然Systemd的作用就是控制服务的启动，那么就可以把自己的服务添加进去，就可以直接使用systemctl命令来控制服务的启动，或者是设置开机自动启动等等。</p><h4 id="1-创建Unit配置文件"><a href="#1-创建Unit配置文件" class="headerlink" title="1. 创建Unit配置文件"></a>1. 创建Unit配置文件</h4><p>在<code>/usr/lib/systemd/system</code>目录中创建自己的配置文件，一般都是<code>.service</code>结尾，例如这里创建了一个<code>test-sh.service</code>配置文件，这个Unit是为了启动我们自己的一个shell脚本。</p><pre><code class="bash"># /usr/lib/systemd/system/test-sh.service[Unit]Description= test sh log[Service]ExecStart=/opt/dev/shell/test.shType=forkingKillMode=processRestart=on-failureRestartSec=30s[Install]WantedBy=multi-user.target</code></pre><h4 id="2-创建脚本"><a href="#2-创建脚本" class="headerlink" title="2. 创建脚本"></a>2. 创建脚本</h4><pre><code class="bash">在上面配置文件指定的启动路径`/opt/dev/shell/`下创建shell脚本，这里只是每秒打印当前时间，并输出到一个文本中。#!/bin/bashwhile truedosleep 1 date=`date -d today +&quot;%Y-%m-%d %T&quot;` echo ${date} &gt;&gt; /opt/dev/shell/test.txtdone</code></pre><h4 id="3-载入配置文件并启动"><a href="#3-载入配置文件并启动" class="headerlink" title="3. 载入配置文件并启动"></a>3. 载入配置文件并启动</h4><pre><code class="bash">使用`systemctl daemon-reload`命令来载入新添加的配置文件，然后使用`systemctl start test-sh.service`命令启动，再使用`systemctl status test-sh.service`命令来查看状态，可以看到已经启动，`/opt/dev/shell/test.txt`也确实在不停的写入内容，最后使用`systemctl stop test-sh.service`命令停止服务，可以看到状态也是停止了。注意的是修改配置文件后一定要使用`systemctl daemon-reload`命令来载入新添加的配置文件，然后再启动服务。[root@VM_0_11_centos ~]# systemctl start test-sh.service^C[root@VM_0_11_centos ~]# systemctl status test-sh.service● test-sh.service - test sh log   Loaded: loaded (/usr/lib/systemd/system/test-sh.service; enabled; vendor preset: disabled)   Active: activating (start) since Fri 2020-06-26 05:46:45 CST; 11s ago   Control: 9295 (test.sh)   CGroup: /system.slice/test-sh.service       ├─9295 /bin/bash /opt/dev/shell/test.sh       └─9343 sleep 1Jun 26 05:46:45 VM_0_11_centos systemd[1]: Starting test sh log...[root@VM_0_11_centos ~]# systemctl stop test-sh.service[root@VM_0_11_centos ~]# systemctl status test-sh.service● test-sh.service - test sh log   Loaded: loaded (/usr/lib/systemd/system/test-sh.service; enabled; vendor preset: disabled)   Active: inactive (dead) since Fri 2020-06-26 05:47:52 CST; 2s ago  Process: 9295 ExecStart=/opt/dev/shell/test.sh (code=killed, signal=TERM)Jun 26 05:46:45 VM_0_11_centos systemd[1]: Starting test sh log...Jun 26 05:47:52 VM_0_11_centos systemd[1]: Stopped test sh log.</code></pre><h3 id="查看Unit启动日志"><a href="#查看Unit启动日志" class="headerlink" title="查看Unit启动日志"></a>查看Unit启动日志</h3><p>Systemd统一管理了所有Unit的启动日志，因此只需要使用journalctl命令就可以查看到服务的日志</p><pre><code class="bash"># 查看所有日志（默认情况下 ，只保存本次启动的日志）journalctl# 查看指定时间的日志journalctl --since=&quot;2012-10-30 18:17:16&quot;journalctl --since &quot;20 min ago&quot;journalctl --since yesterdayjournalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;journalctl --since 09:00 --until &quot;1 hour ago&quot;# 显示尾部的最新10行日志journalctl -n# 显示尾部指定行数的日志journalctl -n 20# 实时滚动显示最新日志journalctl -f# 查看指定服务的日志journalctl /usr/lib/systemd/systemd# 查看指定进程的日志journalctl _PID=1# 查看某个路径的脚本的日志journalctl /usr/bin/bash# 查看指定用户的日志journalctl _UID=33 --since today# 查看某个 Unit 的日志journalctl -u nginx.servicejournalctl -u nginx.service --since today# 实时滚动显示某个 Unit 的最新日志journalctl -u nginx.service -f# 合并显示多个 Unit 的日志$ journalctl -u nginx.service -u php-fpm.service --since today</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 系统管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中查看各文件夹大小命令du -h --max-depth=1</title>
      <link href="/2021/11/21/Linux%E4%B8%AD%E6%9F%A5%E7%9C%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%91%BD%E4%BB%A4du%20-h%20--max-depth=1/"/>
      <url>/2021/11/21/Linux%E4%B8%AD%E6%9F%A5%E7%9C%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%91%BD%E4%BB%A4du%20-h%20--max-depth=1/</url>
      
        <content type="html"><![CDATA[<p>du [-abcDhHklmsSx] [-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;] [–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]<br>常用参数：<br>-a或-all 为每个指定文件显示磁盘使用情况，或者为目录中每个文件显示各自磁盘使用情况。<br>-b或-bytes 显示目录或文件大小时，以byte为单位。<br>-c或–total 除了显示目录或文件的大小外，同时也显示所有目录或文件的总和。<br>-D或–dereference-args 显示指定符号连接的源文件大小。<br>-h或–human-readable 以K，M，G为单位，提高信息的可读性。<br>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位,而不是以1024为换算单位。<br>-k或–kilobytes 以1024 bytes为单位。<br>-l或–count-links 重复计算硬件连接的文件。<br>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。<br>-m或–megabytes 以1MB为单位。<br>-s或–summarize 仅显示总计，即当前目录的大小。<br>-S或–separate-dirs 显示每个目录的大小时，并不含其子目录的大小。<br>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<br>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。<br>–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。<br>–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。<br>–help 显示帮助。<br>–version 显示版本信息。</p><p><strong>1&gt; 要显示一个目录树及其每个子树的磁盘使用情况</strong><br>du /home/linux<br>这在/home/linux目录及其每个子目录中显示了磁盘块数。  </p><p><strong>2&gt; 要通过以1024字节为单位显示一个目录树及其每个子树的磁盘使用情况</strong><br>du -k /home/linux<br>这在/home/linux目录及其每个子目录中显示了 1024 字节磁盘块数。  </p><p><strong>3&gt; 以MB为单位显示一个目录树及其每个子树的磁盘使用情况</strong><br>du -m /home/linux<br>这在/home/linux目录及其每个子目录中显示了 MB 磁盘块数。  </p><p><strong>4&gt; 以GB为单位显示一个目录树及其每个子树的磁盘使用情况</strong><br>du -g /home/linux<br>这在/home/linux目录及其每个子目录中显示了 GB 磁盘块数。  </p><p><strong>5&gt;查看当前目录下所有目录以及子目录的大小：</strong><br>du -h .<br>“.”代表当前目录下。也可以换成一个明确的路径<br>-h表示用K、M、G的人性化形式显示  </p><p><strong>6&gt;查看当前目录下user目录的大小，并不想看其他目录以及其子目录：</strong><br>du -sh user<br>-s表示总结的意思，即只列出一个总结的值<br>du -h –max-depth=0 user<br>–max-depth=n表示只深入到第n层目录，此处设置为0，即表示不深入到子目录。  </p><p><strong>7&gt;列出user目录及其子目录下所有目录和文件的大小：</strong><br>du -ah user<br>-a表示包括目录和文件  </p><p><strong>8&gt;列出当前目录中的目录名不包括xyz字符串的目录的大小：</strong><br>du -h –exclude=’<em>xyz</em>‘  </p><p><strong>9&gt;想在一个屏幕下列出更多的关于user目录及子目录大小的信息：</strong><br>du -0h user<br>-0（杠零）表示每列出一个目录的信息，不换行，而是直接输出下一个目录的信息。  </p><p><strong>10&gt;只显示一个目录树的全部磁盘使用情况</strong><br>du -s /home/linux</p><p><strong>11&gt;查看各文件夹大小:du -h –max-depth=1</strong><br> 查看指定目录：<br> 代码如下：  其中 /path表示路径</p><pre><code class="bash">du -h --max-depth=1 /path</code></pre><p> 具体如下所示：</p><pre><code class="bash">root@ubuntu4146:~# du -h --max-depth=1 /data/1.1G    /data/gitlabDataa8.0K    /data/test241G    /data/gitlabData809G    /data/home15G    /data/OpenGrok16K    /data/lost+found1.1T    /data/</code></pre><p> 我们发现  /data/home/ 目录占用最多，因此我们可以继续看那个目录占用的最多，如下所示：</p><pre><code class="bash">root@ubuntu4146:/data/home# du -h --max-depth=1 /data/home/141G    /data/home/wzm62G    /data/home/lwc421G    /data/home/hcy16K    /data/home/zzp16K    /data/home/zl54G    /data/home/drj122G    /data/home/sjq4.1G    /data/home/ljs6.7G    /data/home/ywm809G    /data/home/root@ubuntu4146:/data/home# </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 文件管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij IDEA破解补丁FineAgent，可破解至2099</title>
      <link href="/2021/11/18/Intellij%20IDEA%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B%EF%BC%8CIDEA%E7%A0%B4%E8%A7%A3%E8%A1%A5%E4%B8%81FineAgent%EF%BC%8C%E5%8F%AF%E7%A0%B4%E8%A7%A3%E8%87%B3%202099%20%E5%B9%B4/"/>
      <url>/2021/11/18/Intellij%20IDEA%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B%EF%BC%8CIDEA%E7%A0%B4%E8%A7%A3%E8%A1%A5%E4%B8%81FineAgent%EF%BC%8C%E5%8F%AF%E7%A0%B4%E8%A7%A3%E8%87%B3%202099%20%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<p>有网友问我，IDEA 产品能否永久激活呢？目前，我在网上逛了一圈，又发现某大佬开发了一款新的破解补丁，叫<strong>FineAgent</strong>，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812172447.png" alt="IDEA破解成功" title="IDEA破解成功">                </div>                <div class="image-caption">IDEA破解成功</div>            </figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li>本教程适用于**JetBrains 全系列产品，可放心使用；</li><li>本教程适用于 <strong>Windows</strong>/<strong>Mac</strong>/<strong>Linux</strong> 系统；</li><li>本教程适用于 <strong>JetBrains 全系列产品</strong>，包括 <strong>IntelliJ IDEA</strong>、<strong>APPCode</strong>、<strong>CLion</strong>、<strong>DataGrip</strong>、<strong>GoLand</strong>、<strong>PhpStorm</strong>、<strong>PyCharm</strong>、<strong>Rider</strong>、<strong>RubyMine</strong> 和 <strong>WebStorm</strong>。</li></ul><h1 id="教程演示"><a href="#教程演示" class="headerlink" title="教程演示"></a>教程演示</h1><p>下面的教程演示使用的是 <strong>Windows</strong> 系统，安装的 <strong>IDEA 版本为 2021.2</strong>。</p><h3 id="1、下载自己需要的IDEA"><a href="#1、下载自己需要的IDEA" class="headerlink" title="1、下载自己需要的IDEA"></a>1、下载自己需要的IDEA</h3><p>IDEA 老版本下载地址：<a href="https://www.jetbrains.com/zh-cn/idea/download/other.html" target="_blank" rel="noopener">https://www.jetbrains.com/zh-cn/idea/download/other.html</a></p><h3 id="2、安装IDEA"><a href="#2、安装IDEA" class="headerlink" title="2、安装IDEA"></a>2、安装IDEA</h3><p>这个操作就easy了，我们按照常规的安装方式安装就行，我就不详细说了。<br>如果你真的不会的话，那说明你确实不太适合做程序员~</p><h3 id="3、重置IDEA并点击试用"><a href="#3、重置IDEA并点击试用" class="headerlink" title="3、重置IDEA并点击试用"></a>3、重置IDEA并点击试用</h3><p>1）如果你的IDEA是新安装的，可以直接点击 <strong>试用</strong>，跳过这一步接下来的操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210424231958.png" alt="IDEA试用" title="IDEA试用">                </div>                <div class="image-caption">IDEA试用</div>            </figure><p>2）如果你的电脑之前安装过IDEA且超过试用期（还在试用期的可以忽略该步骤），可以直接通过我这里提供的重置脚本进行重置就行，其原理是删除jetbrains全系列产品软件试用相关目录（其他配置不受影响）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210423185059.png" alt="IDEA重置脚本" title="IDEA重置脚本">                </div>                <div class="image-caption">IDEA重置脚本</div>            </figure><p>IDEA重置脚本安全可靠，大家可以看看下面的源码哈：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210423185142.png" alt="IDEA重置脚本" title="IDEA重置脚本">                </div>                <div class="image-caption">IDEA重置脚本</div>            </figure><p>重置IDEA之后，打开IDEA，点击试用，按照图示选择试用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210424231958.png" alt="IDEA试用" title="IDEA试用">                </div>                <div class="image-caption">IDEA试用</div>            </figure><p><strong>说明：最新的 IDEA 2021.2.3 版本 IDEA 界面发生了变化，取消了直接试用 30 天的按钮，需要我们先注册一个 JetBrains（这里我用的 GitHub 账号注册的）</strong>，如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.javatiku.cn/usr/img/4816dd4fc758afa9e0e4e717059ed162.png" alt="IDEA试用" title="IDEA试用">                </div>                <div class="image-caption">IDEA试用</div>            </figure><p>注册账号并登录后，就可以试用 IDEA 了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.javatiku.cn/usr/img/96f2e7b62949112c63fe5eb498bd2d64.png" alt="IDEA试用" title="IDEA试用">                </div>                <div class="image-caption">IDEA试用</div>            </figure><h3 id="4、下载破解补丁"><a href="#4、下载破解补丁" class="headerlink" title="4、下载破解补丁"></a>4、下载破解补丁</h3><p>该破解方法需要用到的文件都准备好了，通过下方的网盘链接下载就行。</p><h6 id="蓝奏云下载"><a href="#蓝奏云下载" class="headerlink" title="蓝奏云下载"></a><a href="https://wwe.lanzoui.com/iWZ0Nwm96od" target="_blank" rel="noopener">蓝奏云下载</a></h6><p>压缩包目录结构：</p><pre><code>FineAgent.zip|---激活码|---FineAgent.jarreset_script.zip</code></pre><h3 id="5、安装破解补丁"><a href="#5、安装破解补丁" class="headerlink" title="5、安装破解补丁"></a>5、安装破解补丁</h3><p>如果你之前安装过 IDEA, 那么修改过的 hosts 文件要还原回去、引用过的补丁要移除掉等, 不然可能会有各种奇奇怪怪的问题。<br>打开IDEA，你可以在Help -&gt; Eidt Custom VM Options… ，参考如下图所示:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812172939.png" alt="安装破解补丁" title="安装破解补丁">                </div>                <div class="image-caption">安装破解补丁</div>            </figure><p>由于我把压缩包内的<code>FineAgent.jar</code>直接放在D盘的根目录，所以一定要先清除vmoptions文件内其它的<code>-javaagent:xxx</code>配置（否则会存在IDEA打不开的情况），然后再在最后一行加上如下代码：</p><pre><code>-javaagent:d:/FineAgent.jar</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812173210.png" alt="IDEA破解教程" title="IDEA破解教程">                </div>                <div class="image-caption">IDEA破解教程</div>            </figure><h3 id="6、重启IDEA"><a href="#6、重启IDEA" class="headerlink" title="6、重启IDEA"></a>6、重启IDEA</h3><p>安装完成后，重启 idea。</p><h3 id="7、通过指定的注册码来激活IDEA"><a href="#7、通过指定的注册码来激活IDEA" class="headerlink" title="7、通过指定的注册码来激活IDEA"></a>7、通过指定的注册码来激活IDEA</h3><p>重启后，便会提示你输入激活码，激活码在压缩包内 <code>ActivationCode.txt</code> ，这时，你可以用压缩包内的激活码进行激活，如下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812173504.png" alt="IDEA激活码" title="IDEA激活码">                </div>                <div class="image-caption">IDEA激活码</div>            </figure><p>此时，点击Activate，便激活成功了。</p><h3 id="8、如何验证是否激活成功呢？"><a href="#8、如何验证是否激活成功呢？" class="headerlink" title="8、如何验证是否激活成功呢？"></a>8、如何验证是否激活成功呢？</h3><p>你直接进入 IDEA 主界面，在上方的菜单栏点击 <code>Help</code> -&gt; <code>Register</code> 查看当前激活状态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812173753.png" alt="IDEA破解教程" title="IDEA破解教程">                </div>                <div class="image-caption">IDEA破解教程</div>            </figure><p>这时候你就可以看到，已经激活至 2099 年啦，爽歪歪~</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812173856.png" alt="IDEA破解教程" title="IDEA破解教程">                </div>                <div class="image-caption">IDEA破解教程</div>            </figure><h3 id="为何IDEA打不开？"><a href="#为何IDEA打不开？" class="headerlink" title="为何IDEA打不开？"></a>为何IDEA打不开？</h3><p>一个最主要的原因是：你在<code>vmoptions</code>文件配置的路径不对。<br>如果你想打开IDEA，那么需要找到以<code>vmoptions</code>后缀结尾的文件(一般位于<code>C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2021.2</code>目录下)，找到 <code>idea64.exe.vmoptions</code>，打开之后，删除 -javaagent:xxx的信息，即可打开，虽然IDEA能打开了，但是很不幸你未破解成功！<br>要想重新破解，那么请重复上述步骤！！！<br>希望本教程对你有所帮助！</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="http://www.javatiku.cn/idea/5.html" target="_blank" rel="noopener">http://www.javatiku.cn/idea/5.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 破解 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客备份与恢复</title>
      <link href="/2021/11/15/Hexo%20%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>/2021/11/15/Hexo%20%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-博客备份与恢复"><a href="#Hexo-博客备份与恢复" class="headerlink" title="Hexo 博客备份与恢复"></a>Hexo 博客备份与恢复</h1><p>本文旨在解决在不同电脑上都能维护博客或配置、发布的内容丢失可恢复的问题。<br>观察部署到仓库的内容，我们可以看到上传的内容是 <code>public</code> 文件夹下的所有内容。事实上 <code>hexo-deploy-git</code> 插件是通过拷贝 <code>public</code> 文件夹内容到 <code>.deploy_git</code> 文件夹下，然后提交推送到远程分支上实现了网站文件的部署。<br>那我们的备份思路也可以这样，上传目录下的其他所有文件就可以了，同时我们不能修改博客的发布分支，因此考虑备份其他所有文件到新分支中。<br>最简单直接的方法就是在仓库创建一个新的分支，把本地所有的内容都上传到该分支上。但这样会备份一部分不必要的文件，例如 <code>public</code> 文件夹内容，它可以再次生成，就没有必要备份。<br>那具体要备份哪些文件呢？</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="备份的文件列表"><a href="#备份的文件列表" class="headerlink" title="备份的文件列表"></a>备份的文件列表</h3><p>我们先看下，现在博客文件夹都有什么内容：</p><pre><code>.├──_config.yml├── db.json├── node_modules├── package.json├── package-lock.json├── public├── scaffolds├── source└── themes     ├── next     └── landscape</code></pre><p>这几个文件或文件夹的内容分别是：</p><ol><li><code>_config.yml</code> 文件：站点配置文件，很多功能、插件需要修改该配置文件应用生效。</li><li><code>node_modules</code> 文件夹：包含依赖的模块。</li><li><code>package.json</code> 文件：依赖的模块列表。说明见：<a href="https://www.npmjs.cn/files/package.json/" target="_blank" rel="noopener">package.json:Specifics of npm’s package.json handling</a></li><li><code>package-lock.json</code> 文件：依赖的模块安装记录。说明见：<a href="https://www.npmjs.cn/files/package-locks/" target="_blank" rel="noopener">npm-package-locks:An explanation of npm lockfiles</a></li><li><code>public</code> 文件夹：包含生成的网页静态文件。</li><li><code>scaffolds</code> 文件夹：包含创建的文章、分类、标签界面的模板。博客的定制修改会对模板进行修改。</li><li><code>source</code> 文件夹：包含生成网页所需要的源文件，包括包含我们心血的 Markdown 文稿，这也是最重要的内容。</li><li><code>themes</code> 文件夹：其中 <code>landscape</code> 是默认的主题，其他文件夹是克隆下来时的主题。<br>我们可以参考 Hexo 初始化使用的仓库的备份列表，它的仓库是 <a href="https://github.com/hexojs/hexo-starter" target="_blank" rel="noopener">hexojs/hexo-starter</a>。我们看下它备份了哪些内容：</li></ol><pre><code>scaffoldssourcethemes.gitignore.gitmodules_config.ymlpackage.json</code></pre><p>比对一下，它抛弃了：</p><ol><li><code>node_modules</code> &amp; <code>package-lock.json</code>：这两部分内容，只要保留 <code>package.json</code>，执行 <code>npm install</code> 就可以下载、生成。</li><li><code>public</code>：执行 <code>hexo g</code> 即可根据源文件生成网页内容。<br>这些可重新生成的文件都可以不上传，因为它们只要使用特定的命令操作即可恢复。<br>它增加了 <code>.gitmodules</code>，那它的作用又是什么呢？其实 <code>hexojs/hexo-starter</code> 是通过 Git 的 Submodule 功能来下载主题模块，本身仓库并不备份主题文件。考虑下我们需要如何备份主题文件目录，有两个方案：</li><li>一个方案是将其内容全部上传进行备份，这样可以保证原主题的更新不会影响你原先配置的效果。</li><li>另一个方案是像 <code>hexo-starter</code> 仓库一样通过 Git 的 Submodule 功能来管理，这样可以进行主题的更新。<br>这里我选择和 Hexo 初始化仓库一样使用 Git 子模块的方式进行主题的备份处理。不过通过子模块管理的方式我们恢复时仅会同步到 Next 主题的原文件，没法直接同步我们对主题配置文件或其他文件的修改，因为我们没有权限提交修改到 Next 仓库中。因此我创建了了个 <code>themes_custom</code> 文件夹来存放对应主题的修改的备份，这样子我们同步之后，只需要对比一下内容手动把这些配置应用过去就可以快速完成对主题的配置。<br>最终备份文件列表如下：</li></ol><pre><code>scaffoldssourcethemesthemes_custom/next.gitignore.gitmodules_config.ymlpackage.json</code></pre><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>有了方案之后，我们备份的具体操作如下：</p><ol><li>先修改 <code>.gitignore</code> 文件，查看之后由于原文件已经忽略了 <code>public</code> 和 <code>node_modules</code> 文件夹，因此仅需要添加 <code>package-lock.json</code> 到忽略清单中。</li><li>我们可以删除不使用的主题 <code>landscape</code> 或者把主题路径添加到忽略列表中。</li><li>创建 <code>themes_custom/next</code> 文件夹，将对主题进行的配件修改的文件拷贝一份到这里</li><li>执行以下命令，在本地创建备份仓库：</li></ol><pre><code class="bash">$ cd blog$ git init#已初始化空的 Git 仓库于 blog/.git/$ git submodule add https://github.com/theme-next/hexo-theme-next.git themes/next#添加位于 &#39;themes/next&#39; 的现存仓库到索引$ git add .$ git commit -m &quot;init blog backup&quot;</code></pre><ol><li>将备份内容 push 到远程仓库的备份分支 <code>hexo</code> 上：</li></ol><pre><code class="bash">$ git branch -m master hexo$ git remote add origin https://github.com/Mupceet/mupceet.github.io.git$ git push -u origin hexo:hexo</code></pre><p> 这里，我对分支进行了重命名以减少记忆负担<br>经过以上步骤，我们就备份了所有必要的文件。后续更新博客也要及时地将这些文件进行提交并上传完成备份。</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>有了备份之后，在另一台电脑上创建博客，或者是恢复备份时，就可以直接使用我们备份的内容进行操作。</p><ol><li>环境准备<br>具体见 <a href="https://mupceet.com/2019/08/build-blog-based-on-hexo/" target="_blank" rel="noopener">Hexo 博客搭建与主题配置（零基础版）</a>一文。</li><li>克隆备份的内容</li></ol><pre><code class="bash">$ git clone --recursive -b hexo https://github.com/Mupceet/mupceet.github.io.git blog</code></pre><ol><li>下载 npm 依赖模块</li></ol><pre><code class="bash">$ cd blog$ npm install</code></pre><ol><li>恢复主题配置<br>将 <code>themes_custom</code> 文件夹中对主题的配置的修改恢复到对应的主题文件夹中，这里建议使用对比的方式对其进行修改，而不是直接覆盖，这样就完成了主题的配置。</li><li>克隆原博客内容</li></ol><pre><code class="bash">$ cd blog$ git clone https://github.com/Mupceet/mupceet.github.io.git .deploy\_git</code></pre><ol><li>正常更新博客</li></ol><pre><code class="bash">$ hexo g$ hexo s$ hexo d</code></pre><p>可以看到，使用备份文件恢复博客的环境是非常简单的，强烈建议大家搭建好博客之后增加一个备份操作。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 定时计划任务设置</title>
      <link href="/2021/11/07/CentOS7-%E5%AE%9A%E6%97%B6%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE/"/>
      <url>/2021/11/07/CentOS7-%E5%AE%9A%E6%97%B6%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>就像再windows上有计划任务一样，centos7 自然也有计划任务，而且设置更为灵活，好用。再centos7 上可以利用crontab 来执行计划任务，<br>依赖与 crond 的系统服务，这个服务是系统自带的，可以直接查看状态，启动，停止。  </p><h2 id="安装-crontabs服务并设置开机自启"><a href="#安装-crontabs服务并设置开机自启" class="headerlink" title="安装 crontabs服务并设置开机自启"></a>安装 crontabs服务并设置开机自启</h2><pre><code class="bash">yum install crontabs  systemctl enable crond （设为开机启动）  systemctl start crond（启动crond服务）  systemctl status crond （查看状态） </code></pre><h2 id="设置用户自定义定时任务"><a href="#设置用户自定义定时任务" class="headerlink" title="设置用户自定义定时任务"></a>设置用户自定义定时任务</h2><pre><code class="bash">vi /etc/crontab</code></pre><p>可以看到： </p><pre><code class="bash">Example of job definition:  .---------------- minute (0 - 59)  | .------------- hour (0 - 23)  | | .---------- day of month (1 - 31)  | | | .------- month (1 - 12) OR jan,feb,mar,apr ...  | | | | .---- day of week (0 - 6) (Sunday=0 or 7) ORsun,mon,tue,wed,thu,fri,sat  | | | | |  * * * * * user-name command to be executed  即：  分钟(0-59) 小时(0-23) 日(1-31) 月(11-12) 星期(0-6,0表示周日) 用户名 要执行的命令  * */30 * * * root /usr/local/mycommand.sh (每天，每30分钟执行一次 mycommand命令)  * * 3 * * * root /usr/local/mycommand.sh (每天凌晨三点，执行命令脚本，PS:这里由于第一个的分钟没有设置，那么就会每天凌晨3点的每分钟都执行一次命令)  * 0 3 * * * root /usr/local/mycommand.sh (这样就是每天凌晨三点整执行一次命令脚本)  * */10 11-13 * * * root /usr/local/mycommand.sh (每天11点到13点之间，每10分钟执行一次命令脚本，这一种用法也很常用)  * 10-30 * * * * root /usr/local/mycommand.sh (每小时的10-30分钟，每分钟执行一次命令脚本，共执行20次)  * 10,30 * * * * * root /usr/local/mycommand.sh (每小时的10,30分钟，分别执行一次命令脚本，共执行2次）</code></pre><h3 id="保存生效"><a href="#保存生效" class="headerlink" title="保存生效"></a>保存生效</h3><p>加载任务,使之生效：<code>crontab /etc/crontab</code></p><p>查看任务：<code>crontab -l</code><br>$ crontab -u 用户名 -l （列出用户的定时任务列表）</p><p>PS：特别注意，crond的任务计划，<br>有并不会调用用户设置的环境变量，它有自己的环境变量，当你用到一些命令时，比如mysqldump等需要环境变量的命令，手工执行脚本时是正常的，但用crond执行的时候就会不行，这时你要么写完整的绝对路径，要么将环境变量添加到<br>/etc/crontab 中。</p><p>好了，计划任务就是这么简单了，但是计划任务，执行的语句如果是多条，则需要用药shell脚本，自己先写一个shell脚本，然后在计划任务中，执行这个脚本即可。至于shell脚本的写法，<br>这里不赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS7 </tag>
            
            <tag> 定时任务 </tag>
            
            <tag> Crontabs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS使用yum安装ffmpeg工具</title>
      <link href="/2021/11/07/CentOS%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85ffmpeg%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/11/07/CentOS%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85ffmpeg%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><h3 id="安装ffmpeg"><a href="#安装ffmpeg" class="headerlink" title="安装ffmpeg"></a>安装ffmpeg</h3><pre><code class="bash">yum -y install ffmpeg</code></pre><h3 id="安装yasm"><a href="#安装yasm" class="headerlink" title="安装yasm"></a>安装yasm</h3><pre><code class="bash">yum install -y yasm</code></pre><h3 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h3><pre><code class="bash">ffmpeg -version</code></pre><p><img src="https://img-blog.csdnimg.cn/20200601162219387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b19xaWFuZ3FpYW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><h3 id="升级系统epel-release软件包"><a href="#升级系统epel-release软件包" class="headerlink" title="升级系统epel-release软件包"></a>升级系统epel-release软件包</h3><pre><code class="bash">yum install epel-release -y //安装第三方软件包yum update -y //更新系统软件包shutdown -r now  //也可以不重启  </code></pre><p><strong>EPEL源-是什么?为什么安装？</strong></p><p>EPEL (Extra Packages for Enterprise<br>Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.</p><h3 id="安装Nux-Dextop-Yum-源"><a href="#安装Nux-Dextop-Yum-源" class="headerlink" title="安装Nux Dextop Yum 源"></a>安装Nux Dextop Yum 源</h3><p>由于CentOS没有官方FFmpeg rpm软件包。但是，我们可以使用第三方YUM源（Nux Dextop）完成此工作。</p><h4 id="1-CentOS-7"><a href="#1-CentOS-7" class="headerlink" title="1) CentOS 7"></a>1) CentOS 7</h4><pre><code class="bash">rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rorpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm  </code></pre><h4 id="2-CentOS-6"><a href="#2-CentOS-6" class="headerlink" title="2) CentOS 6"></a>2) CentOS 6</h4><pre><code class="bash">rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rorpm -Uvh http://li.nux.ro/download/nux/dextop/el6/x86_64/nux-dextop-release-0-2.el6.nux.noarch.rpm    </code></pre><h3 id="安装FFmpeg-和-FFmpeg开发包"><a href="#安装FFmpeg-和-FFmpeg开发包" class="headerlink" title="安装FFmpeg 和 FFmpeg开发包"></a>安装FFmpeg 和 FFmpeg开发包</h3><pre><code class="bash">yum install ffmpeg ffmpeg-devel -y</code></pre><h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><pre><code class="bash">ffmpeg 或 ffmpeg -version</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200601172835203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b19xaWFuZ3FpYW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><h3 id="如果你想了解更多关于FFmpeg使用方面的资料"><a href="#如果你想了解更多关于FFmpeg使用方面的资料" class="headerlink" title="如果你想了解更多关于FFmpeg使用方面的资料"></a>如果你想了解更多关于FFmpeg使用方面的资料</h3><pre><code class="bash">ffmpeg -h </code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200601172909584.png?size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 软件 </tag>
            
            <tag> Yum </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA导入/导出Live templates或者其他设置</title>
      <link href="/2021/11/07/IDEA%E5%AF%BC%E5%85%A5-%E5%AF%BC%E5%87%BALive%20templates%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AE/"/>
      <url>/2021/11/07/IDEA%E5%AF%BC%E5%85%A5-%E5%AF%BC%E5%87%BALive%20templates%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA导入-导出live-templates或者其他设置"><a href="#IDEA导入-导出live-templates或者其他设置" class="headerlink" title="IDEA导入/导出live templates或者其他设置"></a>IDEA导入/导出live templates或者其他设置</h1><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><ol><li><p>在菜单栏选择 <code>File</code> | <code>Manage IDE Settings</code> | <code>Export Settings</code></p></li><li><p>在打开的导出弹窗中，选择需要导出的项目，如果我们只需要导出 <strong>Live templates</strong> ，那就只选择 <strong>Live templates</strong> 即可，然后选择一个需要导出的位置并设置一个存储的文件名（默认是settings.zip）</p></li><li><p>点击 <strong>OK</strong> 进行导出，导出的文件可以导入到其他IDEA中进行使用</p></li></ol><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ol><li><p>在菜单栏选择 <code>File</code> | <code>Manage IDE Settings</code> | <code>Import Settings</code></p></li><li><p>选择之前导出的配置文件，点击 <strong>OK</strong></p></li><li><p>在弹出的窗口中选择需要导入的项目，例如 <strong>Live templates</strong> 然后点击 <strong>OK</strong></p></li><li><p>重启IDEA使新配置生效</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>[Share live templates](<a href="https://www.jetbrains.com/help/idea/sharing-live-" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/sharing-live-</a><br>templates.html#export)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Tools </tag>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 yum安装python3.6</title>
      <link href="/2021/11/03/CentOS7-yum%E5%AE%89%E8%A3%85python3-6/"/>
      <url>/2021/11/03/CentOS7-yum%E5%AE%89%E8%A3%85python3-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CentOS7 使用yum 安装Python3 </p></blockquote><h3 id="1-配epel源-阿里"><a href="#1-配epel源-阿里" class="headerlink" title="1.配epel源_阿里"></a>1.配epel源_阿里</h3><pre><code class="bash">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</code></pre><h3 id="2-安装python3-6"><a href="#2-安装python3-6" class="headerlink" title="2.安装python3.6"></a>2.安装python3.6</h3><pre><code class="bash">yum install python36 -y</code></pre><h3 id="3-安装pip3"><a href="#3-安装pip3" class="headerlink" title="3.安装pip3"></a>3.安装pip3</h3><pre><code class="bash"># 搜索pip3的安装包名称yum  whatprovides pip3# 安装pip3yum install python36-pip -y</code></pre><p>依赖：python36-setuptools</p><h3 id="4-验证"><a href="#4-验证" class="headerlink" title="4.验证"></a>4.验证</h3><pre><code class="bash">python3 --version</code></pre><h3 id="5-查看指向"><a href="#5-查看指向" class="headerlink" title="5.查看指向"></a>5.查看指向</h3><pre><code class="bash">ll /usr/bin/pythonll /usr/bin/python3</code></pre><p>由上可知<br>python 代表CentOS7系统默认的 python2.7；<br>python3 代表新安装的 python3.6</p><h3 id="6-安装python开发工具"><a href="#6-安装python开发工具" class="headerlink" title="6.安装python开发工具"></a>6.安装python开发工具</h3><pre><code class="bash">yum install python36-devel -y</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://blog.51cto.com/moerjinrong/2396290" target="_blank" rel="noopener">CentOS7 yum安装python3.6</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 安装Chrome无GUI运行selenium chromedriver</title>
      <link href="/2021/11/03/Centos7-%E5%AE%89%E8%A3%85Chrome%E6%97%A0GUI%E8%BF%90%E8%A1%8Cselenium-chromedriver/"/>
      <url>/2021/11/03/Centos7-%E5%AE%89%E8%A3%85Chrome%E6%97%A0GUI%E8%BF%90%E8%A1%8Cselenium-chromedriver/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装chrome"><a href="#1-安装chrome" class="headerlink" title="1. 安装chrome"></a>1. 安装chrome</h3><p>首先安装google的epel源</p><pre><code class="bash">vi /etc/yum.repos.d/google.repo</code></pre><pre><code>[google]name=Google-x86_64baseurl=http://dl.google.com/linux/rpm/stable/x86_64enabled=1gpgcheck=0gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub </code></pre><pre><code class="bash">yum update &amp;&amp; yum install google-chrome-stable</code></pre><h3 id="2-chromedriver下载"><a href="#2-chromedriver下载" class="headerlink" title="2.chromedriver下载"></a>2.chromedriver下载</h3><p><a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromedriver/</a></p><p>找到chrome对应的chromedriver 版本，并下载</p><pre><code class="bash">wget https://chromedriver.storage.googleapis.com/74.0.3729.6/chromedriver_linux64.zip</code></pre><p>将下载的chromedriver 放到脚本同级目录调用</p><h3 id="3-为chromedriver授权"><a href="#3-为chromedriver授权" class="headerlink" title="3. 为chromedriver授权"></a>3. 为chromedriver授权</h3><pre><code class="bash">chmod 755 chromedriver</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument(&quot;--headless&quot;)chrome_options.add_argument(&#39;--disable-gpu&#39;)chrome_options.add_argument(&#39;--no-sandbox&#39;)    # 禁止沙箱模式，否则肯能会报错遇到chrome异常url=&quot;https://www.west.cn/login.asp&quot;brower=webdriver.Chrome(executable_path=&quot;./chromedriver&quot;, chrome_options=chrome_options)brower.get(url)print(brower.current_url)brower.get(&quot;https://www.west.cn/Manager/&quot;)print(brower.current_url)brower.quit()</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.cnblogs.com/huchong/p/10796823.html" target="_blank" rel="noopener">centos7无GUI运行selenium chromedriver 亲测可用！</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
            <tag> Chrome </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
