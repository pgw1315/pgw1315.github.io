<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>点动控制电路接线图和电机自锁控制启动柜原理</title>
      <link href="/2023/10/11/%E7%82%B9%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%94%B5%E8%B7%AF%E6%8E%A5%E7%BA%BF%E5%9B%BE%E5%92%8C%E7%94%B5%E6%9C%BA%E8%87%AA%E9%94%81%E6%8E%A7%E5%88%B6%E5%90%AF%E5%8A%A8%E6%9F%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2023/10/11/%E7%82%B9%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%94%B5%E8%B7%AF%E6%8E%A5%E7%BA%BF%E5%9B%BE%E5%92%8C%E7%94%B5%E6%9C%BA%E8%87%AA%E9%94%81%E6%8E%A7%E5%88%B6%E5%90%AF%E5%8A%A8%E6%9F%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>小编讲解一下常见的点动电路和自锁电路。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/点动控制电路接线图和电机自锁控制启动柜原理/v2-976151d9e63784c5cb45792ac366fb39_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/点动控制电路接线图和电机自锁控制启动柜原理/v2-b72d790479f60144bb0b24ebf66d9ca8_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一、点动控制电路<br>如下图所示的是一种按钮控制点动电路，当按下按钮时，电动机旋转，松开按钮后电动机停止转动。电路由刀开关Q、熔断器FU1、接触器KM的主触点与电动机M构成主回路。由熔断器FU2、启动按钮SB常开触点、接触器KM线圈构成控制回路。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/点动控制电路接线图和电机自锁控制启动柜原理/v2-0f647de1c0f3689ce61ee89aa13b8310_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当合上电源开关Q时，因为接触器主触点没有闭合，电动机不转。<br>按下启动按钮SB，接触器KM线圈通电吸合，KM主触点此时闭合接通电动机三相电源，电动机旋转。<br>当收松开按钮后，KM线圈断电释放吸合的触点，触器主触点KM断开三相电源，电动机停止转动。<br>本电路常适用于需要经常启动和停止或快速启动运行的生产机械上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/点动控制电路接线图和电机自锁控制启动柜原理/v2-832f9d80b53faa7dd52f9109c8623ccc_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/点动控制电路接线图和电机自锁控制启动柜原理/v2-65cf1bc7e8317c778358dde56d159bfb_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>二、自锁控制电路<br>松开按钮后自锁的意思就是通过按钮启动电动机，松开按钮后电动机主回路被锁定在通电状态，还能继续转动，通常自锁利用接触器自身的辅助触点来保持线圈通电吸合状态。此类电路常用在需要持续单向运转的生产机械上。<br>如下图所示便是一款按钮松开后，电动机仍然能够保持单向旋转的控制电路。由刀开关Q、熔断器FU1、接触器KM的主触点与电动机M构成主回路。由熔断器FU2、停止按钮SB1常闭触点、启动按钮SB2常开触点、接触器KM的常开辅助触点、KM线圈构成控制回路。FU1、FU2起短路保护作用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/点动控制电路接线图和电机自锁控制启动柜原理/v2-9d0b61d74476b59a018122050821abfe_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>合上电源开关Q，按下启动按钮SB2，接触器KM线圈通电并吸合，主回路接通电能，电动机启动旋转。<br>由于按下SB2时，不但KM主触点闭合接通了主电路，而且并联的SB2两端的KM辅助触点也同时闭合，接通了电动机的控制电路。所以，即便松开按钮SB2，控制电路仍然保持接通，电动机仍然能正常旋转。在这里，KM的常开辅助触点起着“自锁”的作用。<br>如果需要电动机停止转动，按下停止按钮SB1，切断控制电路，KM线圈因断电而释放，KM主触点也断开，电动机停止转动；同时KM辅助触点也断开，即使按钮SB1松开，控制电路也不会再次接通。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/点动控制电路接线图和电机自锁控制启动柜原理/v2-23bb9f8dd3833948609264e5f5b7d040_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/点动控制电路接线图和电机自锁控制启动柜原理/v2-84dde1376465b50b79a0ea7c725fc3f0_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/607692114" target="_blank" rel="noopener">点动控制电路接线图和电机自锁控制启动柜原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.gitignore文件的配置使用</title>
      <link href="/2022/06/26/gitignore%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/26/gitignore%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在使用Git的过程中，有的文件比如日志，临时文件，编译的中间文件等不要提交到代码仓库，这时就要设置相应的忽略规则，来忽略这些文件的提交。简单来说一个场景：在你使用git add .的时候，遇到了把你不想提交的文件也添加到了缓存中去的情况，比如项目的本地配置信息，如果你上传到Git中去其他人pull下来的时候就会和他本地的配置有冲突，所以这样的个性化配置文件我们一般不把它推送到git服务器中，但是又为了偷懒每次添加缓存的时候都想用git add .而不是手动一个一个文件添加，该怎么办呢？很简单，git为我们提供了一个.gitignore文件，只要在这个文件中声明哪些文件你不希望添加到git中去，这样当你使用git add .的时候这些文件就会被自动忽略掉。</p><h3 id="Git忽略文件的原则"><a href="#Git忽略文件的原则" class="headerlink" title="Git忽略文件的原则"></a>Git忽略文件的原则</h3><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如产生的.log日志文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul><h3 id="gitignore文件的使用方法"><a href="#gitignore文件的使用方法" class="headerlink" title=".gitignore文件的使用方法"></a>.gitignore文件的使用方法</h3><p>首先，在你的工作区新建一个名称为.gitignore的文件。 然后，把要忽略的文件名填进去，Git就会自动忽略这些文件。不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a>。</p><pre><code class="bash"># dir 不需要提交的目录/node_modules​# file 不需要提交的文件config.ini​# log 不需要提交的任意包含后缀名为log的文件*.log​# Package Files 不需要提交的任意包含后缀名为jar的文件*.jar</code></pre><p>.gitignore注释用’#’, *表示匹配0个或多个任意字符，所以上面的模式就是要忽略所有的xml文件,log文件和apk文件。<br>.gitignore配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为版本管理带来很大的便利。<br>如果有些文件已经被忽略了，当使用<code>git add</code>时是无法添加的。需要加上<code>-f</code>参数才能强制添加到git中去，这样就能强制添加到缓存中去了。</p><pre><code class="bash">git add -f node_modules/jquery/dist/jquery.min.js</code></pre><p>如果我们意外的将想要忽略的文件添加到缓存中去了，我们可以使用<code>rm</code>命令将其从中移除：</p><pre><code class="bash">git rm --cached test.js </code></pre><h3 id="gitignore忽略规则的优先级"><a href="#gitignore忽略规则的优先级" class="headerlink" title=".gitignore忽略规则的优先级"></a>.gitignore忽略规则的优先级</h3><pre><code class="bash">在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：1、从命令行中读取可用的忽略规则2、当前目录定义的规则3、父级目录定义的规则，依次递推4、$GIT_DIR/info/exclude 文件中定义的规则5、core.excludesfile中定义的全局规则</code></pre><h3 id="gitignore忽略规则的匹配语法"><a href="#gitignore忽略规则的匹配语法" class="headerlink" title=".gitignore忽略规则的匹配语法"></a>.gitignore忽略规则的匹配语法</h3><pre><code class="bash">在 .gitignore 文件中，每一行的忽略规则的语法如下：1、空格不匹配任意文件，可作为分隔符，可用反斜杠转义2、以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。3、可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。4、以斜杠&quot;/&quot;开头表示目录；&quot;/&quot;结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；&quot;/&quot;开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。5、以星号&quot;*&quot;通配多个字符，即匹配多个任意字符；使用两个星号&quot;**&quot; 表示匹配任意中间目录，比如a/**/z可以匹配 a/z, a/b/z 或 a/b/c/z等。6、以问号&quot;?&quot;通配单个字符，即匹配一个任意字符；7、以方括号&quot;[]&quot;包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。8、以叹号&quot;!&quot;表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用&quot;!&quot;规则是不起作用的。也就是说&quot;!&quot;开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用&quot;!&quot;也不会再次被包含。可以使用反斜杠进行转义。</code></pre><h3 id="需要谨记："><a href="#需要谨记：" class="headerlink" title="需要谨记："></a>需要谨记：</h3><p>git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p><h3 id="十分重要："><a href="#十分重要：" class="headerlink" title="十分重要："></a>十分重要：</h3><p>如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。简单来说出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。所以大家一定要养成在项目开始就创建.gitignore文件的习惯，否则一单push，处理起来会非常麻烦。</p><pre><code class="bash">#               表示此为注释,将被Git忽略*.a             表示忽略所有 .a 结尾的文件!lib.a          表示但lib.a除外/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin:           表示忽略根目录下的bin文件/*.c:           表示忽略cat.c，不忽略 build/cat.cdebug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo:         表示忽略/foo,a/foo,a/b/foo等a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh    表示不忽略bin目录下的run.sh文件*.log:          表示忽略所有 .log 文件config.php:     表示忽略当前路径的 config.php 文件 /mtk/           表示过滤整个文件夹*.zip           表示过滤所有.zip文件/mtk/do.c       表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容； /*!.gitignore!/fw/ /fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。</code></pre><p>如果你已经把不想上传的文件上传到了git仓库，那么你必须先从远程仓库删了它，我们可以从远程仓库直接删除然后pull代码到本地仓库这些文件就会本删除，或者从本地删除这些文件并且在.gitignore文件中添加这些你想忽略的文件，然后再push到远程仓库。</p><h3 id="gitignor忽略规则查看"><a href="#gitignor忽略规则查看" class="headerlink" title="gitignor忽略规则查看"></a>gitignor忽略规则查看</h3><p>如果你发下.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：</p><pre><code class="bash">git check-ignore -v xxx.js</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/52885189" target="_blank" rel="noopener">[Git].gitignore文件的配置使用</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python需求文件requirements.txt的创建及使用</title>
      <link href="/2022/06/26/python%E7%AC%94%E8%AE%B0---%E9%9C%80%E6%B1%82%E6%96%87%E4%BB%B6requirements.txt%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/26/python%E7%AC%94%E8%AE%B0---%E9%9C%80%E6%B1%82%E6%96%87%E4%BB%B6requirements.txt%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>python项目中必须包含一个 requirements.txt 文件，用于记录所有依赖包及其精确的版本号。以便新环境部署。</p><h2 id="在虚拟环境中使用pip生成："><a href="#在虚拟环境中使用pip生成：" class="headerlink" title="在虚拟环境中使用pip生成："></a>在虚拟环境中使用pip生成：</h2><pre><code class="bash">pip freeze &gt;requirements.txt</code></pre><p>安装或升级包后，最好更新这个文件。</p><p>需求文件的内容示例如下：</p><pre><code class="python">alembic==0.8.6bleach==1.4.3click==6.6dominate==2.2.1Flask==0.11.1Flask-Bootstrap==3.3.6.0Flask-Login==0.3.2Flask-Migrate==1.8.1Flask-Moment==0.5.1Flask-PageDown==0.2.1Flask-Script==2.0.5Flask-SQLAlchemy==2.1Flask-WTF==0.12html5lib==0.9999999itsdangerous==0.24Jinja2==2.8Mako==1.0.4Markdown==2.6.6MarkupSafe==0.23PyMySQL==0.7.5python-editor==1.0.1six==1.10.0SQLAlchemy==1.0.14visitor==0.1.3Werkzeug==0.11.10WTForms==2.1</code></pre><p>当需要创建这个虚拟环境的完全副本，可以创建一个新的虚拟环境，并在其上运行以下命令：</p><pre><code class="bash">pip install -r requirements.txt</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/loyachen/article/details/52028825" target="_blank" rel="noopener">python笔记—需求文件requirements.txt的创建及使用</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>油猴脚本编写教程</title>
      <link href="/2022/06/24/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B-SegmentFault%E6%80%9D%E5%90%A6/"/>
      <url>/2022/06/24/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B-SegmentFault%E6%80%9D%E5%90%A6/</url>
      
        <content type="html"><![CDATA[<p>油猴脚本（Tampermonkey）是一个非常流行的浏览器扩展，它可以运行由广大社区编写的扩展脚本，来实现各式各样的功能，常见的去广告、修改样式文件、甚至是下载视频。今天我们就来看看如何编写自己的油猴脚本。当然为了运行油猴脚本，你应该在浏览器中安装油猴插件。</p><h3 id="安装油猴插件"><a href="#安装油猴插件" class="headerlink" title="安装油猴插件"></a>安装油猴插件</h3><p>安装油猴插件非常简单，直接在浏览器的扩展商店中安装即可。国产浏览器的话一般可以通过下载扩展文件手动拖动的方式来安装。下图是微软新版Edge浏览器的扩展商店，直接搜索Tampermonkey即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/3843056900-8983f8db535e19d8_fix732.png" alt="新版Edge扩展商店" title="">                </div>                <div class="image-caption">新版Edge扩展商店</div>            </figure><h3 id="新建脚本"><a href="#新建脚本" class="headerlink" title="新建脚本"></a>新建脚本</h3><p>首先在浏览器右上角找到并点击油猴插件，选择添加新脚本。</p><ul><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/3094194886-b721a19ba853294b_fix732.png" alt="添加新脚本" title="">                </div>                <div class="image-caption">添加新脚本</div>            </figure></li></ul><p>然后就会打开如图所示的编辑器窗口，我们就可以在其中编辑自己的脚本文件了。如果你喜欢的话，还可以将脚本内容复制到合适的编辑器中编辑，完成之后再复制回来。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/4224078242-f7656f879d3066fa_fix732.png" alt="编辑脚本文件" title="">                </div>                <div class="image-caption">编辑脚本文件</div>            </figure><p>如果你点击开发者菜单的话，可以选择ES6模板，然后就可以在脚本中使用新版JavaScript的特性了，它会有Babel转译回ES5。不过这个模板貌似有点问题，用了它就没办法使用代码纠错功能了。所以这里我还是选择了默认的ES5模板。</p><h3 id="脚本编写方法"><a href="#脚本编写方法" class="headerlink" title="脚本编写方法"></a>脚本编写方法</h3><h4 id="功能注释"><a href="#功能注释" class="headerlink" title="功能注释"></a>功能注释</h4><p>首先来看看脚本的内容，上面是一大排注释，这些注释可以非常有用的，它表明了脚本的各个属性。下面来简单介绍一下。</p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>油猴脚本的名字</td></tr><tr><td>namespace</td><td>命名空间，类似于Java的包名，用来区分相同名称的脚本，一般写成作者名字或者网址就可以了</td></tr><tr><td>version</td><td>脚本版本，油猴脚本的更新会读取这个版本号</td></tr><tr><td>description</td><td>描述，用来告诉用户这个脚本是干什么用的</td></tr><tr><td>author</td><td>作者名字</td></tr><tr><td>match</td><td>只有匹配的网址才会执行对应的脚本，例如<code>*</code>、<code>http://*</code>、<code>http://www.baidu.com/*</code>等，参见<a href="https://developer.chrome.com/docs/extensions/mv3/match_patterns/" target="_blank" rel="noopener">谷歌开发者文档</a></td></tr><tr><td></td><td></td></tr><tr><td>grant</td><td>指定脚本运行所需权限，如果脚本拥有相应的权限，就可以调用油猴扩展提供的API与浏览器进行交互。如果设置为<code>none</code>的话，则不使用沙箱环境，脚本会直接运行在网页的环境中，这时候无法使用大部分油猴扩展的API。如果不指定的话，油猴会默认添加几个最常用的API</td></tr><tr><td>require</td><td>如果脚本依赖其他js库的话，可以使用require指令，在运行脚本之前先加载其他库，常见用法是加载jquery</td></tr><tr><td>connect</td><td>当用户使用<a href="https://www.tampermonkey.net/documentation.php?version=4.9&ext=dhdg&show=dhdg#GM_xmlhttpRequest" target="_blank" rel="noopener">GM_xmlhttpRequest</a>请求远程数据的时候，需要使用connect指定允许访问的域名，支持域名、子域名、IP地址以及<code>*</code>通配符</td></tr><tr><td>updateURL</td><td>脚本更新网址，当油猴扩展检查更新的时候，会尝试从这个网址下载脚本，然后比对版本号确认是否更新</td></tr></tbody></table><h4 id="脚本权限"><a href="#脚本权限" class="headerlink" title="脚本权限"></a>脚本权限</h4><p>下面简单介绍一下grant指令那里可以填写的一些权限，详情请查看<a href="https://www.tampermonkey.net/documentation.php" target="_blank" rel="noopener">油猴脚本文档</a>。这里就简单介绍几个常用的，可以调用的函数全部以GM_作为开头。</p><table><thead><tr><th>权限名</th><th>功能</th></tr></thead><tbody><tr><td>unsafeWindow</td><td>允许脚本可以完整访问原始页面，包括原始页面的脚本和变量。</td></tr><tr><td>GM_getValue(name,defaultValue)</td><td>从油猴扩展的存储中访问数据。可以设置默认值，在没成功获取到数据的时候当做初始值。如果保存的是日期等类型的话，取出来的数据会变成文本，需要自己转换一下。</td></tr><tr><td>GM_setValue(name,value)</td><td>将数据保存到存储中</td></tr><tr><td>GM_xmlhttpRequest(details)</td><td>异步访问网页数据的API，这个方法比较复杂，有大量参数和回调，详情请参考官方文档。</td></tr><tr><td>GM_setClipboard(data, info)</td><td>将数据复制到剪贴板中，第一个参数是要复制的数据，第二个参数是MIME类型，用于指定复制的数据类型。</td></tr><tr><td>GM_log(message)</td><td>将日志打印到控制台中，可以使用F12开发者工具查看。</td></tr><tr><td>GM_addStyle(css)</td><td>像网页中添加自己的样式表。</td></tr><tr><td>GM_notification(details, ondone), GM_notification(text, title, image, onclick)</td><td>设置网页通知，请参考文档获取用法。</td></tr><tr><td>GM_openInTab(url, loadInBackground)</td><td>在浏览器中打开网页，可以设置是否在后台打开等几个选项</td></tr></tbody></table><p>还有一些API没有介绍，请大家直接查看官方文档吧。</p><h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>编写脚本就很简单了，编写到<code>// Your code here ..</code>那里即可。可以编写函数，然后在最后调用这几个函数，这样的模块化编写方法写出来的脚本比较容易维护。</p><h4 id="等vagrant更新时候提醒我的脚本"><a href="#等vagrant更新时候提醒我的脚本" class="headerlink" title="等vagrant更新时候提醒我的脚本"></a>等vagrant更新时候提醒我的脚本</h4><p>前段时间了解了vagrant这个东西，感觉很有意思，准备研究一下，但是照着官网教程运行的时候，第一步就发生了错误。我上网一搜，原来我更新的virtualbox比较新，vagrant恰好不支持。但是如今几个月过去了，vagrant还是没有更新，所以我要写一个脚本，等到vagrant更新的时候，给我网页上弹出一个对话框。</p><p>首先访问<a href="https://www.vagrantup.com/" target="_blank" rel="noopener">vagrant官网</a>，然后就可以看到中间下载按钮上大大的版本号2.2.6了。因为版本肯定是不会倒退的，所以只要判断一下版本号不是2.2.6，就可以弹出提示了。通过F12开发者工具可以看到，这三个按钮其实都是链接，只不过显示成了按钮的样子，而且他们恰好都位于<code>header</code>标签之中。如果如果可以的话，直接用选择器就可以非常轻松的获取到版本号。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/3073214562-a785d8e2c4712cef_fix732.png" alt="vagrant官网" title="">                </div>                <div class="image-caption">vagrant官网</div>            </figure><p>为了能在更新的时候及时获取到提示，我需要脚本在所有网站上生效，来检测版本。但是这样做会导致另外一个问题，那就是每次打开一个网页都会运行一次检查vagrant的脚本，而这是完全不必要的。所以需要一个额外的判断，这就需要利用油猴提供的API来保存当前日期，只有每天第一次的时候才会执行检查代码。本来我想的很复杂，需要一个日期变量，然后还要额外一个变量保存是否是今天第一次更新。后来我发现我想的太多了，做法其实很简单。每天先获取一次日期，然后和事先保存的日期比较，如果不一样的话才执行脚本，并将日期设置为今天的日期；如果日期一样的话无事发生。</p><p>最后一个问题就是如何来判断版本号，有两种方法：第一种就是上面提到的，直接解析HTML代码并找到版本号；第二种是更直接的办法， 因为vagrant也是Github上开源的项目，所以可以直接调用Github的API来获取最新发布的版本号。可惜的是，第二种办法我试了一下居然不成功，不知为何，没办法获取到发布信息，但是换成其他项目就可以。所以最后没办法只好采用第一种办法。有兴趣的同学可以自己试一下第二种方法。</p><p>好了，所有相关的坑我都已经解释完毕了，相信大家应该很容易就可以看懂下面的代码，我就不介绍了。虽然看着简单，但是我其实还是踩了不少的坑，就这点代码花了我好几天的时间。而且确实这个代码写的也并不是很好，因为ajax取回来的代码是完整一个html页面，貌似用原版DOM API没办法解析，最后只好用jQuery的<code>parseHTML</code>方法解析的。而且我还因为原生方法和jQuery之间的方法名搞混了，浪费了很多时间。</p><pre><code class="js">// ==UserScript==// @name         remind_me_vagrant_update// @namespace    https://github.com/techstay/myscripts// @version      0.1// @description  remind me if vagrant support virtualbox// @author       techstay// @match        *// @require      https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js// @connect vagrantup.com// @grant GM_setValue// @grant GM_getValue// @grant GM_setClipboard// @grant GM_log// @grant GM_xmlhttpRequest// @grant unsafeWindow// @grant window.close// @grant window.focus// ==/UserScript==(function () {    &#39;use strict&#39;;    const CHECKED_DATE = &#39;checkedDate&#39;;    function checkDateEquals(a, b) {        return a.getFullYear() === b.getFullYear() &amp;&amp;            a.getMonth() === b.getMonth() &amp;&amp;            a.getDate() === b.getDate();    }    function checkVagrantVersion() {        GM_setValue(CHECKED_DATE, new Date());        GM_xmlhttpRequest({            &quot;method&quot;: &quot;GET&quot;,            &quot;url&quot;: &quot;https://www.vagrantup.com/&quot;,            &quot;headers&quot;: {                &quot;user-agent&quot;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#39;            },            &quot;onload&quot;: function (result) {                var list = jQuery.parseHTML(result.response);                jQuery.each(list, function (i, el) {                    if (el.nodeName == &#39;HEADER&#39;) {                        var header = jQuery.parseXML(el.innerHTML);                        var version = header.getElementsByTagName(&#39;a&#39;)[1].textContent.replace(&#39;Download &#39;, &#39;&#39;);                        if (version != &#39;2.2.6&#39;) {                            alert(&#39;Vagrant update!&#39;);                        }                        return false;                    }                });            }        });    }    var today = new Date();    var lastCheckedDay = new Date(GM_getValue(CHECKED_DATE, new Date(&#39;2006-1-1&#39;)));    if (!checkDateEquals(lastCheckedDay, today)) {        checkVagrantVersion();    }})();</code></pre><h4 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h4><p>编写脚本很难一次成功，大部分时间都花在了调试上面。调试油猴脚本的话有几种调试方法。</p><p>第一种方法就是最原始的打印日志，可以利用<code>console.log</code>和<code>GM_log</code>来将关键信息打印出来，上面的脚本就是我靠打印日志一点点发现各种参数错误的。说实话这种办法有点笨。</p><p>第二种就是利用浏览器的调试功能，在脚本需要调试的地方插入<code>debugger;</code>语句，然后在打开F12开发者工具的情况下刷新页面，就会发现网页已经暂停在相应位置上。这样就可以利用F12开发者工具进行单步调试、监视变量等操作了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/2630308594-5ea670883f9dcd05_fix732.png" alt="调试脚本" title="">                </div>                <div class="image-caption">调试脚本</div>            </figure><h4 id="将文章同步复制到Csdn和思否编辑器的脚本"><a href="#将文章同步复制到Csdn和思否编辑器的脚本" class="headerlink" title="将文章同步复制到Csdn和思否编辑器的脚本"></a>将文章同步复制到Csdn和思否编辑器的脚本</h4><p>我的文章一般都是简书首发，然后复制粘贴到Csdn中，但是后来我发现每次手动操作太蠢了，为什么不用脚本来自动化呢？所以我又写了个脚本帮忙完成自动化工作。本来以为这个脚本应该比较简单，不过还是踩了很多坑才凑合把功能写出来。</p><p>首先是数据的保存，利用油猴提供的<code>GM_setValue</code>倒是可以很简单的将文章标题和内容保存起来。不过问题来了，如何在不同页面之间共享呢？有几种方案：第一种最简单粗暴，直接复制两份，对应页面首先判断是否存在数据，存在的话才执行复制操作，然后清空数据。这种方案最简单，而且如果自己直接新建文章的话也不会出问题。第二种就是数据只保存一份，通过几个变量来确定什么时候复制完成，清空数据，但是这样比较复杂，要理清逻辑顺序很麻烦。所以最后我就采用了第一种办法。</p><p>然后又遇到一个问题，那就是如果编辑器自带了保存和恢复功能，很可能会把我复制过去的文章给覆盖了，所以需要等页面加载完之后，延迟一段时间才进行复制操作。然后我又谷歌了一番，差不多解决了这个问题。</p><p>然后遇到了一个非常棘手的问题，就是SF的编辑器设计比较复杂，没办法通过直接填充<code>value</code>或者<code>text</code>属性的方式来写入文章，我想了很久也没有想出来怎么解决。没办法只好改用剪贴板的方式来糊弄了，也就是将文章内容复制到剪贴板里头，然后手动粘贴到编辑器中。</p><p>最后一个问题就是简书上这个复制按钮应该如何实现，其实简书编辑器的工具栏倒是空了一些部分，我本来想把按钮直接加到那个上面。但是我发现貌似一旦添加东西，那个工具栏会自动重载取消更改，所以水平所限没做到，只好利用jQueryUI加了一个很丑的浮动按钮，而且因为拖动的时候会触发单击，没办法把按钮改成了双击触发。</p><p>最后的脚本就是下面这样的。相比第一个脚本多了几个打开新页面、删除变量、访问剪贴板的API。</p><pre><code class="js">// ==UserScript==// @name         copy_jianshu_to_csdn_and_segmentfault// @namespace    https://github.com/techstay/myscripts// @version      0.1// @description  将简书文章复制到csdn和思否编辑器中// @author       techstay// @match        https://editor.csdn.net/md/// @match https://segmentfault.com/write// @match https://www.jianshu.com/writer*// @require      https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js// @require      https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.min.js// @grant GM_setValue// @grant GM_getValue// @grant GM_deleteValue// @grant unsafeWindow// @grant GM_setClipboard// @grant window.close// @grant window.focus// @grant GM_openInTab// ==/UserScript==(function () {    &#39;use strict&#39;;    const SF_URL = &#39;https://segmentfault.com/write&#39;    const CSDN_URL = &#39;https://editor.csdn.net/md/&#39;    const SF_TITLE = &#39;sf_title&#39;    const SF_CONTENT = &#39;sf_content&#39;    const CSDN_TITLE = &#39;csdn_title&#39;    const CSDN_CONTENT = &#39;csdn_content&#39;    function saveArticle() {        GM_setValue(CSDN_TITLE, $(&#39;._24i7u&#39;).val())        GM_setValue(CSDN_CONTENT, $(&#39;#arthur-editor&#39;).val())        GM_setValue(SF_TITLE, $(&#39;._24i7u&#39;).val())        GM_setValue(SF_CONTENT, $(&#39;#arthur-editor&#39;).val())    }    function copyToCsdn() {        var title = GM_getValue(CSDN_TITLE, &#39;&#39;)        var content = GM_getValue(CSDN_CONTENT, &#39;&#39;)        if (title != &#39;&#39; &amp;&amp; content != &#39;&#39;) {            $(&#39;.article-bar__title&#39;).delay(2000).queue(function () {                $(&#39;.article-bar__title&#39;).val(title)                $(&#39;.editor__inner&#39;).text(content)                GM_deleteValue(CSDN_TITLE)                GM_deleteValue(CSDN_CONTENT)                $(this).dequeue()            })        }    }    function copyToSegmentFault() {        $(document).ready(function () {            var title = GM_getValue(SF_TITLE, &#39;&#39;)            var content = GM_getValue(SF_CONTENT, &#39;&#39;)            if (title != &#39;&#39; &amp;&amp; content != &#39;&#39;) {                $(&#39;#title&#39;).delay(2000).queue(function () {                    $(&#39;#title&#39;).val(title)                    GM_setClipboard(content, &#39;text&#39;)                    GM_deleteValue(SF_TITLE)                    GM_deleteValue(SF_CONTENT)                    $(this).dequeue()                })            }        })    }    function addCopyButton() {        $(&#39;body&#39;).append(&#39;&lt;div id=&quot;copyToCS&quot;&gt;双击复制到CSDN和思否&lt;/div&gt;&#39;)        $(&#39;#copyToCS&#39;).css(&#39;width&#39;, &#39;200px&#39;)        $(&#39;#copyToCS&#39;).css(&#39;position&#39;, &#39;absolute&#39;)        $(&#39;#copyToCS&#39;).css(&#39;top&#39;, &#39;70px&#39;)        $(&#39;#copyToCS&#39;).css(&#39;left&#39;, &#39;350px&#39;)        $(&#39;#copyToCS&#39;).css(&#39;background-color&#39;, &#39;#28a745&#39;)        $(&#39;#copyToCS&#39;).css(&#39;color&#39;, &#39;white&#39;)        $(&#39;#copyToCS&#39;).css(&#39;font-size&#39;, &#39;large&#39;)        $(&#39;#copyToCS&#39;).css(&#39;z-index&#39;, 100)        $(&#39;#copyToCS&#39;).css(&#39;border-radius&#39;, &#39;25px&#39;)        $(&#39;#copyToCS&#39;).css(&#39;text-align&#39;, &#39;center&#39;)        $(&#39;#copyToCS&#39;).dblclick(function () {            saveArticle()            GM_openInTab(SF_URL, true)            GM_openInTab(CSDN_URL, true)        })        $(&#39;#copyToCS&#39;).draggable()    }    $(document).ready(function () {        if (window.location.href.startsWith(&#39;https://www.jianshu.com&#39;)) {            addCopyButton()        } else if (window.location.href.startsWith(SF_URL)) {            copyToSegmentFault()        } else if (window.location.href.startsWith(CSDN_URL)) {            copyToCsdn()        }    })})()</code></pre><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><h4 id="脚本编写流程"><a href="#脚本编写流程" class="headerlink" title="脚本编写流程"></a>脚本编写流程</h4><p>踩了几天坑，最后总结一下编写油猴脚本的一点步骤。首先要思考脚本的实现方式，需要用到什么API和权限，然后填写好脚本的注释信息。</p><p>然后将功能封装成函数的形式，最后在脚本末尾调用实现的函数。写的差不多的时候复制到浏览器中尝试运行。</p><p>遇到困难的时候，可能需要直接在F12开发者工具里进行调试。有些网页不用jQuery，为了方便，我们需要自己将jQuery导入到页面中，可以将下面的代码复制到浏览器控制台中。</p><pre><code class="js">var jq = document.createElement(&#39;script&#39;);jq.src = &quot;https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js&quot;;document.getElementsByTagName(&#39;head&#39;)[0].appendChild(jq);</code></pre><h4 id="发布脚本"><a href="#发布脚本" class="headerlink" title="发布脚本"></a>发布脚本</h4><h5 id="更新URL"><a href="#更新URL" class="headerlink" title="更新URL"></a>更新URL</h5><p>脚本做完了，自然是要共享出来让大家一起使用的。当然既然要发布，自然要支持更新方便日后维护。方法也很简单，直接在上面的注释部分添加<code>updateURL</code>即可，然后设置脚本访问地址。例如我要将脚本发布到Github上，就添加下面的注释。</p><pre><code class="js">// @updateURL https://raw.githubusercontent.com/techstay/myscripts/master/tampermonkey/remind_me_vagrant_update.js</code></pre><h5 id="上传脚本"><a href="#上传脚本" class="headerlink" title="上传脚本"></a>上传脚本</h5><p>油猴脚本支持好几个网站，其中目前最主流的是<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">GreasyFork</a>，登录这个网站注册一个账号，然后进入用户页面选择提交脚本，然后填写脚本代码和各项信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/3346250129-51af0aada1db5227_fix732.png" alt="提交脚本" title="">                </div>                <div class="image-caption">提交脚本</div>            </figure><p>这样脚本就提交上去了，其他人也可以搜索到并安装脚本了！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/油猴脚本编写教程-SegmentFault思否/2044765339-3bf40f378ab7c24b_fix732.png" alt="提交脚本完成" title="">                </div>                <div class="image-caption">提交脚本完成</div>            </figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://segmentfault.com/a/1190000021654926" target="_blank" rel="noopener">油猴脚本编写教程-SegmentFault思否</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 油猴脚本 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python os模块文件目录操作详解</title>
      <link href="/2022/06/22/python%20os%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/22/python%20os%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-os函数列表"><a href="#1-os函数列表" class="headerlink" title="1. os函数列表"></a>1. os函数列表</h3><pre><code class="python">os.mknod(&quot;text.txt&quot;)：创建空文件os.system():运行shell命令os.exit():终止当前进程os.getcwd() 取得当前工作目录os.getenv()和os.putenv:分别用来读取和设置环境变量os.environ[&#39;MY_USER&#39;]os.chdir(&#39;dirname&#39;) 改变目录os.mkdir/makedirs(&#39;dirname&#39;)创建目录/多层目录os.rmdir/removedirs(&#39;dirname&#39;) 删除目录/多层目录os.remove(‘path/filename’) 删除文件os.rename(oldname, newname) 重命名文件os.walk() 生成目录树下的所有文件名os.stat（file）:获得文件属性os.listdir(&#39;dirname&#39;) 列出指定目录的文件os.chmod() 改变目录权限os.path.abspath(path) #返回绝对路径os.path.basename(path) #返回文件名os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。&#39;os.path.dirname(path) #返回文件路径os.path.exists(path) #路径存在则返回True,路径损坏返回Falseos.path.lexists              #路径存在则返回True,路径损坏也返回Trueos.path.expanduser(path)    #把path中包含的&quot;~&quot;和&quot;~user&quot;转换成用户目录os.path.expandvars(path)    #根据环境变量的值替换path中包含的”$name”和”${name}”os.path.getatime(path)      #返回最后一次进入此path的时间。os.path.getmtime(path)      #返回在此path下最后一次修改的时间。os.path.getctime(path)      #返回path的大小os.path.getsize(path)       #返回文件大小，如果文件不存在就返回错误os.path.isabs(path)         #判断是否为绝对路径os.path.isfile(path)        #判断路径是否为文件os.path.isdir(path)         #判断路径是否为目录os.path.islink(path)        #判断路径是否为链接os.path.ismount(path)       #判断路径是否为挂载点（）os.path.join(path1[, path2[, ...]])         #把目录和文件名合成一个路径&#39;os.path.normcase(path)      #转换path的大小写和斜杠os.path.normpath(path)      #规范path字符串形式os.path.realpath(path)      #返回path的真实路径os.path.relpath(path[, start])  #从start开始计算相对路径&#39;os.path.samefile(path1, path2)  #判断目录或文件是否相同&#39;os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件&#39;os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件&#39;os.path.split(path)     #把路径分割成dirname和basename，返回一个元组os.path.splitdrive(path)     #一般用在windows下，返回驱动器名和路径组成的元组os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组os.path.splitunc(path)      #把路径分割为加载点与文件os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有&#39;#3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有#文件名，args则为walk的第三个参数os.path.supports_unicode_filenames      #设置是否支持unicode路径名os.sep:取代操作系统特定的路径分隔符os.name:指示你正在使用的工作平台。比如对于Windows，它是&#39;nt&#39;，而对于Linux/Unix用户，它是&#39;posix&#39;。</code></pre><h3 id="2-os-stat方法"><a href="#2-os-stat方法" class="headerlink" title="2. os.stat方法"></a>2. os.stat方法</h3><pre><code class="python">&gt;&gt;&gt; import os&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;)(33188, 2033080, 26626L, 1, 0, 0, 864, 1297653596, 1275528102, 1292892895)&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;).st_mode   #权限模式33188&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;).st_ino   #inode number2033080&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;).st_dev    #device26626&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;).st_nlink  #number of hard links1&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;).st_uid    #所有用户的user id0&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;).st_gid    #所有用户的group id0&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;).st_size  #文件的大小，以位为单位864&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;).st_atime  #文件最后访问时间1297653596&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;).st_mtime  #文件最后修改时间1275528102&gt;&gt;&gt; print os.stat(&quot;/root/python/zip.py&quot;).st_ctime  #文件创建时间1292892895fp = open(&quot;text.txt&quot;,w):直接打开一个文件，如果文件不存在就创建文件</code></pre><h3 id="3-关于open的模式"><a href="#3-关于open的模式" class="headerlink" title="3. 关于open的模式"></a>3. 关于open的模式</h3><pre><code class="python">w 写方式a 追加模式打开（从EOF开始，必要时创建新文件）r+ 以读写模式打开w+ 以读写模式打开a+ 以读写模式打开rb 以二进制读模式打开wb 以二进制写模式打开 (参见 w )ab 以二进制追加模式打开 (参见 a )rb+ 以二进制读写模式打开 (参见 r+ )wb+ 以二进制读写模式打开 (参见 w+ )ab+ 以二进制读写模式打开 (参见 a+ )</code></pre><h3 id="4-关于文件的函数"><a href="#4-关于文件的函数" class="headerlink" title="4. 关于文件的函数"></a>4. 关于文件的函数</h3><pre><code class="python">fp.read([size])   </code></pre><p>size为读取的长度，以byte为单位</p><pre><code class="python">fp.readline([size])  </code></pre><p>读一行，如果定义了size，有可能返回的只是一行的一部分</p><pre><code class="python">fp.readlines([size]) </code></pre><p>把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。</p><pre><code class="python">fp.write(str)  </code></pre><p>把str写到文件中，write()并不会在str后加上一个换行符</p><pre><code class="python">fp.writelines(seq)  </code></pre><p>把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。</p><pre><code class="python">fp.close()  </code></pre><p>关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError</p><pre><code class="python">fp.flush()     </code></pre><p>把缓冲区的内容写入硬盘</p><pre><code class="python">fp.fileno()    </code></pre><p>返回一个长整型的”文件标签“</p><pre><code class="python">fp.isatty()      </code></pre><p>文件是否是一个终端设备文件（unix系统中的）</p><pre><code class="python">fp.tell()     </code></pre><p>返回文件操作标记的当前位置，以文件的开头为原点</p><pre><code class="python">fp.next()  </code></pre><p>返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。</p><pre><code class="python">fp.seek(offset[,whence])  </code></pre><p>将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</p><pre><code class="python">fp.truncate([size])      </code></pre><p>把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。</p><h3 id="5-实战"><a href="#5-实战" class="headerlink" title="5 实战"></a>5 实战</h3><h4 id="5-1-创建目录"><a href="#5-1-创建目录" class="headerlink" title="5.1 创建目录"></a>5.1 创建目录</h4><pre><code class="python">os.mkdir(&quot;file&quot;)</code></pre><h4 id="5-2-复制文件"><a href="#5-2-复制文件" class="headerlink" title="5.2 复制文件:"></a>5.2 复制文件:</h4><pre><code class="python">shutil.copyfile(&quot;oldfile&quot;,&quot;newfile&quot;)    </code></pre><p>oldfile和newfile都只能是文件</p><pre><code class="python">shutil.copy(&quot;oldfile&quot;,&quot;newfile&quot;)   </code></pre><p>oldfile只能是文件夹，newfile可以是文件，也可以是目标目录</p><pre><code class="python">shutil.copytree(&quot;olddir&quot;,&quot;newdir&quot;)    </code></pre><p>复制文件夹.olddir和newdir都只能是目录，且newdir必须不存在</p><h4 id="5-3-重命名文件（目录）"><a href="#5-3-重命名文件（目录）" class="headerlink" title="5.3 重命名文件（目录）"></a>5.3 重命名文件（目录）</h4><pre><code class="python">os.rename(&quot;oldname&quot;,&quot;newname&quot;)  </code></pre><p>文件或目录都是使用这条命令</p><h4 id="5-4-移动文件（目录）"><a href="#5-4-移动文件（目录）" class="headerlink" title="5.4 移动文件（目录）"></a>5.4 移动文件（目录）</h4><pre><code class="python">shutil.move(&quot;oldpos&quot;,&quot;newpos&quot;) </code></pre><h4 id="5-5-删除"><a href="#5-5-删除" class="headerlink" title="5.5 删除"></a>5.5 删除</h4><p>只能删除空目录</p><pre><code class="python">os.rmdir(&quot;dir&quot;)</code></pre><p>空目录、有内容的目录都可以删</p><pre><code class="python">shutil.rmtree(&quot;dir&quot;)  </code></pre><h4 id="5-6-转换目录，换路径"><a href="#5-6-转换目录，换路径" class="headerlink" title="5.6 转换目录，换路径"></a>5.6 转换目录，换路径</h4><pre><code class="python">os.chdir(&quot;path&quot;)   </code></pre><pre><code class="python">$ cat os1.py #!/usr/bin/python#---coding: utf-8---import osprint(&quot;环境变量 SHLVL:&quot;, os.getenv(&quot;SHLVL&quot;))print(&quot;当前目录:&quot;, os.getcwd())dir = os.getcwd()print(&quot;当前目录下内容：&quot;, os.listdir(dir))print(&quot;当前目录下内容：&quot;, os.system(&quot;ls&quot;))print(&quot;创建目录hello&quot;, os.mkdir(&#39;hello&#39;))print(&quot;删除目录hello&quot;, os.rmdir(&#39;hello&#39;))print(&quot;创建目录foo&quot;, os.mkdir(dir + &#39;/foo&#39;))print(&quot;重命名foo为bar&quot;, os.rename(&#39;foo&#39;,&#39;bar&#39;))print(&quot;创建文件test.txt&quot;, os.mknod(&#39;test.txt&#39;))</code></pre><pre><code class="bash">$ python3.8 os1.py 环境变量 SHLVL: 1当前目录: /root/python/os当前目录下内容： [&#39;os2.py&#39;, &#39;os1.py&#39;]os1.py    os2.py当前目录下内容： 0创建目录hello None删除目录hello None创建目录foo None重命名foo为bar None创建文件test.txt None</code></pre><h4 id="5-7-获取env环境变量"><a href="#5-7-获取env环境变量" class="headerlink" title="5.7 获取env环境变量"></a>5.7 获取env环境变量</h4><p>在python代码中，可以读取env变量，如：</p><pre><code class="python">import osusername = os.environ[&#39;MY_USER&#39;]password = os.environ[&#39;MY_PASS&#39;]print(&quot;Running with user: %s&quot; % username)</code></pre><p>比如运行在容器的python脚本需要捕捉环境变量env。docker run可以动态根据自己的需求修改环境变量。</p><pre><code class="python">docker run -e MY_USER=test -e MY_PASS=12345 ... &lt;image-name&gt; ...</code></pre><h4 id="5-8-批量创建指定名称的文件夹"><a href="#5-8-批量创建指定名称的文件夹" class="headerlink" title="5.8 批量创建指定名称的文件夹"></a>5.8 批量创建指定名称的文件夹</h4><pre><code class="python">import os, sysdef MkDir():    path = &#39;./file/&#39;#创建文件路径    i = 0    for i in range(200): #创建文件个数        file_name = path + str(i)        os.mkdir(file_name)        i=i+1        file_name_child = file_name + &quot;/left_colorimages&quot;          os.mkdir(file_name_child)MkDir()</code></pre><h4 id="5-9-判断目录是否存在"><a href="#5-9-判断目录是否存在" class="headerlink" title="5.9 判断目录是否存在"></a>5.9 判断目录是否存在</h4><pre><code class="python">import osdirs = &#39;/Users/joseph/work/python/&#39;if not os.path.exists(dirs):    os.makedirs(dirs)</code></pre><h4 id="5-10-判断文件是否存在"><a href="#5-10-判断文件是否存在" class="headerlink" title="5.10 判断文件是否存在"></a>5.10 判断文件是否存在</h4><pre><code class="python">import osfilename = &#39;/Users/joseph/work/python/poem.txt&#39;if not os.path.exists(filename):    os.system(r&quot;touch {}&quot;.format(path))#调用系统命令行来创建文件</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/python" alt="在这里插入图片描述" title="os模块文件目录操作详解/bb6a726ffd424868be6ba585ef8203a0.gif">                </div>                <div class="image-caption">os模块文件目录操作详解/bb6a726ffd424868be6ba585ef8203a0.gif</div>            </figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/xixihahalelehehe/article/details/104253123" target="_blank" rel="noopener">python os模块文件目录操作详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python获取当前文件所在目录和当前工作目录</title>
      <link href="/2022/06/20/python%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95%E5%92%8C%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/06/20/python%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95%E5%92%8C%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、当前工作目录"><a href="#一、当前工作目录" class="headerlink" title="一、当前工作目录"></a>一、当前工作目录</h3><pre><code class="python">import  osprint(os.getcwd()) # 获取当前工作目录路径print(os.path.abspath(&#39;.&#39;)) # 获取当前工作目录路径</code></pre><h3 id="二、当前文件路径"><a href="#二、当前文件路径" class="headerlink" title="二、当前文件路径"></a>二、当前文件路径</h3><pre><code class="python">import oscurrent_work_dir = os.path.dirname(__file__)  # 当前文件所在的目录weight_path = os.path.join(current_work_dir, weight_path)  # 再加上它的相对路径，这样可以动态生成绝对路径</code></pre><p> </p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/jizhidexiaoming/article/details/102930885" target="_blank" rel="noopener">python获取当前文件所在目录和当前工作目录</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode中使用git合并分支</title>
      <link href="/2022/06/20/vscode%E4%B8%AD%E4%BD%BF%E7%94%A8git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/"/>
      <url>/2022/06/20/vscode%E4%B8%AD%E4%BD%BF%E7%94%A8git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>首先我们有两个分支，一个是test分支，一个是main分支。我们现在要把test分支合并到main分支里面去。（就是说，test分支是比main分支早一个版本的）<br>另外，<strong>我们默认本地分支和线上分支版本是一样的</strong>，如果不一样要先pull一下。</p><p>test分支的内容 </p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719182820105.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>main分支的内容 </p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719182844500.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-把分支切换到本地的main分支"><a href="#1-把分支切换到本地的main分支" class="headerlink" title="1.把分支切换到本地的main分支"></a>1.把分支切换到本地的main分支</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719182939631.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意，本地的main分支是没有origin开头的。</p><h3 id="2-点击合并分支"><a href="#2-点击合并分支" class="headerlink" title="2. 点击合并分支"></a>2. 点击合并分支</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719183028248.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="3-选择开发的分支"><a href="#3-选择开发的分支" class="headerlink" title="3. 选择开发的分支"></a>3. 选择开发的分支</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719183138645.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里需要选择分支，我们选择本地的test分支。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719183234835.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后，我们看到main分支里面，就会出现刚刚test的内容了。而这时，只是本地的main分支合并了，线上的main分支还没被合并。我们需要再推送一下。</p><h3 id="4-将main分支推送到线上"><a href="#4-将main分支推送到线上" class="headerlink" title="4. 将main分支推送到线上"></a>4. 将main分支推送到线上</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vscode中使用git合并分支/20210719183358597.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="5-合并完成"><a href="#5-合并完成" class="headerlink" title="5.合并完成"></a>5.合并完成</h3><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/weixin_44004835/article/details/118908695" target="_blank" rel="noopener">vscode中使用git合并分支</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YAML中多行字符串的配置方法</title>
      <link href="/2022/06/18/YAML%E4%B8%AD%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
      <url>/2022/06/18/YAML%E4%B8%AD%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>有时候我们会在配置文件中配置一段文字说明，这种时候通常会出现两种需求：</p><ul><li>文字中可能出现段落，希望在配置中按段落方式编写，显示打印的时候也能出现段落换行。</li><li>文字很长，为方便编辑，可能在配置文件中分段写，但是显示的时候不喜欢出现配置中的段落换行。</li></ul><p>简单的说，就是：</p><ul><li>配置与显示，都严格按段落展示</li><li>配置按段落，显示不需要按段落</li></ul><p>假设，我们需要配置这样一段文字：</p><pre><code class="yaml">I am a coder.My blog is didispace.com.复制代码</code></pre><p>下面，就针对上面的两种情况来看看可以怎么来实现：</p><h3 id="配置与显示，都严格按段落展示"><a href="#配置与显示，都严格按段落展示" class="headerlink" title="配置与显示，都严格按段落展示"></a>配置与显示，都严格按段落展示</h3><p>这个需求下，我们希望配置和显示都按句子换行，就是这样：</p><pre><code class="yaml">I am a coder.My blog is didispace.com.复制代码</code></pre><h4 id="方法一：直接使用-n来换行"><a href="#方法一：直接使用-n来换行" class="headerlink" title="方法一：直接使用\n来换行"></a>方法一：直接使用<code>\n</code>来换行</h4><p>这样写：</p><pre><code class="yaml">string: &quot;I am a coder.\n\         My blog is didispace.com.&quot;复制代码</code></pre><p>最终输出：</p><pre><code class="yaml">I am a coder.My blog is didispace.com.复制代码</code></pre><p>通过<code>\n</code>在显示的时候换行，通过配置行末的<code>\</code>让这个字符串换行继续写（这个必须有，如果没有第二行行首会多一个空格）。</p><p><strong>注意</strong>：这里必须使用双引号来定义字符串，不能用单引号。因为单引号是不支持<code>\n</code>换行的。</p><h4 id="方法二：使用｜、｜-、｜"><a href="#方法二：使用｜、｜-、｜" class="headerlink" title="方法二：使用｜、｜+、｜-"></a>方法二：使用<code>｜</code>、<code>｜+</code>、<code>｜-</code></h4><p>在方法一种，其实我们在文字中加入了几个转义符号，其实对于阅读并不方便。在方法二中，将介绍更适合阅读的几种形式：</p><pre><code class="yaml">string: |  I am a coder.  My blog is didispace.com.string: |+  I am a coder.  My blog is didispace.com.string: |-  I am a coder.  My blog is didispace.com.复制代码</code></pre><p>如上面一共有三种配置都会自动按配置中所写的换行来换行，但是在文末会有一些区别，有的会增加一个空行，有的不会，有的会新增两个空行，具体说明如下：</p><ul><li><p><code>|</code>：文中自动换行 + 文末新增一空行</p></li><li><p><code>|+</code>：文中自动换行 + 文末新增两空行</p></li><li><p><code>|-</code>：文中自动换行 + 文末不新增行</p></li></ul><h3 id="配置按段落，显示不需要按段落"><a href="#配置按段落，显示不需要按段落" class="headerlink" title="配置按段落，显示不需要按段落"></a>配置按段落，显示不需要按段落</h3><p>这个需求下，我们希望配置里是按行写的，但是显示是如下面这样在一行的：</p><pre><code class="yaml">I am a coder.My blog is didispace.com.复制代码</code></pre><h4 id="方法一：直接在字符串中换行写"><a href="#方法一：直接在字符串中换行写" class="headerlink" title="方法一：直接在字符串中换行写"></a>方法一：直接在字符串中换行写</h4><p>最粗暴的写法，反正不用换行，那就直接写了：</p><pre><code class="yaml">string: &#39;I am a coder.         My blog is didispace.com.&#39;复制代码</code></pre><p>这里不论用双引号还是单引号都是可以的。因为不存在需要转移的内容，所以总体还算清晰。</p><h4 id="方法二：使用-gt-、-gt-、-gt"><a href="#方法二：使用-gt-、-gt-、-gt" class="headerlink" title="方法二：使用&gt;、&gt;+、&gt;-"></a>方法二：使用<code>&gt;</code>、<code>&gt;+</code>、<code>&gt;-</code></h4><p>比较好的表述方式就是使用<code>&gt;</code>、<code>&gt;+</code>、<code>&gt;-</code>来定义，比如下面这几种：</p><pre><code class="yaml">string: &gt;  I am a coder.  My blog is didispace.com.string: &gt;+  I am a coder.  My blog is didispace.com.string: &gt;-  I am a coder.  My blog is didispace.com.复制代码</code></pre><p>这三种都不会对配置中的换行进行实际换行，但是依然在文末的处理会有一些小区别，具体如下：</p><ul><li><p><code>&gt;</code>：文中不自动换行 + 文末新增一空行</p></li><li><p><code>&gt;+</code>：文中不自动换行 + 文末新增两空行</p></li><li><p><code>&gt;-</code>：文中不自动换行 + 文末不新增行</p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.cn/post/6844903972688363534" target="_blank" rel="noopener">YAML中多行字符串的配置方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YAML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy之Selector详解</title>
      <link href="/2022/06/18/Scrapy%E4%B9%8BSelector%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/18/Scrapy%E4%B9%8BSelector%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>前面介绍了<a href="https://blog.csdn.net/trayvontang/article/details/103286889" target="_blank" rel="noopener">scrapy命令</a>和<a href="https://blog.csdn.net/trayvontang/article/details/103286971" target="_blank" rel="noopener">Scrapy处理流程与重要组件 </a></p><p>这里介绍一下Scrapy的Selector，Scrapy的Selector和Beautifulsoup非常像，关于Beautifulsoup可以参考<a href="https://blog.csdn.net/trayvontang/article/details/103263086" target="_blank" rel="noopener">BeautifuSoup实用方法属性总结 </a>和<a href="https://blog.csdn.net/trayvontang/article/details/102811735" target="_blank" rel="noopener">BeautifulSoup详解</a></p><p>先来看一下Selector的知识点：</p><ul><li><img src="/images/Scrapy%E4%B9%8BSelector%E8%AF%A6%E8%A7%A3/20191128183547553.png" alt="Selector知识点"></li></ul><h2 id="二、xpath"><a href="#二、xpath" class="headerlink" title="二、xpath"></a>二、xpath</h2><p>我们先介绍一下xpath，因为xpath语法比较简洁，并且如果能够灵活应用的话，可以简化我们提取HTML内容的复杂度。</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>/</td><td>从根节点选取，使用绝对路径，路径必须完全匹配</td></tr><tr><td>//</td><td>从整个文档中选取，使用相对路径</td></tr><tr><td>.</td><td>从当前节点开始选取</td></tr><tr><td>…</td><td>从当前节点父节点开始选取</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table><p>光看说明有些抽象，我们通过一个例子来简单说明一下：</p><pre><code class="python"># -*- coding:utf-8 -*-from scrapy import Selectorcontent = &#39;&#39;&#39;&lt;div&gt;    &lt;p&gt;out inner div p&lt;/p&gt;    &lt;div id=&quot;inner&quot;&gt;&lt;p&gt;in inner div p&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;out div p&lt;/p&gt;&#39;&#39;&#39;selector = Selector(text=content)# 在整个文档中选取id为inner的div节点inner_div_sel = selector.xpath(&quot;//div[@id=&#39;inner&#39;]&quot;)# 获取整个文档中的p节点的文本print(inner_div_sel.xpath(&#39;//p/text()&#39;).getall())# 从inner div节点的父节点开始获取所有p节点的文本print(inner_div_sel.xpath(&#39;..//p/text()&#39;).getall())# 从inner div节点开始获取所有p节点的文本print(inner_div_sel.xpath(&#39;.//p/text()&#39;).getall())</code></pre><p>Scrapy的Selector和BeautifulSoup一样，可以通过字符串来构造相应的对象，然后就可以使用xpath相关的语法来解析HTML。</p><pre><code class="python">inner_div_sel = selector.xpath(&quot;//div[@id=&#39;inner&#39;]&quot;)</code></pre><p>首先@在xpath中表示选取属性，@id就表示选取id属性，//div[@id=‘inner’]就表示，选取id属性值为inner的div标签。</p><pre><code class="python">inner_div_sel.xpath(&#39;//p/text()&#39;).getall()</code></pre><p>上面的语句的输出是：</p><pre><code class="python">[&#39;out inner div p&#39;, &#39;in inner div p&#39;, &#39;out div p&#39;]</code></pre><p>很奇怪，我们已经在inner的div节点选取p，为什么获取到了所有的p？</p><p><strong>因为在xpath中，//表示从整个文档中选取，只要相对路径匹配就可以</strong></p><p>所有选取了文档中的所有p节点。</p><p>.和…就非常容易理解了，就是当前路径，和当前路径的上一级路径，路径必须完全匹配。</p><h2 id="三、获取值"><a href="#三、获取值" class="headerlink" title="三、获取值"></a>三、获取值</h2><pre><code class="python"># -*- coding:utf-8 -*-from scrapy import Selectorcontent = &#39;&#39;&#39;&lt;html&gt; &lt;head&gt;  &lt;title&gt;selector css&lt;/title&gt; &lt;/head&gt; &lt;body&gt;    &lt;ul&gt;        &lt;li&gt;ul 1 li 1&lt;/li&gt;        &lt;li&gt;ul 1 li 2&lt;/li&gt;    &lt;/ul&gt;    &lt;ul&gt;        &lt;li&gt;ul 2 li 1&lt;/li&gt;        &lt;li&gt;ul 2 li 2&lt;/li&gt;    &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt;&#39;&#39;&#39;selector = Selector(text=content)# get获取第一个print(selector.css(&#39;li::text&#39;).get())print(selector.css(&#39;li::text&#39;).extract_first())# getall获取列表print(selector.css(&#39;li::text&#39;).getall())print(selector.css(&#39;li::text&#39;).c())# [&#39;&lt;li&gt;ul 1 li 1&lt;/li&gt;&#39;, &#39;&lt;li&gt;ul 2 li 1&lt;/li&gt;&#39;]print(selector.xpath(&#39;//li[1]&#39;).getall())# [&#39;&lt;li&gt;ul 1 li 1&lt;/li&gt;&#39;]print(selector.xpath(&#39;(//li)[1]&#39;).getall())# 没找到返回Noneprint(selector.xpath(&#39;//div[@id=&quot;ne&quot;]/text()&#39;).get())# 给定默认值print(selector.xpath(&#39;//div[@id=&quot;ne&quot;]/text()&#39;).get(default=&#39;default-value&#39;))</code></pre><p>获取值使用get,getall,extract_first,extract方法，其中get与extract_first是获取第一个元素，getall和extract方法是获取所有元素，返回的是一个列表。</p><h2 id="四、css选择"><a href="#四、css选择" class="headerlink" title="四、css选择"></a>四、css选择</h2><pre><code class="python"># -*- coding:utf-8 -*-from scrapy import Selectorcontent = &#39;&#39;&#39;&lt;html&gt; &lt;head&gt;  &lt;title&gt;attribute&lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;div id=&#39;images&#39;&gt;   &lt;a href=&#39;image1.html&#39;&gt;a text 1&lt;img src=&#39;img1.png&#39; /&gt;&lt;/a&gt;   &lt;a href=&#39;image2.html&#39;&gt;a text 2&lt;img src=&#39;img2.png&#39; /&gt;&lt;/a&gt;   &lt;a href=&#39;image3.html&#39;&gt;a text 3&lt;img src=&#39;img3.png&#39;&gt;img3 text&lt;/img&gt;&lt;/a&gt;   &lt;a href=&#39;image4.html&#39;&gt;a text 4&lt;img /&gt;&lt;/a&gt;   &lt;a href=&#39;http://mycollege.vip&#39;&gt;a text 5&lt;img src=&#39;img5.jpg&#39; /&gt;&lt;/a&gt;  &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&#39;&#39;&#39;selector = Selector(text=content)# 获取第一个img标签的src属性print(selector.css(&#39;img&#39;).attrib[&#39;src&#39;])# 获取所有a标签的href属性print(selector.css(&#39;a::attr(href)&#39;).getall())# 选择有href属性并且href属性中包含image的a标签print(selector.css(&#39;a[href*=image]::attr(href)&#39;).getall())# 选择href属性包含image的a标签下的属性包含src的标签print(selector.css(&#39;a[href*=image] img::attr(src)&#39;).getall())# 获取img的文本print(selector.css(&#39;img::text&#39;).getall())print(selector.css(&#39;img::text&#39;).get(default=&#39;default-value&#39;))# 获取id为imgages节点下的所有文本print(selector.css(&#39;#images *::text&#39;).getall())print(selector.css(&#39;title::text&#39;).get())# xpath获取属性print(selector.xpath(&#39;//a/@href&#39;).getall())print(selector.xpath(&#39;//img/@src&#39;).getall())</code></pre><p>Scrapy的css就是实现了css选择器，并且做了一定的扩展，可以更加方便的获取我们最常用的文本和属性。</p><h2 id="五、xpath扩展"><a href="#五、xpath扩展" class="headerlink" title="五、xpath扩展"></a>五、xpath扩展</h2><pre><code class="python"># -*- coding:utf-8 -*-&quot;&quot;&quot;test()starts-with()contains()&quot;&quot;&quot;from scrapy import Selectorcontent = &#39;&#39;&#39;&lt;html&gt; &lt;head&gt;  &lt;title&gt;selector css&lt;/title&gt; &lt;/head&gt; &lt;body&gt;    &lt;ul&gt;        &lt;li class=&quot;nav1&quot;&gt;&lt;a href=&quot;http://www.mycollege.vip&quot;&gt;&lt;/a&gt;nav1 text&lt;/li&gt;        &lt;li class=&quot;nav2&quot;&gt;&lt;a href=&quot;http://www.mycollege.vip&quot;&gt;&lt;/a&gt;nav2 text&lt;/li&gt;        &lt;li class=&quot;nav33&quot;&gt;&lt;a href=&quot;http://www.mycollege.vip&quot;&gt;&lt;/a&gt;nav33 text&lt;/li&gt;        &lt;li class=&quot;clz1&quot;&gt;&lt;a href=&quot;http://www.mycollege.vip/xx.png&quot;&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li class=&quot;clz1 clz2&quot;&gt;&lt;a href=&quot;https://www.mycollege.vip&quot;&gt;&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt;&#39;&#39;&#39;selector = Selector(text=content, type=&quot;html&quot;)# 选择class值匹配正则表达式nav\d$的liprint(selector.xpath(r&#39;//li[re:test(@class, &quot;nav\d$&quot;)]//text()&#39;).getall())# 选择类包含clz1的liprint(selector.xpath(&#39;//li[has-class(&quot;clz1&quot;)]&#39;).getall())# 选择类既包含clz1又包含clz2的liprint(selector.xpath(&#39;//li[has-class(&quot;clz1&quot;, &quot;clz2&quot;)]&#39;).getall())# 选择属性href包含png的a标签print(selector.xpath(&#39;//a[contains(@href, &quot;png&quot;)]/@href&#39;).getall())# 选取href属性以https开头的a标签print(selector.xpath(&#39;//a[starts-with(@href, &quot;https&quot;)]/@href&#39;).getall())</code></pre><p>对于xpath的扩展主要有判断是否包含指定类的has-class方法，属性是否包含指定字符串的contains方法，属性是否以指定字符串开头的starts-with方法。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/trayvontang/article/details/103298913" target="_blank" rel="noopener">Scrapy之Selector详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-版本发布</title>
      <link href="/2022/06/18/Git-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"/>
      <url>/2022/06/18/Git-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h3 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20210707101238633.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20210707101247180.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="github-release"><a href="#github-release" class="headerlink" title="github release"></a>github release</h3><p>查看releases，会有很多版本，这些版本其实就是Git中的标签。<br>Git标签可以将现有或过去的提交点（Commit Point）打上标签，这个标签<br>可能是项目的一个里程碑或者一个重要节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20181213180038917.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>创建Github一个版本发布：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20181213180111885.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>-a 证明这个标签是注解的</li><li>-m 标签消息</li></ul><pre><code class="bash">git tag -a v1.0.1 -m &#39;msg&#39;</code></pre><p>在本地打上标签后，还要推送到远程库中，在Git术语中称之为Sharing Tag<br>使用命令<code>git show v1.0.0</code>（v1.0.0是标签名），来查看某标签的信息</p><pre><code class="bash">git show v1.0.0</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20181213194224114.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>确认无误后，可以将其通过<code>git push origin v1.0.0</code>命令推送到远程库，当然，较为罕见的情况，<br>你需要推送多个标签 <code>git push origin --tags</code>来代替</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/20181213194503568.png" alt="git同步远程库标签" title="">                </div>                <div class="image-caption">git同步远程库标签</div>            </figure><pre><code class="bash">git push origin v1.0.0</code></pre><h3 id="删除标签并推送到远端"><a href="#删除标签并推送到远端" class="headerlink" title="删除标签并推送到远端"></a>删除标签并推送到远端</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Git-版本发布/201812132001379.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><pre><code class="bash">git tag -d v1.0.0 git push origin :refs/tags/v1.0.0</code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/qq_33745102/article/details/84992778" target="_blank" rel="noopener">Git-版本发布</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac_vscode快捷键</title>
      <link href="/2022/06/13/Mac_vscode%E5%BF%AB%E6%8D%B7%E9%94%AE_-_SegmentFault_%E6%80%9D%E5%90%A6/"/>
      <url>/2022/06/13/Mac_vscode%E5%BF%AB%E6%8D%B7%E9%94%AE_-_SegmentFault_%E6%80%9D%E5%90%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><pre><code class="bash">Command + Shift + P / F1 显示命令面板Command + P 快速打开Command + Shift + N 打开新窗口Command + W 关闭窗口</code></pre><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><pre><code class="bash">Command + X 剪切（未选中文本的情况下，剪切光标所在行）Command + C 复制（未选中文本的情况下，复制光标所在行）Option + Up 向上移动行Option + Down 向下移动行Option + Shift + Up 向上复制行Option + Shift + Down 向下复制行Command + Shift + K 删除行Command + Enter 下一行插入Command + Shift + Enter 上一行插入Command + Shift + \ 跳转到匹配的括号Command + [ 减少缩进Command + ] 增加缩进Home 跳转至行首End 跳转到行尾Command + Up 跳转至文件开头Command + Down 跳转至文件结尾Ctrl + PgUp 按行向上滚动Ctrl + PgDown 按行向下滚动Command + PgUp 按屏向上滚动Command + PgDown 按屏向下滚动Command + Shift + [ 折叠代码块Command + Shift + ] 展开代码块Command + K Command + [ 折叠全部子代码块Command + K Command + ] 展开全部子代码块Command + K Command + 0 折叠全部代码块Command + K Command + J 展开全部代码块Command + K Command + C 添加行注释Command + K Command + U 移除行注释Command + / 添加、移除行注释Option + Shift + A 添加、移除块注释Option + Z 自动换行、取消自动换行</code></pre><h3 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h3><pre><code class="bash">Option + 点击 插入多个光标Command + Option + Up 向上插入光标Command + Option + Down 向下插入光标Command + U 撤销上一个光标操作Option + Shift + I 在所选行的行尾插入光标Command + I 选中当前行Command + Shift + L 选中所有与当前选中内容相同部分Command + F2 选中所有与当前选中单词相同的单词Command + Ctrl + Shift + Left 折叠选中Command + Ctrl + Shift + Right 展开选中Alt + Shift + 拖动鼠标 选中代码块Command + Shift + Option + Up 列选择 向上Command + Shift + Option + Down 列选择 向下Command + Shift + Option + Left 列选择 向左Command + Shift + Option + Right 列选择 向右Command + Shift + Option + PgUp 列选择 向上翻页Command + Shift + Option + PgDown 列选择 向下翻页</code></pre><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><pre><code class="bash">Command + F 查找Command + Option + F 替换Command + G 查找下一个Command + Shift + G 查找上一个Option + Enter 选中所有匹配项Command + D 向下选中相同内容Command + K Command + D 移除前一个向下选中相同内容</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><pre><code class="bash">Ctrl + Space 打开建议Command + Shift + Space 参数提示Tab Emmet插件缩写补全Option + Shift + F 格式化Command + K Command + F 格式化选中内容F12 跳转到声明位置Option + F12 查看具体声明内容Command + K F12 分屏查看具体声明内容Command + . 快速修复Shift + F12 显示引用F2 重命名符号Command + Shift + . 替换为上一个值Command + Shift + , 替换为下一个值Command + K Command + X 删除行尾多余空格Command + K M 更改文件语言</code></pre><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><pre><code class="bash">Command + T 显示所有符号Ctrl + G 跳转至某行Command + P 跳转到某个文件Command + Shift + O 跳转到某个符号Command + Shift + M 打开问题面板F8 下一个错误或警告位置Shift + F8 上一个错误或警告位置Ctrl + Shift + Tab 编辑器历史记录Ctrl + - 后退Ctrl + Shift + - 前进Ctrl + Shift + M Tab 切换焦点</code></pre><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><pre><code class="bash">Command + W 关闭编辑器Command + K F 关闭文件夹Command + \ 编辑器分屏Command + 1 切换到第一分组Command + 2 切换到第二分组Command + 3 切换到第三分组Command + K Command + Left 切换到上一分组Command + K Command + Right 切换到下一分组Command + K Command + Shift + Left 左移编辑器Command + K Command + Shift + Right 右移编辑器Command + K Left 激活左侧编辑组Command + K Right 激活右侧编辑组</code></pre><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><pre><code class="bash">Command + N 新建文件Command + O 打开文件Command + S 保存文件Command + Shift + S 另存为Command + Option + S 全部保存Command + W 关闭Command + K Command + W 全部关闭Command + Shift + T 重新打开被关闭的编辑器Command + K Enter 保持打开Ctrl + Tab 打开下一个Ctrl + Shift + Tab 打开上一个Command + K P 复制当前文件路径Command + K R 在资源管理器中查看当前文件Command + K O 新窗口打开当前文件</code></pre><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><pre><code class="bash">Command + Ctrl + F 全屏、退出全屏Command + Option + 1 切换编辑器分屏方式（横、竖）Command + + 放大Command + - 缩小Command + B 显示、隐藏侧边栏Command + Shift + E 显示资源管理器 或 切换焦点Command + Shift + F 显示搜索框Ctrl + Shift + G 显示Git面板Command + Shift + D 显示调试面板Command + Shift + X 显示插件面板Command + Shift + H 全局搜索替换Command + Shift + J 显示、隐藏高级搜索Command + Shift + C 打开新终端Command + Shift + U 显示输出面板Command + Shift + V Markdown预览窗口Command + K V 分屏显示 Markdown预览窗口</code></pre><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><pre><code class="bash">F9 设置 或 取消断点F5 开始 或 继续F11 进入Shift + F11 跳出F10 跳过Command + K Command + I 显示悬停信息</code></pre><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><pre><code class="bash">Ctrl + ` 显示终端Ctrl + Shift + ` 新建终端Command + Up 向上滚动Command + Down 向下滚动PgUp 向上翻页PgDown 向下翻页Command + Home 滚动到顶部Command + End 滚动到底部</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000012811886" target="_blank" rel="noopener">Mac_vscode快捷键_-_SegmentFault_思否</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VScode </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的字符串详解</title>
      <link href="/2022/06/13/Python%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/13/Python%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Python中的字符串"><a href="#Python中的字符串" class="headerlink" title="Python中的字符串"></a>Python中的字符串</h3><p>字符串（String）是字符序列，或者说是一串字符。<br>字符只是一个符号。例如，英语具有26个字符。Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。<br>通过将字符括在单引号或双引号中来创建字符串。Python中甚至可以使用三引号，但通常用于表示多行字符串和文档字符串。</p><pre><code class="python">varS = &#39;Hello World!&#39;三引号字符串可以扩展多行my_str = &quot;&quot;&quot;Hello, welcome to           the world of Python&quot;&quot;&quot;</code></pre><p>Python中的字符串索引:（正）索引从0开始；Python允许负索引，-1 为从末尾的开始位置。</p><p>参见下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210907161243809.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以使用方括号 [] 来标识其中的字符，也可用来截取字符串，<br>标识其中的元素格式如：变量[下标]<br>字符串的切片（截取字符串的一段）语法格式如：变量[头下标:尾下标]，冒号是切片运算符。注意，切片结果不含尾下标字符，遵循左闭右开原则。</p><p>参见如下的例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210907161330157.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="使用字符串需要注意"><a href="#使用字符串需要注意" class="headerlink" title="使用字符串需要注意:"></a>使用字符串需要注意:</h4><p>☆包含字符串引号必须一致，不能一边是单引号一边是双引号，如：var1=”good’ 将报错。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210910182031229.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>☆当字符串中包含单引号（’）使用双引号创建字符串；字符串包含双引号（”）使用单引号创建。如</p><pre><code class="python">var2 = &quot;I&#39;m just a student&quot;var3 = &#39;What is &quot;Python&quot;?&#39;</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210910182031274.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>也可以使用转移字符转义字符，如：</p><pre><code class="python">var4 = &#39;I\&#39;m just a student&#39;</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210910182031275.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>关于转义字符，后面将进一步介绍。</p><p>☆字符串是不可变数据类型，也就是说你要改变原字符串内的元素，只能是新建另一个字符串。换句话说， 字符串是不可变的。这意味着字符串的元素一旦分配就无法更改。我们可以简单地将不同的字符串重新分配给相同的名称。</p><p>不能删除或删除字符串中的字符。但是使用del关键字可以完全删除字符串。<br>例如删除my_string = ‘Python’，可用如下语句：</p><pre><code class="python">del my_string</code></pre><h3 id="Python字符串操作"><a href="#Python字符串操作" class="headerlink" title="Python字符串操作"></a>Python字符串操作</h3><p>Python字符串运算符</p><p>下表示例中，变量 a 值为字符串 “Hello”，b 变量值为 “Python”：</p><table><thead><tr><th><strong>操作符</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td>+</td><td>字符串连接(也称为拼接)</td><td>a + b 输出结果： HelloPython</td></tr><tr><td>*</td><td>重复输出字符串</td><td>a*2 输出结果：HelloHello</td></tr><tr><td>[]</td><td>通过索引获取字符串中字符</td><td>a[1] 输出结果** e**</td></tr><tr><td>[ : ]</td><td>截取字符串中的一部分，遵循<strong>左闭右开</strong>原则，str[0:2] 是不包含第 3 个字符的。</td><td>a[1:4] 输出结果 ell</td></tr><tr><td>in</td><td>成员运算符 - 如果字符串中包含给定的字符返回 True</td><td>‘H’ in a 输出结果 True</td></tr><tr><td>not in</td><td>成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td>‘M’ not in a 输出结果 True</td></tr></tbody></table><h4 id="python里的原始字符串"><a href="#python里的原始字符串" class="headerlink" title="python里的原始字符串"></a>python里的原始字符串</h4><p>原始字符串：所有的字符串都是直接按照字面的意思来使用。<br>python原始字符串是指在引号前添加 r 或 R 前缀的字符串，在原始字符串中，字符“\” 不再表示转义字符的含义。<br>如：<br>直接使用‘c:\now’会报错，\需要转义，应该这样写 ‘c:\now’，或者采用原始字符串的写法r‘c:\now’<br>对于 ASCII 编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能用转义字符的形式来（以反斜杠\开始）表示，常见的转义字符参见下表：</p><table><thead><tr><th><strong>转义字符</strong></th><th><strong>说明</strong></th><th><strong>例子</strong></th></tr></thead><tbody><tr><td>\n</td><td>换行符，将光标位置移到下一行开头。</td><td>print(“Hello\nWorld!”)  输出如下： Hello World!</td></tr><tr><td>\t</td><td>水平制表符，也即 Tab 键，一般相当于四个空格。</td><td>print(“Hello\tWorld!”)  输出如下： Hello        World!</td></tr><tr><td>\</td><td>反斜线</td><td>print(‘此路径是D:\test\hello.txt’) 输出如下： 此路径是D:\test\hello.txt</td></tr><tr><td>&#39;</td><td>单引号</td><td>print(‘I&#39;m Li Ning’) 输出如下： I’m Li Ning</td></tr><tr><td>&quot;</td><td>双引号</td><td>print(“可以使用&quot;创建字符串”) 输出如下： 可以使用”创建字符串</td></tr><tr><td>\</td><td>在字符串行尾的续行符，即一行未完，转到下一行继续写。</td><td>print(“line1 \ line2 \ line3”) 输出如下： line1 line2 line3</td></tr></tbody></table><h4 id="f字符串（f-string）"><a href="#f字符串（f-string）" class="headerlink" title="f字符串（f-string）"></a>f字符串（f-string）</h4><p>以f开头的字符串，称之为f-string，是从python3.6引入的它和普通字符串不同之处在于，字符串如果包含{xxx}，就会以对应的变量替换：</p><pre><code class="python">r = 2.5s = 3.14 * r ** 2print(f&#39;半径为{r}的圆的面积为{s:.2f}&#39;) #半径为2.5的圆的面积为19.62</code></pre><p>参见下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/2021091015555711.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上述代码中，{r}被变量r的值替换，{s:.2f}被变量s的值替换，并且:后面的.2f指定了格式化参数（即保留两位小数），因此，{s:.2f}的替换结果是19.62。</p><p>f字符串的前缀为f，{}括号部分是被替换值，其中冒号前是变量名，冒号后指定用于类型，填充或对齐的格式说明符。</p><h4 id="Python-的字符串常用方法（函数）"><a href="#Python-的字符串常用方法（函数）" class="headerlink" title="Python 的字符串常用方法（函数）"></a>Python 的字符串常用方法（函数）</h4><p>【详见官网<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#string-methods" target="_blank" rel="noopener">内置类型 — Python 3.9.7 文档</a> 】</p><p>方法及描述概述如下：</p><ul><li>capitalize()<br>将字符串的第一个字符转换为大写，不会修改原始字符串。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210908111308767.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>casefold()</li></ul><p>把字符串大写字符转换为小写。不会修改原始字符串。</p><ul><li>center(width, fillchar)</li></ul><p>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</p><ul><li>count(str, beg= 0,end=len(string))</li></ul><p>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数。</p><p>字符索引值从0开始。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210908161802542.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>encode(encoding=’UTF-8’,errors=’strict’)</li></ul><p>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’。</p><ul><li>endswith(suffix, beg=0, end=len(string))</li></ul><p>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False。</p><ul><li>expandtabs(tabsize=8)</li></ul><p>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</p><ul><li>find(str, beg=0, end=len(string))</li></ul><p>检测 str 是否包含在字符串中，如果指定范围 beg（开始） 和 end（结束） ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210911090100608.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>index(str, beg=0, end=len(string))</li></ul><p>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</p><ul><li>isalnum()</li></ul><p>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False。</p><ul><li>isalpha()</li></ul><p>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False。</p><ul><li>isdigit()</li></ul><p>如果字符串只包含数字则返回 True 否则返回 False。</p><ul><li>islower()</li></ul><p>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False。</p><ul><li>isnumeric()</li></ul><p>如果字符串中只包含数字字符，则返回 True，否则返回 False。</p><ul><li>isspace()</li></ul><p>如果字符串中只包含空白，则返回 True，否则返回 False.</p><ul><li>istitle()</li></ul><p>如果字符串是标题化的(见 title())则返回 True，否则返回 False。</p><ul><li>isupper()</li></ul><p>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False。</p><ul><li>join(seq)</li></ul><p>以指定字符串作为分隔符，将 seq 指定要连接的元素序列连接生成一个新的字符串。例如：</p><pre><code class="python">a = &quot;We&quot;b = &quot;learn&quot;c = &quot;Python&quot;str = &quot; &quot;;seq = (a, b, c); #字符串序列print(str.join(seq)) #输出：We learn Python</code></pre><p>运行效果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210911082339166.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>len(string)</li></ul><p>返回字符串长度。</p><p>默认情况下，用 len(string) 函数计算该字符串的长度时，不区分英文、数字、汉字等字符，每个字符长度为1，例如：</p><pre><code class="python">s = &quot;我爱学Python&quot;</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/2021091316431797.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在实际应用中，有时需要获得字符串占用的字节数。这怎么办？在 Python 中，不同的字符所占的字节数不同，数字、英文字母、小数点、下划线以及空格，各占一个字节，而一个汉字可能占 2~4 个字节，具体占多少个，取决于采用的编码方式。例如，汉字在 GBK/GB2312 编码中占用 2 个字节，而在 UTF-8 编码中一般占用 3 个字节。可以通过encode()方法（函数），该方法默认按使用UTF-8编码计算，若按GBK或者GB2312计算，可以带参数，例如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210913170452582.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>ljust(width[, fillchar])</li></ul><p>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</p><ul><li>lower()</li></ul><p>转换字符串中所有大写字符为小写。</p><ul><li>lstrip([chars])</li></ul><p>截掉字符串左边的空格或指定字符。chars – 指定删除的字符（默认即缺省为空格）</p><ul><li>maketrans()</li></ul><p>创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</p><ul><li>max(str)</li></ul><p>返回字符串 str 中最大的字母。</p><ul><li>min(str)</li></ul><p>返回字符串 str 中最小的字母。</p><ul><li>replace(old, new [, max])</li></ul><p>把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</p><ul><li>rfind(str, beg=0,end=len(string))</li></ul><p>类似于 find()函数，不过是从右边开始查找。</p><ul><li>rindex( str, beg=0, end=len(string))</li></ul><p>类似于 index()，不过是从右边开始。</p><ul><li>rjust(width,[, fillchar])</li></ul><p>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串。</p><ul><li>rstrip([chars])</li></ul><p>删除字符串末尾的空格或指定字符。chars – 指定删除的字符（默认即缺省为空格）</p><ul><li>split(str=””, num=string.count(str))</li></ul><p>以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/2021091109162366.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>splitlines([keepends])</li></ul><p>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</p><ul><li>startswith(substr, beg=0,end=len(string))</li></ul><p>检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</p><ul><li>strip([chars])</li></ul><p>在字符串上执行 lstrip()和 rstrip()，chars – 指定删除的字符（默认即缺省为空格）</p><ul><li>swapcase()</li></ul><p>将字符串中大写转换为小写，小写转换为大写。</p><ul><li>title()</li></ul><p>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())。</p><ul><li>translate(table, deletechars=””)</li></ul><p>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中。</p><ul><li>upper()</li></ul><p>转换字符串中的小写字母为大写。</p><ul><li>zfill (width)</li></ul><p>返回长度为 width 的字符串，原字符串右对齐，前面填充0。</p><ul><li>isdecimal()</li></ul><p>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</p><p>函数print()和函数format()结合起来实现格式化输出，功能比较强大。</p><p>先给出基本示例：</p><pre><code class="python">print(&#39;李振兴告诉{}说 &quot;{}!&quot;&#39;.format(&#39;赵萌萌&#39;, &#39;加油&#39;))print(&#39;{0}和{1}是好朋友！&#39;.format(&#39;李振兴&#39;, &#39;赵萌萌&#39;))print(&#39;{1}和{0}是好朋友！&#39;.format(&#39;李振兴&#39;, &#39;赵萌萌&#39;))</code></pre><p>花括号及之内的字符（称为格式字段）被替换为传递给 str.format()方法的对象。花括号中的可有数字，花括号中的数字表示传递给 str.format() 方法的对象所在的位置。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/2021091015564850.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>​<p><strong>format()函数，</strong>可用于执行字符串格式化操作，更多情况，可参见 Python的输入函数input()和输出函数print()详解 <a href="https://blog.csdn.net/cnds123/article/details/118638607" target="_blank" rel="noopener">Python的输入函数input()和输出函数print()详解_cnds123的专栏-CSDN博客</a></p><p>下面给出给出一个字符串拼接示例：</p><p>可以使用加号、字符串方法join、格式化、通过F-string拼接。源码如下：</p><pre><code class="python">a = &quot;We&quot;b = &quot;learn&quot;c = &quot;Python&quot;s1 = a + &quot; &quot; + b + &quot; &quot; + c #通过+号拼接print(s1)seq = (a, b, c); # 字符串序列s2 = &quot; &quot;.join(seq)#通过 str.join()方法拼接print(s2)s3 = &quot;{0} {1} {2}&quot;.format(a,b,c)  #格式化拼接print(s3)s4 = f&quot;{a} {b} {c}&quot; #通过F-string拼接，适用于python3.6.2+版本print(s4)</code></pre><p>运行之，参见下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python中的字符串详解/20210911090257164.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>Unicode 概述 <a href="https://docs.python.org/zh-cn/3/howto/unicode.html" target="_blank" rel="noopener">Unicode 指南 — Python 3.9.7 文档</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/cnds123/article/details/120160535" target="_blank" rel="noopener">Python中的字符串详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【万字长文详解】Python库collections，让你击败99%的Pythoner</title>
      <link href="/2022/06/13/%E3%80%90%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E3%80%91Python%E5%BA%93collections%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%87%BB%E8%B4%A599%E7%9A%84Pythoner/"/>
      <url>/2022/06/13/%E3%80%90%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E3%80%91Python%E5%BA%93collections%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%87%BB%E8%B4%A599%E7%9A%84Pythoner/</url>
      
        <content type="html"><![CDATA[<p>Python的集合（collections）模块，为很多用其他方法很难实现的场景提供了解决方案。本文我们将会学习该模块的抽象概念是如何产生的，日后处理不同问题的过程中迟早会用得到这些知识。<br>免责声明：这篇文章是关于Python的一个相当高级的特性，如果你刚入门，建议先收藏，请等一等再学！<br>没想到这篇文章这么受欢迎， 修改优化下。</p><h3 id="一、模块概述"><a href="#一、模块概述" class="headerlink" title="一、模块概述"></a>一、模块概述</h3><h3 id="1、模块作用"><a href="#1、模块作用" class="headerlink" title="1、模块作用"></a>1、模块作用</h3><p><strong>官方说法：</strong>collections模块实现了特定目标的容器，以提供Python标准内建容器dict ,list , set , 和tuple的替代选择。<br><strong>通俗说法：</strong>Python内置的数据类型和方法，collections模块在这些内置类型的基础提供了额外的高性能数据类型，比如基础的字典是不支持顺序的，collections模块的OrderedDict类构建的字典可以支持顺序，collections模块的这些扩展的类用处非常大，熟练掌握该模块，可以大大简化Python代码，提高Python代码逼格和效率，<strong>高手入门必备。</strong></p><h3 id="2、模块资料"><a href="#2、模块资料" class="headerlink" title="2、模块资料"></a>2、模块资料</h3><p>关于该模块，官方的参考资料写的非常详细，也很有价值，大家可以参考<br>中文文档：<a href="https://link.zhihu.com/?target=https://docs.python.org/zh-cn/3/library/collections.html%23module-collections">https://docs.python.org/zh-cn/3/library/collections.html#module-collections</a><br>英文文档：<a href="https://link.zhihu.com/?target=https://docs.python.org/3/library/collections.html%23module-collections">https://docs.python.org/3/library/collections.html#module-collections</a></p><h3 id="3、模块子类"><a href="#3、模块子类" class="headerlink" title="3、模块子类"></a>3、模块子类</h3><p>用collections.__all__查看所有的子类，一共包含9个</p><pre><code class="python">import collectionsprint(collections.__all__)[&#39;deque&#39;, &#39;defaultdict&#39;, &#39;namedtuple&#39;, &#39;UserDict&#39;, &#39;UserList&#39;, &#39;UserString&#39;, &#39;Counter&#39;, &#39;OrderedDict&#39;, &#39;ChainMap&#39;]</code></pre><p>这个模块实现了特定目标的容器，以提供Python标准内建容器dict , list , set , 和tuple 的替代选择。 </p><table><thead><tr><th>namedtuple()</th><th>创建命名元组子类的工厂函数，生成可以使用名字来访问元素内容的tuple子类</th></tr></thead><tbody><tr><td>deque</td><td>类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)</td></tr><tr><td>ChainMap</td><td>类似字典(dict)的容器类，将多个映射集合到一个视图里面</td></tr><tr><td>Counter</td><td>字典的子类，提供了可哈希对象的计数功能</td></tr><tr><td>OrderedDict</td><td>字典的子类，保存了他们被添加的顺序，有序字典</td></tr><tr><td>defaultdict</td><td>字典的子类，提供了一个工厂函数，为字典查询提供一个默认值</td></tr><tr><td>UserDict</td><td>封装了字典对象，简化了字典子类化</td></tr><tr><td>UserList</td><td>封装了列表对象，简化了列表子类化</td></tr><tr><td>UserString</td><td>封装了字符串对象，简化了字符串子类化（中文版翻译有误）</td></tr></tbody></table><h3 id="二、计数器-Counter"><a href="#二、计数器-Counter" class="headerlink" title="二、计数器-Counter"></a>二、计数器-Counter</h3><h3 id="1、基础介绍"><a href="#1、基础介绍" class="headerlink" title="1、基础介绍"></a>1、基础介绍</h3><p>一个计数器工具提供快速和方便的计数，Counter是一个dict的子类，用于<strong>计数可哈希对象</strong>。它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。计数可以是任何整数值，包括0和负数，Counter类有点像其他语言中的bags或multisets。简单说，就是可以统计计数，来几个例子看看就清楚了，比如</p><pre><code class="python">#计算top10的单词from collections import Counterimport retext = &#39;remove an existing key one level down remove an existing key one level down&#39;words = re.findall(r&#39;\w+&#39;, text)Counter(words).most_common(10)[(&#39;remove&#39;, 2),(&#39;an&#39;, 2),(&#39;existing&#39;, 2),(&#39;key&#39;, 2),(&#39;one&#39;, 2)(&#39;level&#39;, 2),(&#39;down&#39;, 2)] #计算列表中单词的个数cnt = Counter()for word in [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;blue&#39;]:    cnt[word] += 1cntCounter({&#39;red&#39;: 2, &#39;blue&#39;: 3, &#39;green&#39;: 1})#上述这样计算有点嘛，下面的方法更简单，直接计算就行L = [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;blue&#39;] Counter(L)Counter({&#39;red&#39;: 2, &#39;blue&#39;: 3, &#39;green&#39;: 1}</code></pre><p>元素从一个iterable 被计数或从其他的mapping (or counter)初始化：</p><pre><code class="python">from collections import Counter#字符串计数Counter(&#39;gallahad&#39;) Counter({&#39;g&#39;: 1, &#39;a&#39;: 3, &#39;l&#39;: 2, &#39;h&#39;: 1, &#39;d&#39;: 1})#字典计数Counter({&#39;red&#39;: 4, &#39;blue&#39;: 2})  Counter({&#39;red&#39;: 4, &#39;blue&#39;: 2})#是个啥玩意计数Counter(cats=4, dogs=8)Counter({&#39;cats&#39;: 4, &#39;dogs&#39;: 8})Counter([&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;blue&#39;])Counter({&#39;red&#39;: 2, &#39;blue&#39;: 3, &#39;green&#39;: 1})</code></pre><p>计数器对象除了字典方法以外，还提供了三个其他的方法：</p><h3 id="1、elements"><a href="#1、elements" class="headerlink" title="1、elements()"></a>1、elements()</h3><p><strong>描述：</strong>返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于1，elements() 将会忽略它。<br><strong>语法：</strong>elements(  )<br><strong>参数：</strong>无</p><pre><code class="python">c = Counter(a=4, b=2, c=0, d=-2)list(c.elements())[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]sorted(c.elements())[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]c = Counter(a=4, b=2, c=0, d=5)list(c.elements())[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;]</code></pre><h3 id="2、most-common"><a href="#2、most-common" class="headerlink" title="2、most_common()"></a>2、most_common()</h3><p>返回一个列表，其中包含n个最常见的元素及出现次数，按常见程度由高到低排序。 如果 n 被省略或为None，most_common() 将返回计数器中的所有元素，计数值相等的元素按首次出现的顺序排序，经常用来计算top词频的词语。</p><pre><code class="python">Counter(&#39;abracadabra&#39;).most_common(3)[(&#39;a&#39;, 5), (&#39;b&#39;, 2), (&#39;r&#39;, 2)]Counter(&#39;abracadabra&#39;).most_common(5)[(&#39;a&#39;, 5), (&#39;b&#39;, 2), (&#39;r&#39;, 2), (&#39;c&#39;, 1), (&#39;d&#39;, 1)]</code></pre><h3 id="3、subtract"><a href="#3、subtract" class="headerlink" title="3、subtract()"></a>3、subtract()</h3><p>从迭代对象或映射对象减去元素。像dict.update() 但是是减去，而不是替换。输入和输出都可以是0或者负数。</p><pre><code class="python">c = Counter(a=4, b=2, c=0, d=-2)d = Counter(a=1, b=2, c=3, d=4)c.subtract(d)cCounter({&#39;a&#39;: 3, &#39;b&#39;: 0, &#39;c&#39;: -3, &#39;d&#39;: -6})#减去一个abcdstr0 = Counter(&#39;aabbccdde&#39;)str0Counter({&#39;a&#39;: 2, &#39;b&#39;: 2, &#39;c&#39;: 2, &#39;d&#39;: 2, &#39;e&#39;: 1})str0.subtract(&#39;abcd&#39;)str0Counter({&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;c&#39;: 1, &#39;d&#39;: 1, &#39;e&#39;: 1}</code></pre><h3 id="4、字典方法"><a href="#4、字典方法" class="headerlink" title="4、字典方法"></a>4、字典方法</h3><p>通常字典方法都可用于Counter对象，除了有两个方法工作方式与字典并不相同。<br><strong>fromkeys(iterable)</strong><br>这个类方法没有在Counter中实现。<br><strong>update([iterable-or-mapping])</strong><br>从迭代对象计数元素或者从另一个映射对象 (或计数器) 添加。 像 dict.update() 但是是加上，而不是替换。另外，迭代对象应该是序列元素，而不是一个 (key, value) 对。</p><pre><code class="python">sum(c.values())                 # total of all countsc.clear()                       # reset all countslist(c)                         # list unique elementsset(c)                          # convert to a setdict(c)                         # convert to a regular dictionaryc.items()                       # convert to a list of (elem, cnt) pairsCounter(dict(list_of_pairs))    # convert from a list of (elem, cnt) pairsc.most_common()[:-n-1:-1]       # n least common elements+c                              # remove zero and negative counts</code></pre><h3 id="5、数学操作"><a href="#5、数学操作" class="headerlink" title="5、数学操作"></a>5、数学操作</h3><p>这个功能非常强大，提供了几个数学操作，可以结合 Counter 对象，以生产 multisets (计数器中大于0的元素）。 加和减，结合计数器，通过加上或者减去元素的相应计数。交集和并集返回相应计数的最小或最大值。每种操作都可以接受带符号的计数，但是输出会忽略掉结果为零或者小于零的计数。</p><pre><code class="python">c = Counter(a=3, b=1)d = Counter(a=1, b=2)c + d                       # add two counters together:  c[x] + d[x]Counter({&#39;a&#39;: 4, &#39;b&#39;: 3})c - d                       # subtract (keeping only positive counts)Counter({&#39;a&#39;: 2})c &amp; d                       # intersection:  min(c[x], d[x]) Counter({&#39;a&#39;: 1, &#39;b&#39;: 1})c | d                       # union:  max(c[x], d[x])Counter({&#39;a&#39;: 3, &#39;b&#39;: 2})</code></pre><p>单目加和减（一元操作符）意思是从空计数器加或者减去。</p><pre><code class="python">c = Counter(a=2, b=-4)+cCounter({&#39;a&#39;: 2})-cCounter({&#39;b&#39;: 4})</code></pre><p>写一个计算文本相似的算法，加权相似</p><pre><code class="python">def str_sim(str_0,str_1,topn):    topn = int(topn)    collect0 = Counter(dict(Counter(str_0).most_common(topn)))    collect1 = Counter(dict(Counter(str_1).most_common(topn)))           jiao = collect0 &amp; collect1    bing = collect0 | collect1           sim = float(sum(jiao.values()))/float(sum(bing.values()))            return(sim)         str_0 = &#39;定位手机定位汽车定位GPS定位人定位位置查询&#39;         str_1 = &#39;导航定位手机定位汽车定位GPS定位人定位位置查询&#39;         str_sim(str_0,str_1,5)    0.75       </code></pre><h3 id="二、双向队列-deque"><a href="#二、双向队列-deque" class="headerlink" title="二、双向队列-deque"></a>二、双向队列-deque</h3><p>双端队列，可以快速的从另外一侧追加和推出对象,deque是一个双向链表，针对list连续的数据结构插入和删除进行优化。它提供了两端都可以操作的序列，这表示在序列的前后你都可以执行添加或删除操作。双向队列(deque)对象支持以下方法：</p><h3 id="1、append"><a href="#1、append" class="headerlink" title="1、append()"></a>1、append()</h3><p>添加 x 到右端。</p><pre><code class="python">d = deque(&#39;ghi&#39;)  d.append(&#39;j&#39;) ddeque([&#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;])</code></pre><h3 id="2、appendleft"><a href="#2、appendleft" class="headerlink" title="2、appendleft()"></a>2、appendleft()</h3><p>添加 x 到左端。</p><pre><code class="python">d.appendleft(&#39;f&#39;)ddeque([&#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;])</code></pre><h3 id="3、clear"><a href="#3、clear" class="headerlink" title="3、clear()"></a>3、clear()</h3><p>移除所有元素，使其长度为0.</p><pre><code class="python">d = deque(&#39;ghi&#39;)d.clear()ddeque([])</code></pre><h3 id="4、copy"><a href="#4、copy" class="headerlink" title="4、copy()"></a>4、copy()</h3><p>创建一份浅拷贝。</p><pre><code class="python">d = deque(&#39;xiaoweuge&#39;)y = d.copy()print(y)deque([&#39;x&#39;, &#39;i&#39;, &#39;a&#39;, &#39;o&#39;, &#39;w&#39;, &#39;e&#39;, &#39;u&#39;, &#39;g&#39;, &#39;e&#39;])</code></pre><h3 id="5、count"><a href="#5、count" class="headerlink" title="5、count()"></a>5、count()</h3><p>计算 deque 中元素等于 x 的个数。</p><pre><code class="python">d = deque(&#39;xiaoweuge-shuai&#39;)d.count(&#39;a&#39;)2</code></pre><h3 id="6、extend"><a href="#6、extend" class="headerlink" title="6、extend()"></a>6、extend()</h3><p>扩展deque的右侧，通过添加iterable参数中的元素。</p><pre><code class="python">a = deque(&#39;abc&#39;)b = deque(&#39;cd&#39;)a.extend(b)adeque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;])#与append 的区别a = deque(&#39;abc&#39;)b = deque(&#39;cd&#39;)a.append(b)deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, deque([&#39;c&#39;, &#39;d&#39;])])</code></pre><h3 id="7、extendleft"><a href="#7、extendleft" class="headerlink" title="7、extendleft()"></a>7、extendleft()</h3><p>扩展deque的左侧，通过添加iterable参数中的元素。注意，左添加时，在结果中iterable参数中的顺序将被反过来添加。</p><pre><code class="python">a = deque(&#39;abc&#39;)b = deque(&#39;cd&#39;)a.extendleft(b)adeque([&#39;d&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code></pre><h3 id="8、index"><a href="#8、index" class="headerlink" title="8、index()"></a>8、index()</h3><p>返回 x 在 deque 中的位置（在索引 start 之后，索引 stop 之前）。 返回第一个匹配项，如果未找到则引发 ValueError。</p><pre><code class="python">d = deque(&#39;xiaoweuge&#39;)d.index(&#39;w&#39;)4</code></pre><h3 id="9、insert"><a href="#9、insert" class="headerlink" title="9、insert()"></a>9、insert()</h3><p>在位置 i 插入 x 。<br>如果插入会导致一个限长 deque 超出长度 maxlen 的话，就引发一个 IndexError。</p><pre><code class="python">a = deque(&#39;abc&#39;)a.insert(1,&#39;X&#39;)deque([&#39;a&#39;, &#39;X&#39;, &#39;b&#39;, &#39;c&#39;])</code></pre><h3 id="10、pop"><a href="#10、pop" class="headerlink" title="10、pop()"></a>10、pop()</h3><p>移去并且返回一个元素，deque 最右侧的那一个。 如果没有元素的话，就引发一个 IndexError。</p><pre><code class="python">d.pop()      &#39;j&#39;</code></pre><h3 id="11、popleft"><a href="#11、popleft" class="headerlink" title="11、popleft()"></a>11、popleft()</h3><p>移去并且返回一个元素，deque 最左侧的那一个。 如果没有元素的话，就引发 IndexError。</p><pre><code class="python">d.popleft()&#39;f&#39;</code></pre><h3 id="12、remove-value"><a href="#12、remove-value" class="headerlink" title="12、remove(value)"></a>12、remove(value)</h3><p>移除找到的第一个 value。 如果没有的话就引发 ValueError。</p><pre><code class="python">a = deque(&#39;abca&#39;)a.remove(&#39;a&#39;)adeque([&#39;b&#39;, &#39;c&#39;, &#39;a&#39;])</code></pre><h3 id="13、reverse"><a href="#13、reverse" class="headerlink" title="13、reverse()"></a>13、reverse()</h3><p>将deque逆序排列。返回 None 。</p><pre><code class="python">#逆序排列d = deque(&#39;ghi&#39;) # 创建一个dequelist(reversed(d))[&#39;i&#39;, &#39;h&#39;, &#39;g&#39;]deque(reversed(d))deque([&#39;i&#39;, &#39;h&#39;, &#39;g&#39;])</code></pre><h3 id="14、rotate-n-1"><a href="#14、rotate-n-1" class="headerlink" title="14、rotate(n=1)"></a>14、rotate(n=1)</h3><p>向右循环移动 n 步。 如果 n 是负数，就向左循环。<br>如果deque不是空的，向右循环移动一步就等价于 d.appendleft(d.pop()) ， 向左循环一步就等价于 d.append(d.popleft()) 。</p><pre><code class="python"># 向右边挤一挤d = deque(&#39;ghijkl&#39;)d.rotate(1)                      ddeque([&#39;l&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;])# 向左边挤一挤d.rotate(-1)                     ddeque([&#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;])#看一个更明显的x = deque(&#39;12345&#39;)xdeque([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;])x.rotate()xdeque([&#39;5&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;])d = deque([&#39;12&#39;,&#39;av&#39;,&#39;cd&#39;])d.rotate(1)deque([&#39;cd&#39;, &#39;12&#39;, &#39;av&#39;</code></pre><h3 id="15、maxlen"><a href="#15、maxlen" class="headerlink" title="15、maxlen"></a>15、maxlen</h3><p>Deque的最大尺寸，如果没有限定的话就是 None 。</p><pre><code class="python">from collections import dequed=deque(maxlen=10)for i in range(20):   d.append(i)d  deque([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])</code></pre><p>除了以上操作，deque还支持迭代、封存、len(d)、reversed(d)、copy.deepcopy(d)、copy.copy(d)、成员检测运算符 in 以及下标引用例如通过 d[0] 访问首个元素等。 索引访问在两端的复杂度均为 O(1) 但在中间则会低至 O(n)。 如需快速随机访问，请改用列表。<br>Deque从版本3.5开始支持 <strong>add</strong>(), <strong>mul</strong>(), 和 <strong>imul</strong>() 。 </p><pre><code class="python">from collections import dequed = deque(&#39;ghi&#39;)                 # 创建一个dequefor elem in d:    print(elem.upper())GHI#从右边添加一个元素d.append(&#39;j&#39;)d   deque([&#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;])#从左边添加一个元素d.appendleft(&#39;f&#39;)d deque([&#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;])#右边删除d.pop()                          &#39;j&#39;#左边边删除d.popleft()&#39;f&#39;#看看还剩下啥list(d)                          # [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;]#成员检测&#39;h&#39; in d                         True#添加多个元素d.extend(&#39;jkl&#39;)              ddeque([&#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;])d.clear()                        # empty the dequed.pop()                          # cannot pop from an empty dequeTraceback (most recent call last):    File &quot;&lt;pyshell#6&gt;&quot;, line 1, in -toplevel-        d.pop()IndexError: pop from an empty dequed.extendleft(&#39;abc&#39;)              # extendleft() reverses the input orderddeque([&#39;c&#39;, &#39;b&#39;, </code></pre><h3 id="三、有序字典-OrderedDict"><a href="#三、有序字典-OrderedDict" class="headerlink" title="三、有序字典-OrderedDict"></a>三、有序字典-OrderedDict</h3><p>有序词典就像常规词典一样，但有一些与排序操作相关的额外功能,popitem() 方法有不同的签名。它接受一个可选参数来指定弹出哪个元素。move_to_end() 方法，可以有效地将元素移动到任一端。<br>有序词典就像常规词典一样，但有一些与排序操作相关的额外功能。由于内置的 dict 类获得了记住插入顺序的能力（在 Python 3.7 中保证了这种新行为），它们变得不那么重要了。<br>一些与 dict 的不同仍然存在：</p><ul><li>常规的 dict 被设计为非常擅长映射操作。 跟踪插入顺序是次要的。</li><li>OrderedDict 旨在擅长重新排序操作。 空间效率、迭代速度和更新操作的性能是次要的。</li><li>算法上， OrderedDict 可以比 dict 更好地处理频繁的重新排序操作。 这使其适用于跟踪最近的访问（例如在 <a href="https://link.zhihu.com/?target=https://medium.com/@krishankantsinghal/my-first-blog-on-medium-583159139237">LRU cache</a> 中）。</li><li>对于 OrderedDict ，相等操作检查匹配顺序。</li><li>OrderedDict 类的 popitem() 方法有不同的签名。它接受一个可选参数来指定弹出哪个元素。</li><li>OrderedDict 类有一个 move_to_end() 方法，可以有效地将元素移动到任一端。</li><li>Python 3.8之前， dict 缺少 <strong>reversed</strong>() 方法。</li></ul><table><thead><tr><th>传统字典方法</th><th>OrderedDict方法</th><th>差异</th></tr></thead><tbody><tr><td>clear</td><td>clear</td><td></td></tr><tr><td>copy</td><td>copy</td><td></td></tr><tr><td>fromkeys</td><td>fromkeys</td><td></td></tr><tr><td>get</td><td>get</td><td></td></tr><tr><td>items</td><td>items</td><td></td></tr><tr><td>keys</td><td>keys</td><td></td></tr><tr><td>pop</td><td>pop</td><td></td></tr><tr><td>popitem</td><td>popitem</td><td>OrderedDict   类的 popitem() 方法有不同的签名。它接受一个可选参数来指定弹出哪个元素。</td></tr><tr><td>setdefault</td><td>setdefault</td><td></td></tr><tr><td>update</td><td>update</td><td></td></tr><tr><td>values</td><td>values</td><td></td></tr><tr><td></td><td>move_to_end</td><td>可以有效地将元素移动到任一端。</td></tr></tbody></table><h3 id="1、popitem"><a href="#1、popitem" class="headerlink" title="1、popitem"></a>1、popitem</h3><p>语法：popitem(last=True)<br>功能：有序字典的 popitem() 方法移除并返回一个 (key, value) 键值对。 如果 last 值为真，则按 LIFO 后进先出的顺序返回键值对，否则就按 FIFO 先进先出的顺序返回键值对。</p><pre><code class="python">from collections import OrderedDictd = OrderedDict.fromkeys(&#39;abcde&#39;)d.popitem() (&#39;e&#39;, None)dOrderedDict([(&#39;a&#39;, None), (&#39;b&#39;, None), (&#39;c&#39;, None), (&#39;d&#39;, None)])#last=False时，弹出第一个d = OrderedDict.fromkeys(&#39;abcde&#39;)&#39;&#39;.join(d.keys())&#39;abcde&#39;d.popitem(last=False)&#39;&#39;.join(d.keys())&#39;bcde&#39;</code></pre><h3 id="2、move-to-end"><a href="#2、move-to-end" class="headerlink" title="2、move_to_end"></a>2、move_to_end</h3><pre><code class="python">from collections import OrderedDictd = OrderedDict.fromkeys(&#39;abcde&#39;)d.move_to_end(&#39;b&#39;)&#39;&#39;.join(d.keys())&#39;acdeb&#39;dOrderedDict([(&#39;a&#39;, None), (&#39;c&#39;, None), (&#39;d&#39;, None), (&#39;e&#39;, None), (&#39;b&#39;, None)])d.move_to_end(&#39;b&#39;, last=False)&#39;&#39;.join(d.keys())&#39;bacde&#39;</code></pre><h3 id="3、reversed"><a href="#3、reversed" class="headerlink" title="3、reversed()"></a>3、reversed()</h3><p>相对于通常的映射方法，有序字典还另外提供了逆序迭代的支持，通过reversed() 。 </p><pre><code class="python">d = OrderedDict.fromkeys(&#39;abcde&#39;)list(reversed(d))[&#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</code></pre><h3 id="四、可命名元组-namedtuple"><a href="#四、可命名元组-namedtuple" class="headerlink" title="四、可命名元组-namedtuple"></a>四、可命名元组-namedtuple</h3><p>生成可以使用名字来访问元素内容的tuple子类，命名元组赋予每个位置一个含义，提供可读性和自文档性。它们可以用于任何普通元组，并添加了通过名字获取值的能力，通过索引值也是可以的。</p><h3 id="1、参数介绍"><a href="#1、参数介绍" class="headerlink" title="1、参数介绍"></a>1、参数介绍</h3><p>namedtuple(typename,field_names,*,verbose=False, rename=False, module=None)<br>1）typename：该参数指定所创建的tuple子类的类名，相当于用户定义了一个新类。<br>2）field_names：该参数是一个字符串序列，如 [‘x’，’y’]。此外，field_names 也可直接使用单个字符串代表所有字段名，多个字段名用空格、逗号隔开，如 ‘x y’ 或 ‘x,y’。任何有效的 Python 标识符都可作为字段名（不能以下画线开头）。有效的标识符可由字母、数字、下画线组成，但不能以数字、下面线开头，也不能是关键字（如 return、global、pass、raise 等）。<br>3）rename：如果将该参数设为 True，那么无效的字段名将会被自动替换为位置名。例如指定 [‘abc’,’def’,’ghi’,’abc’]，它将会被替换为 [‘abc’, ‘_1’,’ghi’,’_3’]，这是因为 def 字段名是关键字，而 abc 字段名重复了。<br>4）verbose：如果该参数被设为 True，那么当该子类被创建后，该类定义就被立即打印出来。<br>5）module：如果设置了该参数，那么该类将位于该模块下，因此该自定义类的 <strong>module</strong> 属性将被设为该参数值。</p><h3 id="2、应用案例"><a href="#2、应用案例" class="headerlink" title="2、应用案例"></a>2、应用案例</h3><p>1）水族箱案例<br>Python元组是一个不可变的，或不可改变的，有序的元素序列。元组经常用来表示纵列数据;例如，一个CSV文件中的行数或一个SQL数据库中的行数。一个水族箱可以用一系列元组来记录它的鱼类的库存。<br>一个单独的鱼类元组:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-efa2efb16a4e3a24b191bf866281836b_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个元组由三个字符串元素组成。<br>虽然在某些方面很有用，但是这个元组并没有清楚地指明它的每个字段代表什么。实际上，元素0是一个名称，元素1是一个物种，元素2是一个饲养箱。<br>鱼类元组字段说明:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-de3e2a13b4a1524a0b3cb42d18346ad4_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个表清楚地表明，该元组的三个元素都有明确的含义。<br>来自collections模块的namedtuple允许你向一个元组的每个元素添加显式名称，以便在你的Python程序中明确这些元素的含义。<br>让我们使用namedtuple来生成一个类，从而明确地命名鱼类元组的每个元素:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-6feda1c80a14993793c335c93d667262_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><pre><code class="python">from collections import namedtuple </code></pre><p>可以让你的Python程序访问namedtuple工厂函数。namedtuple()函数调用会返回一个绑定到名称Fish的类。namedtuple()函数有两个参数:我们的新类“Fish”的期望名称和命名元素[“name”、”species”、“tank”]的一个列表。<br>我们可以使用Fish类来表示前面的鱼类元组:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-e8975db7e7c2f9d0de2e1faa7427ba83_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果我们运行这段代码，我们将看到以下输出:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-168252851c2344011745913d8b8330b7_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>sammy是使用Fish类进行实例化的。sammy是一个具有三个明确命名元素的元组。<br>sammy的字段可以通过它们的名称或者一个传统的元组索引来访问:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-ba1c11aa62529004b8b20b5507c8b371_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果我们运行这两个print调用，我们将看到以下输出:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-0c90981e53acc01aac99f161467407cf_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>访问.species会返回与使用[1]访问sammy的第二个元素相同的值。<br>使用collections模块中的namedtuple可以在维护元组(即它们是不可变的、有序的)的重要属性的同时使你的程序更具可读性。<br>此外，namedtuple工厂函数还会向Fish实例添加几个额外的方法。<br>使用._asdict()将一个实例转换为字典:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-6d8e3cd1dbf4186e0e24620b884bcf3c_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果我们运行print，你会看到如下输出:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-8f982aebadbbea91fffd8b63922813e3_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在sammy上调用.asdict()将返回一个字典，该字典会将三个字段名称分别映射到它们对应的值。<br>大于3.8的Python版本输出这一行的方式可能略有不同。例如，你可能会看到一个OrderedDict，而不是这里显示的普通字典。<br>2）加法器案例</p><pre><code class="python">from collections import namedtuple# 定义命名元组类：PointPoint = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])# 初始化Point对象，即可用位置参数，也可用命名参数p = Point(11, y=22)# 像普通元组一样用根据索引访问元素print(p[0] + p[1]) 33#执行元组解包，按元素的位置解包a, b = pprint(a, b) 11, 22#根据字段名访问各元素print(p.x + p.y) 33print(p) Point(x=11, y=22)</code></pre><h3 id="3、三个方法"><a href="#3、三个方法" class="headerlink" title="3、三个方法"></a>3、三个方法</h3><p>备注: 在Python中，带有前导下划线的方法通常被认为是“私有的”。但是，namedtuple提供的其他方法(如._asdict()、._make()、._replace()等)是公开的。<br>除了继承元组的方法，命名元组还支持三个额外的方法和两个属性。为了防止字段名冲突，方法和属性以下划线开始。</p><h4 id="make-iterable"><a href="#make-iterable" class="headerlink" title="_make(iterable)"></a>_make(iterable)</h4><p>类方法从存在的序列或迭代实例创建一个新实例。</p><pre><code class="python">t = [14, 55]Point._make(t)</code></pre><h4 id="asdict"><a href="#asdict" class="headerlink" title="_asdict()"></a>_asdict()</h4><p>返回一个新的 dict ，它将字段名称映射到它们对应的值：</p><pre><code class="python">p = Point(x=11, y=22)p._asdict()OrderedDict([(&#39;x&#39;, 11), (&#39;y&#39;, 22)])</code></pre><h4 id="replace-kwargs"><a href="#replace-kwargs" class="headerlink" title="_replace(**kwargs)"></a>_replace(**kwargs)</h4><p>返回一个新的命名元组实例，并将指定域替换为新的值</p><pre><code class="python">p = Point(x=11, y=22)p._replace(x=33)Point(x=33, y=22)</code></pre><h3 id="4、两个属性"><a href="#4、两个属性" class="headerlink" title="4、两个属性"></a>4、两个属性</h3><p><strong>_fields</strong><br>字符串元组列出了字段名。用于提醒和从现有元组创建一个新的命名元组类型。</p><pre><code class="python">p._fields            # view the field names(&#39;x&#39;, &#39;y&#39;)Color = namedtuple(&#39;Color&#39;, &#39;red green blue&#39;)Pixel = namedtuple(&#39;Pixel&#39;, Point._fields + Color._fields)Pixel(11, 22, 128, 255, 0)Pixel(x=11, y=22, red=128, green=255, blue=0)</code></pre><p><strong>_field_defaults</strong><br>字典将字段名称映射到默认值。</p><pre><code class="python">Account = namedtuple(&#39;Account&#39;, [&#39;type&#39;, &#39;balance&#39;], defaults=[0])Account._field_defaults{&#39;balance&#39;: 0}Account(&#39;premium&#39;)Account(type=&#39;premium&#39;, balance=0)</code></pre><h3 id="5、其他函数"><a href="#5、其他函数" class="headerlink" title="5、其他函数"></a>5、其他函数</h3><p><strong>getattr()</strong><br>要获取这个名字域的值，使用 getattr() 函数 : </p><pre><code class="python">getattr(p, &#39;x&#39;)11</code></pre><p>转换一个字典到命名元组，使用 ** 两星操作符</p><pre><code class="python">d = {&#39;x&#39;: 11, &#39;y&#39;: 22}Point(**d)Point(x=11, y=22)</code></pre><p>因为一个命名元组是一个正常的Python类，它可以很容易的通过子类更改功能。这里是如何添加一个计算域和定宽输出打印格式:</p><pre><code class="python">class Point(namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])):    __slots__ = ()    @property    def hypot(self):                return (self.x ** 2 + self.y ** 2) ** 0.5    def __str__(self):        return &#39;Point: x=%6.3f  y=%6.3f  hypot=%6.3f&#39; % (self.x, self.y, self.hypot)for p in Point(3, 4), Point(14, 5/7):     print(p)Point: x= 3.000  y= 4.000  hypot= 5.000Point: x=14.000  y= 0.714  hypot=14.018</code></pre><h3 id="五、默认字典-defaultdict"><a href="#五、默认字典-defaultdict" class="headerlink" title="五、默认字典-defaultdict"></a>五、默认字典-defaultdict</h3><p>在Python字典中收集数据通常是很有用的。<br>在字典中获取一个 key 有两种方法, 第一种 get , 第二种 通过 [] 获取.<br><strong>使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict。</strong><br>当我使用普通的字典时，用法一般是dict={},添加元素的只需要dict[element] =value即，调用的时候也是如此，dict[element] = xxx,但前提是element字典里，如果不在字典里就会报错<br>这时defaultdict就能排上用场了，defaultdict的作用是在于，当字典里的key不存在但被查找时，返回的不是keyError而是一个默认值，这个默认值是什么呢，下面会说</p><h3 id="1、基础介绍-1"><a href="#1、基础介绍-1" class="headerlink" title="1、基础介绍"></a>1、基础介绍</h3><p><strong>defaultdict([default_factory[, …]])</strong><br>返回一个新的类似字典的对象。 defaultdict是内置dict类的子类。它重载了一个方法并添加了一个可写的实例变量。其余的功能与dict类相同，此处不再重复说明。<br>本对象包含一个名为default_factory的属性，构造时，第一个参数用于为该属性提供初始值，默认为 None。所有其他参数（包括关键字参数）都相当于传递给 dict 的构造函数。<br>defaultdict 对象除了支持标准 dict 的操作，还支持以下方法作为扩展：<br><strong><strong>missing</strong>(key)</strong><br>如果 default_factory 属性为 None，则调用本方法会抛出 KeyError 异常，附带参数 key。<br>如果 default_factory 不为 None，则它会被（不带参数地）调用来为 key 提供一个默认值，这个值和 key 作为一对键值对被插入到字典中，并作为本方法的返回值返回。<br>如果调用 default_factory 时抛出了异常，这个异常会原封不动地向外层传递。<br>在无法找到所需键值时，本方法会被 dict 中的 <strong>getitem</strong>() 方法调用。无论本方法返回了值还是抛出了异常，都会被 <strong>getitem</strong>() 传递。<br>注意，<strong>missing</strong>() 不会 被 <strong>getitem</strong>() 以外的其他方法调用。意味着 get() 会像正常的 dict 那样返回 None，而不是使用 default_factory。</p><h3 id="2、示例介绍"><a href="#2、示例介绍" class="headerlink" title="2、示例介绍"></a>2、示例介绍</h3><p>使用 list 作为 default_factory，很轻松地将（键-值对组成的）序列转换为（键-列表组成的）字典 </p><pre><code class="python">s  = [(&#39;yellow&#39;, 1), (&#39;blue&#39;, 2), (&#39;yellow&#39;, 3), (&#39;blue&#39;, 4), (&#39;red&#39;, 1)]d = defaultdict(list)for k, v in s:    d[k].append(v)sorted(d.items())[(&#39;blue&#39;, [2, 4]), (&#39;red&#39;, [1]), (&#39;yellow&#39;, [1, 3])]</code></pre><p>当每个键第一次遇见时，它还没有在字典里面，所以自动创建该条目，即调用default_factory方法，返回一个空的 list。 list.append() 操作添加值到这个新的列表里。当再次存取该键时，就正常操作，list.append() 添加另一个值到列表中。这个计数比它的等价方法dict.setdefault()要快速和简单： </p><pre><code class="python">s = [(&#39;yellow&#39;, 1), (&#39;blue&#39;, 2), (&#39;yellow&#39;, 3), (&#39;blue&#39;, 4), (&#39;red&#39;, 1)]d = {}for k, v in s:    d.setdefault(k, []).append(v)sorted(d.items())[(&#39;blue&#39;, [2, 4]), (&#39;red&#39;, [1]), (&#39;yellow&#39;, [1, 3])]</code></pre><p>设置 default_factory为int，使defaultdict用于计数（类似其他语言中的 bag或multiset）： </p><pre><code class="python">s = &#39;mississippi&#39;d = defaultdict(int)for k in s:    d[k] += 1sorted(d.items()) [(&#39;i&#39;, 4), (&#39;m&#39;, 1), (&#39;p&#39;, 2), (&#39;s&#39;, 4)]</code></pre><p>设置 default_factory 为 set 使 defaultdict 用于构建 set 集合： </p><pre><code class="python">s = [(&#39;red&#39;, 1), (&#39;blue&#39;, 2), (&#39;red&#39;, 3), (&#39;blue&#39;, 4), (&#39;red&#39;, 1), (&#39;blue&#39;, 4)]d = defaultdict(set)for k, v in s:    d[k].add(v)sorted(d.items())[(&#39;blue&#39;, {2, 4}), (&#39;red&#39;, {1, 3})]</code></pre><p>defaultdict绝不会引发一个KeyError。如果一个键不存在，defaultdict会插入并返回一个占位符值来代替:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-e9411272b33c99cdfe9b78c9d03f9b90_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果我们运行这段代码，我们将看到如下输出:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-520a3b53ca349a4c1e821d044d850dce_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>defaultdict会插入并返回一个占位符值，而不是引发一个KeyError。在本例中，我们将占位符值指定为一个列表。<br>相比之下，常规字典会在缺失的键上引发一个KeyError:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-76d68d5bc235feea862299e4159a0ce5_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果我们运行这段代码，我们将看到如下输出:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-520a3b53ca349a4c1e821d044d850dce_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当我们试图访问一个不存在的键时，常规字典my_regular_dict会引发一个KeyError。<br>defaultdict的行为与常规字典不同。defaultdict会不带任何参数调用占位符值来创建一个新对象，而不是在缺失的键上引发一个KeyError。在本例中，是调用list()创建一个空列表。<br>继续我们虚构的水族箱示例，假设我们有一个表示水族箱清单的鱼类元组列表:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-3c82b2b94a06a00daee8ee56f0a3b722_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>水族箱中有三种鱼——它们的名字、种类和饲养箱在这三个元组中都有指出。<br>我们的目标是按饲养箱组织我们的清单—我们想知道每个饲养箱中存在的鱼的列表。换句话说，我们需要一个能将“tank-a”映射到[“Jamie”, “Mary”] ，并且将“tank-b”映射到[“Jamie”]的字典。<br>我们可以使用defaultdict来按饲养箱对鱼进行分组:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-dfc8d0750c881756d3bd6c6335c5e08f_b.octet-stream" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>运行这段代码，我们将看到以下输出:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-ef4f16054ebda651b702ca60191c880f_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>fish_names_by_tank被声明为一个defaultdict，它默认会插入list()而不是引发一个KeyError。由于这保证了fish_names_by_tank中的每个键都将指向一个list，所以我们可以自由地调用.append()来将名称添加到每个饲养箱的列表中。<br>这里，defaultdict帮助你减少了出现未预期的KeyErrors的机会。减少未预期的KeyErrors意味着你可以用更少的行更清晰地编写你的程序。更具体地说，defaultdict习惯用法让你避免了手动地为每个饲养箱实例化一个空列表。<br>如果没有 defaultdict, for循环体可能看起来更像这样:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-61edd6a75a4588ea47ffb8bce558f4cd_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用常规字典(而不是defaultdict)意味着for循环体总是必须检查fish_names_by_tank中给定的tank是否存在。只有在验证了fish_names_by_tank中已经存在tank，或者已经使用一个[]初始化了tank之后，我们才可以添加鱼类名称。<br>在填充字典时，defaultdict可以帮助我们减少样板代码，因为它从不引发KeyError。</p><h3 id="六、映射链-ChainMap"><a href="#六、映射链-ChainMap" class="headerlink" title="六、映射链-ChainMap"></a>六、映射链-ChainMap</h3><h3 id="1、ChainMap是什么"><a href="#1、ChainMap是什么" class="headerlink" title="1、ChainMap是什么"></a>1、ChainMap是什么</h3><p>ChainMap最基本的使用，可以用来合并两个或者更多个字典，当查询的时候，从前往后依次查询。<br><strong>ChainMap：将多个字典视为一个，解锁Python超能力。</strong><br>ChainMap是由Python标准库提供的一种数据结构，允许你将多个字典视为一个。换句话说:<strong>ChainMap是一个基于多dict的可更新的视图，它的行为就像一个普通的dict。</strong><br>ChainMap类用于快速链接多个映射，以便将它们视为一个单元。它通常比创建新字典和多次调用update()快得多。<br>你以前可能从来没有听说过ChainMap，你可能会认为ChainMap的使用情况是非常特定的。坦率地说，你是对的。<br>我知道的用例包括：</p><ul><li>通过多个字典搜索</li><li>提供链缺省值</li><li>经常计算字典子集的性能关键的应用程序</li></ul><h3 id="2、特性"><a href="#2、特性" class="headerlink" title="2、特性"></a>2、特性</h3><p>1）找到一个就不找了：这个列表是按照第一次搜索到最后一次搜索的顺序组织的，搜索查询底层映射，直到一个键被找到。<br>2）更新原始映射：不同的是，写，更新和删除只操作第一个映射。<br>3）支持所有常用字典方法。<br>简而言之ChainMap：将多个字典视为一个，解锁Python超能力。<br>Python标准库中的集合模块包含许多为性能而设计的实用的数据结构。著名的包括命名元组或计数器。<br>今天，通过实例，我们来看看鲜为人知的<strong>ChainMap</strong>。通过浏览具体的示例，我希望给你一个提示，关于在更高级的Python工作中使用ChainMap将如何从中受益。</p><h3 id="3、应用案例-基础案例"><a href="#3、应用案例-基础案例" class="headerlink" title="3、应用案例-基础案例"></a>3、应用案例-基础案例</h3><pre><code class="python">from collections import ChainMap baseline = {&#39;music&#39;: &#39;bach&#39;, &#39;art&#39;: &#39;rembrandt&#39;}adjustments = {&#39;art&#39;: &#39;van gogh&#39;, &#39;opera&#39;: &#39;carmen&#39;}ChainMap(adjustments, baseline)ChainMap({&#39;art&#39;: &#39;van gogh&#39;, &#39;opera&#39;: &#39;carmen&#39;}, {&#39;music&#39;: &#39;bach&#39;, &#39;art&#39;: &#39;rembrandt&#39;})list(ChainMap(adjustments, baseline))[&#39;music&#39;, &#39;art&#39;, &#39;opera&#39;]#存在重复元素时，也不会去重dcic1 = {&#39;label1&#39;: &#39;11&#39;, &#39;label2&#39;: &#39;22&#39;}dcic2 = {&#39;label2&#39;: &#39;22&#39;, &#39;label3&#39;: &#39;33&#39;}dcic3 = {&#39;label4&#39;: &#39;44&#39;, &#39;label5&#39;: &#39;55&#39;}last  = ChainMap(dcic1, dcic2,dcic3)last  ChainMap({&#39;label1&#39;: &#39;11&#39;, &#39;label2&#39;: &#39;22&#39;}, {&#39;label2&#39;: &#39;22&#39;, &#39;label3&#39;: &#39;33&#39;}, {&#39;label4&#39;: &#39;44&#39;, &#39;label5&#39;: &#39;55&#39;})</code></pre><h4 id="new-child-方法"><a href="#new-child-方法" class="headerlink" title="new_child()方法"></a>new_child()方法</h4><p>用法：new_child(m=None)<br>返回一个新的ChainMap类，包含了一个新映射(map)，后面跟随当前实例的全部映射map。如果m被指定，它就成为不同新的实例，就是在所有映射前加上 m，如果没有指定，就加上一个空字典，这样的话一个 d.new_child() 调用等价于ChainMap({}, *d.maps) 。这个方法用于创建子上下文，不改变任何父映射的值。</p><pre><code class="python">last.new_child(m={&#39;key_new&#39;:888})ChainMap({&#39;key_new&#39;: 888}, {&#39;label1&#39;: &#39;11&#39;, &#39;label2&#39;: &#39;22&#39;}, {&#39;label2&#39;: &#39;22&#39;, &#39;label3&#39;: &#39;33&#39;}, {&#39;label4&#39;: &#39;44&#39;, &#39;label5&#39;: &#39;55&#39;})</code></pre><h4 id="parents属性"><a href="#parents属性" class="headerlink" title="parents属性"></a>parents属性</h4><p>属性返回一个新的ChainMap包含所有的当前实例的映射，除了第一个。这样可以在搜索的时候跳过第一个映射。使用的场景类似在 <a href="https://link.zhihu.com/?target=https://docs.python.org/zh-cn/3/glossary.html%23term-nested-scope">nested scopes</a> 嵌套作用域中使用nonlocal关键词。用例也可以类比内建函数super() 。一个d.parents 的引用等价于ChainMap(*d.maps[1:]) 。</p><pre><code class="python">last.parentsChainMap({&#39;label2&#39;: &#39;22&#39;, &#39;label3&#39;: &#39;33&#39;}, {&#39;label4&#39;: &#39;44&#39;, &#39;label5&#39;: &#39;55&#39;})</code></pre><h3 id="4、应用案例-购物清单"><a href="#4、应用案例-购物清单" class="headerlink" title="4、应用案例-购物清单"></a>4、应用案例-购物清单</h3><p>作为使用ChainMap的第一个例子，让我们考虑一张购物清单。我们的清单可能包含玩具，电脑，甚至衣服。所有这些条目都有价格，所以我们将把我们的条目存储在名称价格映射中。</p><pre><code class="python">toys = {&#39;Blocks&#39;:30,&#39;Monopoly&#39;:20}computers = {&#39;iMac&#39;:1000,&#39;Chromebook&#39;:1000,&#39;PC&#39;:400}clothing = {&#39;Jeans&#39;:40,&#39;T-shirt&#39;:10}</code></pre><p>现在我们可以使用ChainMap在这些不同的集合上建立一个单一的视图：</p><pre><code class="python">from collections import ChainMapinventory = ChainMap(toys,computers,clothing)</code></pre><p>这使得我们可以查询清单，就像它是一个单一的字典：</p><pre><code class="python">inventory[&#39;Monopoly&#39;]20inventory[&#39;Jeans&#39;]40</code></pre><p>正如官方文档所述，ChainMap支持所有常用的字典方法。我们可以使用.get()来搜索可能不存在的条目，或者使用 .pop()删除条目。</p><pre><code class="python">inventory.get(&#39;Blocks-1&#39;)Noneinventory.get(&#39;Chromebook&#39;)1000inventory.pop(&#39;Blocks&#39;)inventoryChainMap({&#39;Monopoly&#39;: 20}, {&#39;iMac&#39;: 1000, &#39;Chromebook&#39;: 1000, &#39;PC&#39;: 400}, {&#39;Jeans&#39;: 40, &#39;T-shirt&#39;: 10})</code></pre><p>如果我们现在把玩具添加到toys字典里，它也将在清单中可用。这是ChainMap的可更新的方面。</p><pre><code class="python">toys[&#39;Nintendo&#39;] = 20inventory[&#39;Nintendo&#39;]20</code></pre><p>Oh和ChainMap有一个恰当的字符串表示形式：</p><pre><code class="python">str(inventory)&quot;ChainMap({&#39;Monopoly&#39;: 20, &#39;Nintendo&#39;: 20}, {&#39;iMac&#39;: 1000, &#39;Chromebook&#39;: 1000, &#39;PC&#39;: 400}, {&#39;Jeans&#39;: 40, &#39;T-shirt&#39;: 10})&quot;</code></pre><p>一个很好的特点是，在我们的例子中，toys, computers和clothing都是在相同的上下文中（解释器），它们可以来自完全不同的模块或包。这是因为ChainMap通过引用存储底层字典。<br>第一个例子是使用ChainMap一次搜索多个字典。<br>事实上，当构建ChainMap时，我们所做的就是有效地构建一系列字典。当查找清单中的一个项时，toys首先被查找，然后是computers，最后是clothing。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-d679e081f5420e6fb13b2daef2feaee4_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>ChainMap真的只是一个映射链！<br><strong>实际上，ChainMap的另一个任务是维护链的默认值。</strong><br>我们将以一个命令行应用程序的例子来说明这是什么意思。</p><h3 id="5、应用案例-CLI配置"><a href="#5、应用案例-CLI配置" class="headerlink" title="5、应用案例-CLI配置"></a>5、应用案例-CLI配置</h3><p>让我们面对现实，管理命令行应用程序的配置可能是困难的。配置来自多个源：命令行参数、环境变量、本地文件等。<br>我们通常实施<strong>优先级</strong>的概念：如果A和B都定义参数P，A的P值将被使用，因为它的优先级高于B。<br>例如，如果传递了命令行参数，我们可能希望在环境变量上使用命令行参数。如何轻松地管理配置源的优先级？<br>一个答案是将所有配置源存储在ChainMap中。<br><strong>因为ChainMap中的查找是按顺序连续地对每个底层映射执行的</strong>（按照他们传给构造函数的顺序），所以我们可以很容易地实现我们寻找的优先级。<br>下面是一个简单的命令行应用程序。调试参数从命令行参数、环境变量或硬编码默认值中提取：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-c69ecbd6433f66bb29a25079a89ad8fb_b.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在执行脚本时，我们可以检查是否首先在命令行参数中查找debug，然后是环境变量，最后是默认值：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/【万字长文详解】Python库collections，让你击败99%的Pythoner/v2-0f9bcf49cd958ec597af013c8b5bc7bd_b.octet-stream" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这样看上去就非常整洁，对吧？</p><h3 id="6、我为什么关心？"><a href="#6、我为什么关心？" class="headerlink" title="6、我为什么关心？"></a>6、我为什么关心？</h3><p>坦率地说，ChainMap是那些你可以忽略的Python特性之一。<br>还有其他ChainMap的替代方案。例如，使用更新循环—例如创建一个dict并用字典update()它—可能奏效。但是，这只有在您不需要跟踪项目的起源时才有效，就像我们的多源CLI配置示例中的情况一样。<strong>但是，当你知道ChainMap存在的时候，ChainMap可以让你更轻松，你的代码更优雅。</strong></p><h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><p>总而言之，我们一起看了ChainMap是什么，一些具体的使用示例，以及如何在现实生活中，性能关键的应用程序中使用ChainMap。如果您想了解更多关于Python的高性能数据容器的信息，请务必从Python的标准库中collections模块中查看其他出色类和函数。</p><h3 id="七、UserDict"><a href="#七、UserDict" class="headerlink" title="七、UserDict"></a>七、UserDict</h3><p>UserDict类是用作字典对象的外包装。对这个类的需求已部分由直接创建dict的子类的功能所替代；不过这个类处理起来更容易，因为底层的字典可以作为属性来访问。<br>模拟一个字典类。这个实例的内容保存为一个正常字典，可以通过UserDict实例的data属性存取。如果提供了initialdata 值， data 就被初始化为它的内容，注意一个 initialdata 的引用不会被保留作为其他用途。<br>UserDict 实例提供了以下属性作为扩展方法和操作的支持:data一个真实的字典，用于保存 UserDict 类的内容。</p><h3 id="八、UserList"><a href="#八、UserList" class="headerlink" title="八、UserList"></a>八、UserList</h3><p>这个类封装了列表对象。它是一个有用的基础类，对于你想自定义的类似列表的类，可以继承和覆盖现有的方法，也可以添加新的方法。这样我们可以对列表添加新的行为。<br>对这个类的需求已部分由直接创建 list 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的列表可以作为属性来访问。<br>模拟一个列表。这个实例的内容被保存为一个正常列表，通过 UserList 的 data 属性存取。实例内容被初始化为一个 list 的copy，默认为 [] 空列表。 list可以是迭代对象，比如一个Python列表，或者一个UserList 对象。<br>UserList 提供了以下属性作为可变序列的方法和操作的扩展:data<br>一个 list 对象用于存储 UserList 的内容。<br>子类化的要求: UserList 的子类需要提供一个构造器，可以无参数调用，或者一个参数调用。返回一个新序列的列表操作需要创建一个实现类的实例。它假定了构造器可以以一个参数进行调用，这个参数是一个序列对象，作为数据源。<br>如果一个分离的类不希望依照这个需求，所有的特殊方法就必须重写；请参照源代码进行修改。 </p><h3 id="九、UserString"><a href="#九、UserString" class="headerlink" title="九、UserString"></a>九、UserString</h3><p>UserString类是用作字符串对象的外包装。对这个类的需求已部分由直接创建str的子类的功能所替代，不过这个类处理起来更容易，因为底层的字符串可以作为属性来访问。<br>模拟一个字符串对象。这个实例对象的内容保存为一个正常字符串，通过UserString的data属性存取。实例内容初始化设置为seq的copy。seq 参数可以是任何可通过内建str()函数转换为字符串的对象。<br>UserString 提供了以下属性作为字符串方法和操作的额外支持：data一个真正的str对象用来存放 UserString 类的内容。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://zhuanlan.zhihu.com/p/343747724" target="_blank" rel="noopener">【万字长文详解】Python库collections，让你击败99%的Pythoner</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的list列表详解</title>
      <link href="/2022/06/13/Python%E7%9A%84list%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/13/Python%E7%9A%84list%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Python list(列表)，是Python中最常用的一种数据结构，它是一组用方括号括起来、逗号分隔的数据。<br>列表的元素可以是任何类型的，但使用时通常各个元素的类型是相同的。<br>列表支持加入不同数据类型的元素：数字、字符串、列表、元组等。<br>列表是可变的，因此即使在创建后也可以对其进行更改。</p><p>Python中的列表是有序的，并且有一定数量。 根据确定的序列对列表中的元素进行索引，并使用0作为第一个索引来完成列表的索引。</p><h4 id="一、创建列表Creating-a-List"><a href="#一、创建列表Creating-a-List" class="headerlink" title="一、创建列表Creating a List"></a>一、创建列表Creating a List</h4><pre><code class="python">list1 = [&#39;Google&#39;, &#39;Runoob&#39;, 1997, 2000]list2 = [1, 2, 3, 4, 5 ]my_list = [&#39;p&#39;,&#39;r&#39;,&#39;o&#39;,&#39;b&#39;,&#39;e&#39;]kong = [] #创建空白list，用于后面调用</code></pre><h4 id="二、访问列表中的元素Accessing-elements-from-the-List"><a href="#二、访问列表中的元素Accessing-elements-from-the-List" class="headerlink" title="二、访问列表中的元素Accessing elements from the List"></a>二、访问列表中的元素Accessing elements from the List</h4><p>我们可以使用索引运算符[]访问列表中的项。索引必须为整数。嵌套列表通过嵌套索引访问。</p><p>索引的排序规则如下图，从零开始。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python的list列表详解/4ded7b055733bb97a7b67097980065bd_a8859852-9dad-4113-a0d2-df554dcb9f07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><pre><code class="python">List = [&quot;Geeks&quot;, &quot;For&quot;, &quot;Geeks&quot;] print(List[0])  </code></pre><p>在使用索引访问列表中的元素时，使用的索引(下标)不可越界，否则会报如下错误 </p><ul><li>IndexError: list index out of range</li></ul><p>以下几种情况会引起越界：</p><ul><li><p>创建空的list，但使用list[0] 来访问其中元素</p></li><li><p>访问list[n] ，但是N大于len(list)</p></li><li><p>创建空的list，通过list[0]来赋值</p></li></ul><h4 id="三、添加或删除元素Adding-or-Removing-Elements"><a href="#三、添加或删除元素Adding-or-Removing-Elements" class="headerlink" title="三、添加或删除元素Adding or Removing Elements"></a>三、添加或删除元素Adding or Removing Elements</h4><p>我们可以使用内置的append()函数将元素添加到列表中。<br>通过使用append()方法，一次只能将一个元素添加到列表中，如果使用append()方法添加多个元素，则需要使用循环。</p><pre><code class="python">List = [] print(List) # Addition of Elements  List.append(1) List.append(2) print(List) # Adding elements to the List using Iterator for i in range(1, 4):     List.append(i) print(List) </code></pre><p>其运行结果如下</p><pre><code class="python">[][1, 2][1, 2, 1, 2, 3]</code></pre><p>append()方法仅适用于List末尾的元素添加，如果需要在中间位置插入元素，则使用insert()方法。<br>insert()方法需要两个参数，位置和值。  insert(position, value)</p><pre><code class="python">List = [1,2,3,4]print(List)List.insert(3, 12)List.insert(0, &#39;Geeks&#39;)print(List)</code></pre><p>其运行结果如下</p><pre><code class="python">[1, 2, 3, 4][&#39;Geeks&#39;, 1, 2, 3, 12, 4]</code></pre><p>除了append()和insert()方法外，还有一个元素添加方法extend()，该方法用于在列表末尾同时添加多个元素。<br>我们可以使用内置的remove()函数从列表中删除元素，但是如果元素不存在于集合中，则会发生错误。<br>Remove()方法一次只删除一个元素，如需删除多个需要使用循环语句。<br>注意：remove(value)方法的参数是值，不是索引(index，下标)，此方法将仅删除搜索到的元素的第一个匹配项。</p><pre><code class="python">List = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]print(List)List.remove(5)List.remove(6)print(List)</code></pre><p>运行结果如下</p><pre><code class="python">List = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]print(List)List.remove(5)List.remove(6)print(List)</code></pre><h3 id="四、列表合并Merge-lists"><a href="#四、列表合并Merge-lists" class="headerlink" title="四、列表合并Merge lists"></a>四、列表合并Merge lists</h3><p>前面我们说过，使用append()方法，可以在列表尾部添加一个新元素，所以对于两个或者多个列表的合并不是很适用。</p><pre><code class="python">list1 = [&#39;Google&#39;, &#39;Runoob&#39;, 1997, 2000]list2 = [1, 2, 3, 4, 5 ]list3 = [{&#39;name&#39;: &#39;Soe&#39;, &#39;Sex&#39;: &#39;Female&#39;}, {&#39;name&#39;: &#39;John&#39;, &#39;Sex&#39;: &#39;Male&#39;}]newlist = list1.append(list2)print(newlist)</code></pre><p>大家猜猜返回什么结果？ </p><ul><li>None。可见list的许多方法，都是应用在list本身的，不能赋值到新的list，这一点要注意。</li></ul><pre><code class="python">list1.append(list2)# Result: [&#39;Google&#39;, &#39;Runoob&#39;, 1997, 2000, [1, 2, 3, 4, 5]]list1.extend(list2)# Result: [&#39;Google&#39;, &#39;Runoob&#39;, 1997, 2000, 1, 2, 3, 4, 5]</code></pre><p>上面这些只能合并两个list，也不方便，下面才是真正常用的方法</p><pre><code class="python">newlist = list1 + list2 + list3print(newlist)# Result: [&#39;Google&#39;, &#39;Runoob&#39;, 1997, 2000, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, {&#39;name&#39;: &#39;Soe&#39;, &#39;Sex&#39;: &#39;Female&#39;}, {&#39;name&#39;: &#39;John&#39;, &#39;Sex&#39;: &#39;Male&#39;}]newlist = [*list1, *list2, *list3]print(newlist)# Result: [&#39;Google&#39;, &#39;Runoob&#39;, 1997, 2000, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, {&#39;name&#39;: &#39;Soe&#39;, &#39;Sex&#39;: &#39;Female&#39;}, {&#39;name&#39;: &#39;John&#39;, &#39;Sex&#39;: &#39;Male&#39;}]</code></pre><h3 id="五、列表List的遍历以及判断元素是否在列表List中"><a href="#五、列表List的遍历以及判断元素是否在列表List中" class="headerlink" title="五、列表List的遍历以及判断元素是否在列表List中"></a>五、列表List的遍历以及判断元素是否在列表List中</h3><p>通过for循环可以实现列表List的遍历</p><pre><code class="python">a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]# simple iterate 简单遍历for i in a:    print(i)# iterate with index 带索引的遍历for i, el in enumerate(a):    print(i, el)# iterate with custom index 自定义索引号吗的遍历for i, el in enumerate(a, 1):    print(i, el)</code></pre><p>通过in方法可以判断元素是否在列表中</p><pre><code class="python">list1 = [&#39;Google&#39;, &#39;Runoob&#39;, 1997, 2000]if &#39;Google&#39; in list1:    print(True)# Result: True</code></pre><h3 id="六、列表排序和去重去空Sort-Remove-duplicates-Remove-NA"><a href="#六、列表排序和去重去空Sort-Remove-duplicates-Remove-NA" class="headerlink" title="六、列表排序和去重去空Sort ,Remove duplicates, Remove NA"></a>六、列表排序和去重去空Sort ,Remove duplicates, Remove NA</h3><p>通过sort方法可以进行排序</p><pre><code class="python">list1 = [&#39;Google&#39;, &#39;Yahoo&#39;, &#39;Baidu&#39;, &#39;Sogou&#39;]list1.sort(reverse=True)print(list1)# Result:  [&#39;Yahoo&#39;, &#39;Sogou&#39;, &#39;Google&#39;, &#39;Baidu&#39;]</code></pre><p>sort函数还有一个告警用法sort(key=Function)，我们在后续在探讨。<br>使用先set后list的方法可以实现对列表list元素进行去重</p><pre><code class="python">my_list = [&#39;Google&#39;, &#39;Yahoo&#39;, &#39;Baidu&#39;, &#39;Sogou&#39;, &#39;Google&#39;]newlist = list(set(my_list))print(newlist)# Result:  [&#39;Baidu&#39;, &#39;Yahoo&#39;, &#39;Google&#39;, &#39;Sogou&#39;]</code></pre><p>set()方法是创建一个集合，集合（set）是一个无序的不重复元素序列。创建完成集合set以后，在转换回来就还是一个列表list。<br>除了去重，还有经常遇到去除空值的情况</p><pre><code class="python">d = [&#39;&#39;, &#39;剧情&#39;, &#39;喜剧&#39;, &#39;恐怖&#39;, &#39;&#39;, &#39;伦理&#39;, &#39;&#39;]d_dropna = list(filter(None, d))    #去除列表空值print(d_dropna)# Result:  [&#39;剧情&#39;, &#39;喜剧&#39;, &#39;恐怖&#39;, &#39;伦理&#39;]</code></pre><p>使用filter就可以过滤掉空值，然后在使用list将其格式转换为列表。</p><h3 id="七、列表切片Slicing-of-a-List"><a href="#七、列表切片Slicing-of-a-List" class="headerlink" title="七、列表切片Slicing of a List"></a>七、列表切片Slicing of a List</h3><p>在Python列表中，有多种方法来打印包含所有元素的整个列表，但是要打印列表中特定范围的元素，我们使用切片操作。 </p><p>注意：除了列表List，元组Tuple，字符串string 也可以进行切片操作。</p><p>切片操作的格式如下</p><pre><code class="python">list[start_index: end_index: step]</code></pre><ul><li>start：表示是第一个元素对象，正索引位置默认为0；负索引位置默认为 -序列长度 </li><li>end：表示是最后一个元素对象，正索引位置默认为 (序列长度－1)；负索引位置默认为 -1 </li><li>step：步长，end-start，步长为正时，从左向右取值。步长为负时，反向取值，默认为1，步长值不能为0</li></ul><pre><code class="python">List = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]print(List[0:])print(List[:])print(List[2:])print(List[2:4])print(List[2:100])print(&#39;============================&#39;)print(List[:-1])print(List[::-1])   print(List[::-2])</code></pre><p>这里的[start_index:end_index] 是一个前开后闭的区间取值，例如[2:4]实际数学表示是[2:4)，也就是获取第3个和第4个值。 </p><p>运行结果如下</p><pre><code class="python">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10][1, 2, 3, 4, 5, 6, 7, 8, 9, 10][3, 4, 5, 6, 7, 8, 9, 10][3, 4][3, 4, 5, 6, 7, 8, 9, 10]============================[1, 2, 3, 4, 5, 6, 7, 8, 9][10, 9, 8, 7, 6, 5, 4, 3, 2, 1][10, 8, 6, 4, 2]</code></pre><p>注意：切片操作不会出现索引(下标)越界的情况，Python内部有处理机制自动转换了，这里和通过索引访问列表list是不一样的。</p><h3 id="八、列表的常用方法总结"><a href="#八、列表的常用方法总结" class="headerlink" title="八、列表的常用方法总结"></a>八、列表的常用方法总结</h3><p>用append()方法，在列表尾部添加单个新元素。 </p><ul><li> 用insert()方法，在列表中指定位置添加元素。 </li><li> 用 “+” 运算符，将两个列表拼接出一个新列表。 </li><li> 用extend()方法，在一个列表后面拼接进另一个列表。 </li><li> 用del list[m] 语句，删除指定索引m处的元素。 </li><li> 用remove()方法，删除指定值的元素（第一个匹配项）。 </li><li> 用pop()方法，取出并删除列表末尾的单个元素。 </li><li> 用pop(m)方法，取出并删除索引值为m的元素。 </li><li> 用clear()方法，清空列表的元素。（杯子还在，水倒空了） </li><li> 用del list 语句，销毁整个列表。（杯子和水都没有了） </li><li> 用len()方法，统计全部元素的个数。 </li><li> 用count()方法，统计指定值的元素的个数。 </li><li> 用max()方法，统计元素中的最大值（要求元素类型相同；数字类型直接比较，其它类型比较id） </li><li> 用min()方法，统计元素中的最小值（要求元素类型相同；数字类型直接比较，其它类型比较id） </li><li> 用index()方法，查找指定值的元素的索引位置（第一个匹配项）。 </li><li> 用reverse()方法，翻转列表中的元素。 </li><li> 用copy()方法，浅拷贝并生成新的列表。 </li><li> 用deepcopy()方法，深拷贝并生成新的列表。 </li><li> 用sort()方法，在原列表基础上进行排序。 </li><li> 用sorted()方法，将新列表基础上对原列表的元素进行排序。</li></ul><h3 id="九、扩展习题"><a href="#九、扩展习题" class="headerlink" title="九、扩展习题"></a>九、扩展习题</h3><p>切片操作()</p><pre><code class="python">#判断回文s = &#39;abba&#39;if s == s[::-1]:    print(&quot;True&quot;)else:    print(&quot;False&quot;)#数字翻转#对于一个整数X，定义操作rev(X)为将X按数位翻转过来，并且去除掉前导0def rev(x):    x = str(x)    return int(x[::-1])z = 10590print(rev(z))</code></pre><p>来点难度，leetcode题目，</p><pre><code class="python">Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.You may assume that the array is non-empty and the majority element always exist in the array.Example 1:Input: [3,2,3]Output: 3Example 2:Input: [2,2,1,1,1,2,2]Output: 2</code></pre><p>最好理解的解法</p><pre><code class="python">class Solution:    def majorityElement(self, nums):        majority_count = len(nums)//2        for num in nums:            count = sum(1 for elem in nums if elem == num)            if count &gt; majority_count:                return num#遍历数组，某元素出现次数大于半数，就返回该元素#注意这里用到了生成器(1 for elem in nums if elem == num)</code></pre><p>最快的解法</p><pre><code class="python">class Solution:    def majorityElement(self, nums):        nums.sort()        return nums[len(nums)//2]#众数必然出现在中间位置</code></pre><h3 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h3><ul><li>TypeError: ‘list’ object is not callable </li><li>命名错误，使用了保留字list定义了变量</li></ul><pre><code class="python">list = [1, 2, 3] #list是保留字，不能做变量my_list = [&#39;Google&#39;, &#39;Yahoo&#39;, &#39;Baidu&#39;, &#39;Sogou&#39;, &#39;Google&#39;]newlist = list(set(my_list))print(newlist)</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s/OKf7N3xxrS0tJ_K8Srw-jA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OKf7N3xxrS0tJ_K8Srw-jA</a> </p><ul><li><a href="https://www.geeksforgeeks.org/python-list/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/python-list/</a> </li><li><a href="https://www.yuanrenxue.com/python/python-list.html" target="_blank" rel="noopener">https://www.yuanrenxue.com/python/python-list.html</a></li></ul><p>转载请注明：<a href="https://www.ipcpu.com/" target="_blank" rel="noopener">IPCPU-网络之路</a> » <a href="https://www.ipcpu.com/2021/07/python%e7%9a%84list%e5%88%97%e8%a1%a8%e8%af%a6%e8%a7%a3/" target="_blank" rel="noopener">Python的list列表详解</a> </p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.ipcpu.com/2021/07/python%e7%9a%84list%e5%88%97%e8%a1%a8%e8%af%a6%e8%a7%a3/" target="_blank" rel="noopener">Python的list列表详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xpath_详解</title>
      <link href="/2022/06/12/Xpath_%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/12/Xpath_%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Xpath？"><a href="#什么是-Xpath？" class="headerlink" title="什么是 Xpath？"></a>什么是 Xpath？</h2><p>Xpath 是一种用在 XML 文档中定位元素的语言，同样也支持 HTML 元素的解析。</p><p>所谓 Xpath，是指 XML path language。path 就是路径，那么 Xpath 主要是通过路径来查找元素。</p><p>我们通过下面一张小图来了解一下 HTML 中的结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-1d5d648e03370891.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>HTML 的结构就是树形结构，HTML 是根节点，所有的其他元素节点都是从根节点发出的。其他的元素都是这棵树上的节点<code>Node</code>，每个节点还可能有属性和文本。</p><ul><li>而路径就是指某个节点到另一个节点的路线。</li></ul><p>节点之间存在各种关系：</p><ul><li><p>父节点(Parent)： HTML 是 body 和 head 节点的父节点；</p></li><li><p>子节点(Child)：head 和 body 是 HTML 的子节点；</p></li><li><p>兄弟节点(Sibling)：拥有相同的父节点，head 和 body 就是兄弟节点。title 和 div 不是兄弟，因为他们不是同一个父节点。</p></li><li><p>祖先节点(Ancestor)：body 是 form 的祖先节点，爷爷辈及以上👴；</p></li><li><p>后代节点(Descendant)：form 是 HTML 的后代节点，孙子辈及以下👶。</p></li></ul><p>Xpath 中的绝对路径从 HTML 根节点开始算，相对路径从任意节点开始。</p><p>通过开发者工具，我们可以拷贝到 Xpath 的绝对路径和相对路径代码：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-3ce3a8737955cffe.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但是由于拷贝出来的代码缺乏灵活性，也不全然准确。大部分情况下，都需要自己定义 Xpath 语句，因此 Xpath 语法还是有必要学习。</p><h2 id="绝对路径："><a href="#绝对路径：" class="headerlink" title="绝对路径："></a>绝对路径：</h2><p>Xpath 中最直观的定位策略就是绝对路径。</p><p>以百度中的输入框和按钮为例，通过拷贝出来的 full Xpath：</p><pre><code class="python">/html/body/div[2]/div/div/div/div/form/span/input</code></pre><p>这就是一个绝对路径我们可以看出，绝对路径是从根节点<code>/html</code>开始往下，一层层的表示出来直到需要的节点为止。</p><p>这明显不是理智的选项，因此了解以下即可，不用往心里去。</p><h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>除了绝对路径，Xpath 中更常用的方式是相对路径定位方法，以“//”开头。</p><p>相对路径可以从任意节点开始，一般我们会选取一个可以唯一定位到的元素开始写，可以增加查找的准确性。</p><p>相对路径可以通过以下的方式来定位元素：</p><h3 id="基本定位语法"><a href="#基本定位语法" class="headerlink" title="基本定位语法"></a>基本定位语法</h3><p>定位语法主要依赖于以下特殊符号：</p><table><thead><tr><th>表达式</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>/</code></td><td>从根节点开始选取</td><td>/html/div/span</td></tr><tr><td><code>//</code></td><td>从任意节点开始选取</td><td>//input</td></tr><tr><td><code>.</code></td><td>选取当前节点</td><td></td></tr><tr><td><code>..</code></td><td>选取当前节点的父节点</td><td>//input/.. 会选取 input 的父节点</td></tr><tr><td><code>@</code></td><td>选取属性，或者根据属性选取</td><td>//input[@data] 选取具备 data 属性的 input 元素 //@data 选取所有 data 属性</td></tr><tr><td><code>*</code></td><td>通配符，表示任意节点或任意属性</td><td></td></tr></tbody></table><h3 id="元素属性定位"><a href="#元素属性定位" class="headerlink" title="元素属性定位"></a>元素属性定位</h3><p>属性定位是通过 @ 符号指定需要使用的属性。</p><ul><li>根据元素是否具备某个属性查找元素</li></ul><pre><code class="python">//*[@data-recordid]</code></pre><p>选取包含data-recordid属性的所有节点。可以定位到以下元素：</p><pre><code class="python">&lt;tr role=&quot;row&quot; data-boundview=&quot;gridview-1029&quot; data-recordid=&quot;B36BCA33&quot; &gt;&lt;/tr&gt;</code></pre><ul><li>根据属性是否等于某值查找元素</li></ul><pre><code class="python">//span[@role=&#39;img&#39;]</code></pre><p>选取属性 role 的属性值为 img 的所有节点。可以定位到以下元素：</p><pre><code class="python">&lt;span role=&quot;img&quot; class=&quot;x-btn-icon-el&quot; unselectable=&quot;on&quot; style=&quot;&quot;&gt;&lt;/span&gt;</code></pre><p>注意，属性值必须要加引号，单双引号都可以。</p><h3 id="层级属性结合定位"><a href="#层级属性结合定位" class="headerlink" title="层级属性结合定位"></a>层级属性结合定位</h3><p>遇到某些元素无法精确定位的时候，可以查找其父级及其祖先节点，找到有确定的祖先节点后通过层级依次向下定位。</p><p>以下面的结构为例：</p><ul><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-1187d4bb553f53c6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><pre><code class="python">&lt;form action=&quot;search&quot; id=&quot;form&quot; method=&quot;post&quot;&gt;    &lt;span class=&quot;bg&quot;&gt;        &lt;span class=&quot;soutu&quot;&gt;搜索&lt;/span&gt;    &lt;/span&gt;    &lt;span class=&quot;soutu&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;key&quot; id=&quot;su&quot;&gt;    &lt;/span&gt;&lt;/form&gt;</code></pre><ul><li>根据层级向下找，从 form 找到绿色的 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span/span</code></pre><ul><li>查找某元素内部的所有元素，选取 form 元素内部的所有 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]//span</code></pre><p>第二个双斜杠，表示选取内部所有的 span，不管层级关系</p><ul><li>使用星号找不特定的元素</li></ul><pre><code class="python">//*[@id=&quot;form&quot;]//*[@type=&quot;text&quot;]</code></pre><p>选取 id 属性为 form 的任意属性内部，并且 type 属性为 text 的任意元素。这里会找到 input。</p><ul><li>使用<code>..</code>从下往上找，根据 input 查找其父节点 span：</li></ul><pre><code class="python">//input[@name=&quot;key&quot;]/..</code></pre><p>注意最后的两个点，找到 input 节点的上级节点，如果还要再往上再加 <code>/..</code></p><ul><li>找同级节点：</li><li>比如我们想通过第一个 span 标签去 找 div 标签。树形结构中，兄弟节点之间的关系是通过父节点建立起来的。所以可以先找到父节点，再通过父节点找同级节点。</li></ul><pre><code class="python">//span[@class=&quot;bg&quot;]/../div</code></pre><p>先通过<code>/..</code>找到 span 的父节点，再通过父节点找到 div。</p><h3 id="使用谓语定位"><a href="#使用谓语定位" class="headerlink" title="使用谓语定位"></a>使用谓语定位</h3><p>谓语是 Xpath 中用于描述元素位置。主要有数字下标、最后一个子元素<code>last()</code>、元素下标函数<code>position()</code>。</p><ul><li>使用下标的方式，从 form 找到 input ：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span[2]/input</code></pre><p>Xpath 中的下标从 <code>1</code> 开始。</p><ul><li>查找最后一个子元素，选取 form 下的最后一个 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span[last()]</code></pre><ul><li>查找倒数第几个子元素，选取 form 下的倒数第一个 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span[last()-1]</code></pre><ul><li>使用 position() 函数，选取 from 下第二个 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span[position()=2]</code></pre><ul><li>使用 position() 函数，选取下标大于 2 的 span：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]/span[position()&gt;2]</code></pre><h3 id="使用逻辑运算符"><a href="#使用逻辑运算符" class="headerlink" title="使用逻辑运算符"></a>使用逻辑运算符</h3><p>如果元素的某个属性无法精确定位到这个元素，我们还可以用逻辑运算符 and 连接多个属性进行定位，以百度输入框为例。</p><ul><li>使用 <code>and</code> ：</li></ul><pre><code class="python">//*[@name=&#39;wd&#39; and @class=&#39;s_ipt&#39;]</code></pre><p>查找 name 属性为 wd 并且 class 属性为 s_ipt 的任意元素</p><ul><li>使用 <code>or</code>：</li></ul><pre><code class="python">//*[@name=&#39;wd&#39; or @class=&#39;s_ipt&#39;]</code></pre><p>查找 name 属性为 wd 或者 class 属性为 s_ipt 的任意元素，取其中之一满足即可。</p><ul><li>使用<code>|</code>，同时查找多个路径，取或：</li></ul><pre><code class="python">//form[@id=&quot;form&quot;]//span | //form[@id=&quot;form&quot;]//input</code></pre><p>选取 form 下所有的 span 和所有的 input。</p><h3 id="使用文本定位"><a href="#使用文本定位" class="headerlink" title="使用文本定位"></a>使用文本定位</h3><p>使用文本定位，是 Xpath 中的一大特色。在自动化测试中，为了让代码的可读性更高，可以使用文本的方式。</p><p>以下一个案例：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-466743dbeb77cb6f.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>部分网页结构如下：</p><pre><code class="python">&lt;tr&gt;  &lt;td valign=&quot;top&quot;&gt;    &lt;input type=&quot;radio&quot; name=&quot;payment&quot; value=&quot;1&quot; checked=&quot;&quot; iscod=&quot;0&quot;&gt;  &lt;/td&gt;  &lt;td valign=&quot;top&quot;&gt;    &lt;strong&gt;支付宝&lt;/strong&gt;  &lt;/td&gt;&lt;/tr&gt;</code></pre><p>其实我们需要点的是前的单选框，但是单选框没有任何特殊的标识，不够灵活。我们可以通过后面的名称，如(支付宝、余额支付等)来找到其对应行的 radio，再去点击。</p><p>我们就需要先通过文本定位到“支付宝”，再去找其同一行(tr)的 input 节点。如果理不清楚，我们可以先画一个结构图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-443ad23bb513cce3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>红色箭头表示查找路径，先定位到“支付宝”所在的 strong，再定位 <code>td -&gt; tr -&gt; td - &gt;input</code> 。那么要定位“支付宝”文本，就需要用到 Xpath 中的函数 <code>text()</code> 或 <code>string()</code>，注意是函数，所以括号不能少。</p><p><code>text()</code>：当前元素节点包含的文本内容；</p><ul><li>表达式<code>//div[text()=&quot;文本&quot;]</code>，能找到：</li></ul><pre><code class="python">&lt;div&gt;文本&lt;/div&gt;</code></pre><p>不能找到：</p><pre><code class="python">&lt;div&gt;&lt;span&gt;文本&lt;/span&gt;&lt;/div&gt;</code></pre><p><code>string()</code>：当前元素节点内部所有节点元素的文本内容。表达式<code>//div[string()=&quot;文本&quot;]</code>上述两种情况都能找到。</p><p>好，接着写上面的内容。先通过 <code>//strong[text()=&quot;支付宝&quot;]</code>定位到“支付宝”所在的元素 strong，再找上级 td -&gt; tr，再向下找：</p><pre><code class="python">//strong[text()=&quot;支付宝&quot;]/../../td[1]/input</code></pre><p>也可以写为：</p><pre><code class="python">//td[string()=&quot;支付宝&quot;]/../td[1]/input</code></pre><h3 id="使用部分匹配函数"><a href="#使用部分匹配函数" class="headerlink" title="使用部分匹配函数"></a>使用部分匹配函数</h3><p>Xpath 中有提供了几个函数，用来进行部分匹配。</p><table><thead><tr><th>函数</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>contains</td><td>选取属性或者文本包含某些字符</td><td>//div[contains(@id, ‘data’)] 选取 id 属性包含 data 的 div 元素  //div[contains(string(), ‘支付宝’)] 选取内部文本包含“支付宝”的 div 元素</td></tr><tr><td>starts-with</td><td>选取属性或者文本以某些字符开头</td><td>//div[starts-with(@id, ‘data’)] 选取 id 属性以 data 开头的 div 元素  //div[starts-with(string(), ‘银联’)] 选取内部文本以“银联”开头的 div 元素</td></tr><tr><td>ends-with</td><td>选取属性或者文本以某些字符开头</td><td>//div[ends-with(@id, ‘require’)] 选取 id 属性以 require 结尾的 div 元素  //div[ends-with(string(), ‘支付’)] 选取内部文本以“支付”结尾的 div 元素</td></tr></tbody></table><h2 id="验证-Xpath"><a href="#验证-Xpath" class="headerlink" title="验证 Xpath"></a>验证 Xpath</h2><p>验证 xpath 有两种方法：</p><ul><li>在开发者工具的 Elements 中按<code>Ctrl + F</code>，在搜索框中输入 Xpath：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-a9ed19d1dffab883.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>在开发者工具的 Console 中使用 <code>$x()</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Xpath_详解/8178525-1d6c86e9e1723c6a.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/6a0dbb4e246a" target="_blank" rel="noopener">Xpath_详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Xpath </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python读取配置文件方式(ini、yaml、xml)</title>
      <link href="/2022/06/11/python%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F(ini%E3%80%81yaml%E3%80%81xml)/"/>
      <url>/2022/06/11/python%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F(ini%E3%80%81yaml%E3%80%81xml)/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>python代码中配置文件是必不可少的内容。常见的配置文件格式有很多中：ini、yaml、xml、properties、txt、py等。</p><h2 id="一、ini文件"><a href="#一、ini文件" class="headerlink" title="一、ini文件"></a>一、ini文件</h2><h3 id="1-1-ini文件的格式"><a href="#1-1-ini文件的格式" class="headerlink" title="1.1 ini文件的格式"></a>1.1 ini文件的格式</h3><pre><code class="ini">; 注释内容 [url] ; section名称 baidu = https://www.zalou.cn port = 80 [email] sender = ‘xxx@qq.com’</code></pre><p>注意section的名称不可以重复，注释用分号开头。</p><h3 id="1-2-读取-configparser"><a href="#1-2-读取-configparser" class="headerlink" title="1.2 读取 configparser"></a>1.2 读取 configparser</h3><p>python自带的configparser模块可以读取.ini文件，注意：在python2中是ConfigParser</p><p>创建文件的时候，只需要在pychrame中创建一个扩展名为.ini的文件即可。</p><pre><code class="python">import configparserfile = &#39;config.ini&#39;# 创建配置文件对象con = configparser.ConfigParser()# 读取文件con.read(file, encoding=&#39;utf-8&#39;)# 获取所有sectionsections = con.sections()# [&#39;url&#39;, &#39;email&#39;]# 获取特定sectionitems = con.items(&#39;url&#39;) # 返回结果为元组# [(&#39;baidu&#39;,&#39;https://www.zalou.cn&#39;),(&#39;port&#39;, &#39;80&#39;)] # 数字也默认读取为字符串# 可以通过dict方法转换为字典items = dict(items)</code></pre><h2 id="二、yaml配置文件"><a href="#二、yaml配置文件" class="headerlink" title="二、yaml配置文件"></a>二、yaml配置文件</h2><h3 id="2-1-yaml文件格式"><a href="#2-1-yaml文件格式" class="headerlink" title="2.1 yaml文件格式"></a>2.1 yaml文件格式</h3><p>yaml文件是用来方便读写的一种格式。它实质上是一种通用的数据串行话格式。</p><p>它的基本语法如下：</p><ul><li>大小写敏感</li><li>缩进表示层级关系</li><li>缩进时不允许使用Tab，仅允许空格</li><li>空格的多少不重要，关键是相同层级的元素要对齐</li><li>#表示注释，#后面的字符都会被忽略</li></ul><p>yaml支持的数据格式包括:</p><ul><li>字典</li><li>数组</li><li>纯量：单个的，不可再次分割的值</li></ul><h3 id="2-1-2-对象"><a href="#2-1-2-对象" class="headerlink" title="2.1.2 对象"></a>2.1.2 对象</h3><p>对象是一组组的键值对，使用冒号表示结构</p><pre><code class="yaml">url: https://www.zalou.cnlog:  file_name: test.log backup_count: 5</code></pre><p>yaml也允许另外一种写法，将所有的键值对写成一个行内对象</p><pre><code class="yaml"> log: {file_name: test.log, backup_count: 5}</code></pre><h3 id="2-1-3-数组"><a href="#2-1-3-数组" class="headerlink" title="2.1.3 数组"></a>2.1.3 数组</h3><p>一组横线开头的行，组成一个数组。</p><pre><code class="yaml"> – cat – Dog – Goldfish</code></pre><p>转换成python对象是</p><pre><code class="python"> [‘cat’, ‘Dog’, ‘Goldfish’]</code></pre><p>数组也可以采用行内写法：</p><pre><code class="yaml"> animal: [cat, dog]</code></pre><p>转行成python对象是</p><pre><code class="python"> {‘animal’: [‘cat’, ‘dog’]}</code></pre><h3 id="2-1-4-纯量"><a href="#2-1-4-纯量" class="headerlink" title="2.1.4 纯量"></a>2.1.4 纯量</h3><p>纯量是最基本，不可分割的值。<br>数字和字符串直接书写即可：</p><pre><code class="yaml"> number: 12.30 name: zhangsan</code></pre><p>布尔值用true和false表示</p><pre><code class="yaml"> isSet: true flag: false</code></pre><p>null用~表示</p><pre><code class="yaml"> parent: ~</code></pre><p>yaml允许用两个感叹号表示强制转换</p><pre><code class="yaml"> e: !!str 123 f: !!str true</code></pre><h3 id="2-1-5-引用"><a href="#2-1-5-引用" class="headerlink" title="2.1.5 引用"></a>2.1.5 引用</h3><p>锚点&amp;和别名*，可以用来引用</p><pre><code class="yaml">defaults: &amp;defaults adapter: postgres host: localhost development:  databases: myapp_deveploment &lt;&lt;: *defaultstest: databases: myapp_test &lt;&lt;: *defaults</code></pre><p>等同于以下代码</p><pre><code class="yaml">defaults:  adapter: postgres host: localhost development:  databases: myapp_deveploment adapter: postgres host: localhosttest: databases: myapp_test adapter: postgres host: localhost</code></pre><p>&amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点<br>下面是另外一个例子：</p><pre><code class="yaml"> – &amp;abc st – cat – dog – *abc</code></pre><p>转换成python代码是：</p><pre><code class="python"> [‘st’, ‘cat’, ‘dog’, ‘st’]</code></pre><h3 id="2-2-yaml文件的读取"><a href="#2-2-yaml文件的读取" class="headerlink" title="2.2 yaml文件的读取"></a>2.2 yaml文件的读取</h3><p>读取yaml文件需要先安装相应模块。</p><pre><code class="shell">pip install pyyaml</code></pre><p>yaml文件内容如下：</p><pre><code class="yaml">url: https://www.baidu.comemail: send: xxx@qq.com port: 25---url: http://www.sina.com.cn</code></pre><p>读取代码如下：</p><pre><code class="bash"># coding:utf-8import yaml# 获取yaml文件路径yamlPath = &#39;config.yaml&#39;with open(yamlPath,&#39;rb&#39;) as f: # yaml文件通过---分节，多个节组合成一个列表 date = yaml.safe_load_all(f) # salf_load_all方法得到的是一个迭代器，需要使用list()方法转换为列表 print(list(date))</code></pre><h2 id="三、xml配置文件读取"><a href="#三、xml配置文件读取" class="headerlink" title="三、xml配置文件读取"></a>三、xml配置文件读取</h2><p>xml文件内容如下：</p><pre><code class="xml">&lt;collection shelf=&quot;New Arrivals&quot; &lt;movie title=&quot;Enemy Behind&quot;  &lt;type War, Thriller&lt;/type  &lt;format DVD&lt;/format  &lt;year 2003&lt;/year  &lt;rating PG&lt;/rating  &lt;stars 10&lt;/stars  &lt;description Talk about a US-Japan war&lt;/description &lt;/movie &lt;movie title=&quot;Transformers&quot;  &lt;type Anime, Science Fiction&lt;/type  &lt;format DVD&lt;/format  &lt;year 1989&lt;/year  &lt;rating R&lt;/rating  &lt;stars 8&lt;/stars  &lt;description A schientific fiction&lt;/description &lt;/movie  &lt;movie title=&quot;Trigun&quot;  &lt;type Anime, Action&lt;/type  &lt;format DVD&lt;/format  &lt;episodes 4&lt;/episodes  &lt;rating PG&lt;/rating  &lt;stars 10&lt;/stars  &lt;description Vash the Stampede!&lt;/description &lt;/movie &lt;movie title=&quot;Ishtar&quot;  &lt;type Comedy&lt;/type  &lt;format VHS&lt;/format  &lt;rating PG&lt;/rating  &lt;stars 2&lt;/stars  &lt;description Viewable boredom&lt;/description &lt;/movie &lt;/collection </code></pre><p>读取代码如下：</p><pre><code class="python"># coding=utf-8import xml.dom.minidomfrom xml.dom.minidom import parseDOMTree = parse(&#39;config.xml&#39;)collection = DOMTree.documentElementif collection.hasAttribute(&quot;shelf&quot;): print(&quot;Root element : %s&quot; % collection.getAttribute(&quot;shelf&quot;))# 在集合中获取所有电影movies = collection.getElementsByTagName(&quot;movie&quot;)# 打印每部电影的详细信息for movie in movies: print(&quot;*****Movie*****&quot;) if movie.hasAttribute(&quot;title&quot;):  print(&quot;Title: %s&quot; % movie.getAttribute(&quot;title&quot;)) type = movie.getElementsByTagName(&#39;type&#39;)[0] print(&quot;Type: %s&quot; % type.childNodes[0].data) format = movie.getElementsByTagName(&#39;format&#39;)[0] print(&quot;Format: %s&quot; % format.childNodes[0].data) rating = movie.getElementsByTagName(&#39;rating&#39;)[0] print(&quot;Rating: %s&quot; % rating.childNodes[0].data) description = movie.getElementsByTagName(&#39;description&#39;)[0] print(&quot;Description: %s&quot; % description.childNodes[0].data)</code></pre><p>以上这篇python读取配置文件方式(ini、yaml、xml)就是小编分享给大家的全部内容了，希望能给大家一个参考。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://cloud.tencent.com/developer/article/1740527" target="_blank" rel="noopener">python读取配置文件方式(ini、yaml、xml)</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python一秒钟搭建文件分享网页</title>
      <link href="/2022/06/10/Python%E4%B8%80%E7%A7%92%E9%92%9F%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E5%88%86%E4%BA%AB%E7%BD%91%E9%A1%B5/"/>
      <url>/2022/06/10/Python%E4%B8%80%E7%A7%92%E9%92%9F%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E5%88%86%E4%BA%AB%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>    Python的库是十分丰富的。在局域网内分享文件时，Python的http.server可以创建一个非常基本的Web服务器，相对于当前目录提供文件。http.server模块定义用于实现 HTTP 服务器（Web 服务器）的类。</p><h3 id="一、运行简单网页"><a href="#一、运行简单网页" class="headerlink" title="一、运行简单网页"></a>一、运行简单网页</h3><p>    先来试验一下，在cmd运行：python -m http.server，如果时linux平台的化，注意python版本3 。在浏览器输入IP地址:8000，即可获得的当前目录下的所有文件列表，以提供下载。需要注意的是防火墙要关闭或添加规则。<br>    在局域网内暂时分享文件的话是十分方便的，比U盘拷贝省心很多。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python一秒钟搭建文件分享网页/24447700-a76e1d33147b6118.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python一秒钟搭建文件分享网页/24447700-e9440b8b295e43e1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="分享网页"><a href="#分享网页" class="headerlink" title="分享网页"></a>分享网页</h4><p>查看官方文档：http请求映射到目录，检查目录中是否有index.html或index.htm文件（按顺序）。如果有，文件的内容将返回：否则，目录列表将通过调用list_directory()方法生成，此方法使用os.listdir()扫描目录。</p><h3 id="二、http-server具体使用方法"><a href="#二、http-server具体使用方法" class="headerlink" title="二、http.server具体使用方法"></a>二、http.server具体使用方法</h3><p> 使用 python -m http.server –help 再来看一下具体的使用方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python一秒钟搭建文件分享网页/24447700-acbebe374b8d8c3c.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>port指定端口号，而不是默认的8000。<br>–bind ADDRESS, -b ADDRESS此方式是针对多网卡设备，绑定特定的网卡可以访问，而不是全部网卡。<br>–directory DIRECTORY, -d DIRECTORY指定特定的目录，而不是当前目录。<br>下面的命令指定E:\download目录并通过端口8888运行http.server ，所有网卡组成的局域网IP地址都可以访问。<br>python -m http.server –directory E:\download 8888</p><p><img src="/images/Python%E4%B8%80%E7%A7%92%E9%92%9F%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E5%88%86%E4%BA%AB%E7%BD%91%E9%A1%B5/24447700-a9f48c4af6cbc7aa.png"></p><p>   下面的命令指定E:\download目录并通过端口8888运行http.server ，特定网卡的局域网IP地址可以访问。    <br>    python -m http.server –directory E:\download –bind 192.168.15.219 8888</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python一秒钟搭建文件分享网页/24447700-e5a3b5d7ac736f8e.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="三、底层实现server-py"><a href="#三、底层实现server-py" class="headerlink" title="三、底层实现server.py"></a>三、底层实现server.py</h3><p>    上面的帮助信息里面有提示：usage: server.py [-h] [–cgi] [–bind ADDRESS] [–directory DIRECTORY] [port]  ，既是此种方法的底层调用的是server.py  （<a href="https://github.com%2Fpython%2Fcpython%2Ftree%2F3.3%2FLib%2Fhttp%2Fserver.py">github上也有托管</a>）。下面笔者通过进入到server.py的目录，直接使用底层server.py来运行http服务，效果是一样的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python一秒钟搭建文件分享网页/24447700-fd7af4ded14cafe7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>你也可以使用__pycache__目录下的已经编译好的.pyc文件。<br>![]/images/Python一秒钟搭建文件分享网页/24447700-2daa0e093f417a40.png)</p><h3 id="四、Linux系统上实践"><a href="#四、Linux系统上实践" class="headerlink" title="四、Linux系统上实践"></a>四、Linux系统上实践</h3><p>        在Llinux系统上，如果要远程拷贝文件可以使用scp命令，或者在windows上使用可视化程序winscp。笔者使用腾讯云服务器来测试（哈哈，忽略前面的登陆显示的狮子），需要注意的是腾讯云服务器密钥开启firewall防火墙，但是NAT转换服务器是有防火墙的，需要在控制台中开启TCP/8000端口。<br>    但是，官方不推荐在生产环境中使用 <a href="https://docs.python.org%2Fzh-cn%2F3%2Flibrary%2Fhttp.server.html%23module-http.server">http.server</a> ，它只实现了基本的安全检查功能。所有临时搭建分享文件或者调试是可以的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python一秒钟搭建文件分享网页/24447700-13b0f21eda21d9e8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Python一秒钟搭建文件分享网页/24447700-c31081ae3279e5d7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/f8c31bbbc1ef" target="_blank" rel="noopener">Python一秒钟搭建文件分享网页</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最完美方案！模拟浏览器如何正确隐藏特征</title>
      <link href="/2022/06/10/%E6%9C%80%E5%AE%8C%E7%BE%8E%E6%96%B9%E6%A1%88%EF%BC%81%E6%A8%A1%E6%8B%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%9A%90%E8%97%8F%E7%89%B9%E5%BE%81/"/>
      <url>/2022/06/10/%E6%9C%80%E5%AE%8C%E7%BE%8E%E6%96%B9%E6%A1%88%EF%BC%81%E6%A8%A1%E6%8B%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%9A%90%E8%97%8F%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>在前天的公众号文章<a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&mid=2648979700&idx=1&sn=ec98a4dd7ad660ad8af664942c25072f&scene=21#wechat_redirect" target="_blank" rel="noopener">《别去送死了。Selenium 与 Puppeteer 能被网站探测的几十个特征》</a>中，我们提到目前网上的反检测方法几乎都是掩耳盗铃，因为模拟浏览器有几十个特征可以被检测，仅仅隐藏 webdriver 这一个值是没有任何意义的。</p><p>今天我们就来说说应该如何正确解决这个问题。我们首先给出解决方案。然后再说明这个解决方案，我是通过什么方式找到的。<br>解决这个问题的关键，就是一个 js 文件，叫做<code>stealth.min.js</code>。稍后我会说明如何生成这个文件。<br>我们需要设定，让 Selenium 或者 Pyppeteer 在打开任何页面<strong>之前</strong>，先运行这个 Js 文件。具体的做法和原理，大家可以参考我这两篇文章：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&mid=2648978304&idx=1&sn=bff6a1f03b29702f2393a9fef9a50452&scene=21#wechat_redirect" target="_blank" rel="noopener">（最新版）如何正确移除Selenium中的 window.navigator.webdriver</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&mid=2648978312&idx=1&sn=516564fbb02aca47a1e8b19e1ed9a167&chksm=f2506e68c527e77eca1c987af90c427bdb1c746f0bff6973d1f1a8dcb7d41c814b74af745c87&token=465047301&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">（最新版）如何正确移除 Pyppeteer 中的window.navigator.webdriver</a><br>这里，我以 Selenium 为例来说明如何操作，我们编写如下代码：</p><pre><code class="python">import timefrom selenium.webdriver import Chromefrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument(&quot;--headless&quot;)chrome_options.add_argument(&#39;user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#39;)driver = Chrome(&#39;./chromedriver&#39;, options=chrome_options)with open(&#39;/Users/kingname/test_pyppeteer/stealth.min.js&#39;) as f:    js = f.read()driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, {  &quot;source&quot;: js})driver.get(&#39;https://bot.sannysoft.com/&#39;)time.sleep(5)driver.save_screenshot(&#39;walkaround.png&#39;)# 你可以保存源代码为 html 再双击打开，查看完整结果source = driver.page_sourcewith open(&#39;result.html&#39;, &#39;w&#39;) as f:    f.write(source)  </code></pre><p>运行截图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/最完美方案！模拟浏览器如何正确隐藏特征/1654940870.049451.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以看到，虽然我使用的是无头模式，但是能够被识别的特征都被成功隐藏。大家还可以双击打开保存下来的 html 文件，看看是不是结果跟普通浏览器几乎一样。<br>如果你使用的是 Pyppeteer，那么可以根据我上面文章中给出的方法，试着加载一下这个 js 文件，看看是不是也能成功隐藏特征。<br>那么，这个<code>stealth.min.js</code>文件是怎么来的呢？这就要说到<code>puppeteer</code>了。我们知道，Python 版本的<code>pyppeteer</code>已经很久没有人维护了，但是Node.js 版本的 <code>puppeteer</code>持续有人维护，并且在持续更新，生态也越来越好。<br>有开发者给 puppeteer 写了一套插件，叫做<code>puppeteer-extra</code>。其中，就有一个插件叫做puppeteer-extra-plugin-stealth[1]。这个东西，就来专门用来让 puppeteer 隐藏模拟浏览器的指纹特征。<br>这个东西是专门给 puppeteer 用的。所以，如果你使用的是 puppeteer，那么你可以根据它的 Readme说明，直接使用。<br>那么，我们用 Python 的人怎么办呢？实际上也有办法。就是把其中的隐藏特征的脚本提取出来，做成一个单独的 js 文件。然后让 Selenium 或者 Pyppeteer 在打开任意网页之前，先运行一下这个 js 文件里面的内容。<br>puppeteer-extra-plugin-stealth的作者还写了另外一个工具，叫做extract-stealth-evasions[2]。这个东西就是用来生成<code>stealth.min.js</code>文件的。<br>如果你在国外，并且网速足够快的话。那么你根据它的 Readme，首先安装 Node.js，然后安装 Npm，接着运行如下命令：</p><pre><code class="bash">npx extract-stealth-evasions </code></pre><p>就会在你执行命令的文件夹下面生成一个<code>stealth.min.js</code>文件。然后你就可以正常使用了。<br>如果你在国内，那么执行这个命令的过程中，会有一个下载 Chromium 的过程，速度非常慢，虽然只有130MB，但是可能会下载好几个小时。<br>此时，你需要把它的<code>package.json</code>和<code>index.js</code>两个文件保存到本地。然后打开<code>package.json</code>文件，修改其中的<code>dependencies</code>这一项，把里面的<code>puppeteer</code>改成<code>puppeteer-core</code>，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/最完美方案！模拟浏览器如何正确隐藏特征/1654940870.356005.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后修改<code>index.js</code>，给<code>.launch()</code>函数增加一个参数<code>executablePath</code>，指向你电脑上的 Chrome 浏览器，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/最完美方案！模拟浏览器如何正确隐藏特征/1654940870.654757.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>修改完成以后。首先执行<code>yarn install</code>安装依赖包。然后执行<code>node index.js</code>运行程序。1秒钟以后就会生成<code>stealth.min.js</code>了。<br>如果你对 Node.js 的工具链不熟悉，不知道如何使用。那么你可以关注公众号未闻 Code，回复<code>stealth</code>获取这个 js 文件。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&mid=2648979719&idx=1&sn=71fe9932ae38f2f630f9c817033401dd&chksm=f25064e7c527edf17d617ef28928982c7df6e248d8980758c22a9e0cac67993d51f42da21031&cur_album_id=1318368205836189696&scene=189#wechat_redirect" target="_blank" rel="noopener">最完美方案！模拟浏览器如何正确隐藏特征</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_运维必会的150个常用命令，你都会用吗？</title>
      <link href="/2022/06/10/Linux_%E8%BF%90%E7%BB%B4%E5%BF%85%E4%BC%9A%E7%9A%84150%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BD%A0%E9%83%BD%E4%BC%9A%E7%94%A8%E5%90%97%EF%BC%9F/"/>
      <url>/2022/06/10/Linux_%E8%BF%90%E7%BB%B4%E5%BF%85%E4%BC%9A%E7%9A%84150%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BD%A0%E9%83%BD%E4%BC%9A%E7%94%A8%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>linux 命令是对 Linux 系统进行管理的命令。对于 Linux 系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件， Linux 系统管理的命令是它正常运行的核心，与之前的 DOS 命令类似。linux 命令在系统中有两种类型：内置 Shell 命令和 Linux 命令。</p><h3 id="线上查询及帮助命令-2-个"><a href="#线上查询及帮助命令-2-个" class="headerlink" title="线上查询及帮助命令 (2 个)"></a>线上查询及帮助命令 (2 个)</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>man</td><td>查看命令帮助，命令的词典，更复杂的还有 info，但不常用。</td></tr><tr><td>help</td><td>查看 Linux 内置命令的帮助，比如 cd 命令。</td></tr></tbody></table><h3 id="文件和目录操作命令-18-个"><a href="#文件和目录操作命令-18-个" class="headerlink" title="文件和目录操作命令 (18 个)"></a>文件和目录操作命令 (18 个)</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>ls</td><td>全拼 list，功能是列出目录的内容及其内容属性信息。</td></tr><tr><td>cd</td><td>全拼 change directory，功能是从当前工作目录切换到指定的工作目录。</td></tr><tr><td>cp</td><td>全拼 copy，其功能为复制文件或目录。</td></tr><tr><td>find</td><td>查找的意思，用于查找目录及目录下的文件。</td></tr><tr><td>mkdir</td><td>全拼 make directories，其功能是创建目录。</td></tr><tr><td>mv</td><td>全拼 move，其功能是移动或重命名文件。</td></tr><tr><td>pwd</td><td>全拼 print working directory，其功能是显示当前工作目录的绝对路径。</td></tr><tr><td>rename</td><td>用于重命名文件。</td></tr><tr><td>rm</td><td>全拼 remove，其功能是删除一个或多个文件或目录。</td></tr><tr><td>rmdir</td><td>全拼 remove empty directories，功能是删除空目录。</td></tr><tr><td>touch</td><td>创建新的空文件，改变已有文件的时间戳属性。</td></tr><tr><td>tree</td><td>功能是以树形结构显示目录下的内容。</td></tr><tr><td>basename</td><td>显示文件名或目录名。</td></tr><tr><td>dirname</td><td>显示文件或目录路径。</td></tr><tr><td>chattr</td><td>改变文件的扩展属性。</td></tr><tr><td>lsattr</td><td>查看文件扩展属性。</td></tr><tr><td>file</td><td>显示文件的类型。</td></tr><tr><td>md5sum</td><td>计算和校验文件的 MD5 值。</td></tr></tbody></table><h3 id="查看文件及内容处理命令（21-个）"><a href="#查看文件及内容处理命令（21-个）" class="headerlink" title="查看文件及内容处理命令（21 个）"></a>查看文件及内容处理命令（21 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>cat</td><td>全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。</td></tr><tr><td>tac</td><td>tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。</td></tr><tr><td>more</td><td>分页显示文件内容。</td></tr><tr><td>less</td><td>分页显示文件内容，more 命令的相反用法。</td></tr><tr><td>head</td><td>显示文件内容的头部。</td></tr><tr><td>tail</td><td>显示文件内容的尾部。</td></tr><tr><td>cut</td><td>将文件的每一行按指定分隔符分割并输出。</td></tr><tr><td>split</td><td>分割文件为不同的小片段。</td></tr><tr><td>paste</td><td>按行合并文件内容。</td></tr><tr><td>sort</td><td>对文件的文本内容排序。</td></tr><tr><td>uniq</td><td>去除重复行。oldboy</td></tr><tr><td>wc</td><td>统计文件的行数、单词数或字节数。</td></tr><tr><td>iconv</td><td>转换文件的编码格式。</td></tr><tr><td>dos2unix</td><td>将 DOS 格式文件转换成 UNIX 格式。</td></tr><tr><td>diff</td><td>全拼 difference，比较文件的差异，常用于文本文件。</td></tr><tr><td>vimdiff</td><td>命令行可视化文件比较工具，常用于文本文件。</td></tr><tr><td>rev</td><td>反向输出文件内容。</td></tr><tr><td>grep/egrep</td><td>过滤字符串，三剑客老三。</td></tr><tr><td>join</td><td>按两个文件的相同字段合并。</td></tr><tr><td>tr</td><td>替换或删除字符。</td></tr><tr><td>vi/vim</td><td>命令行文本编辑器。</td></tr></tbody></table><h3 id="文件压缩及解压缩命令（4-个）"><a href="#文件压缩及解压缩命令（4-个）" class="headerlink" title="文件压缩及解压缩命令（4 个）"></a>文件压缩及解压缩命令（4 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>tar</td><td>打包压缩。oldboy</td></tr><tr><td>unzip</td><td>解压文件。</td></tr><tr><td>gzip</td><td>gzip 压缩工具。</td></tr><tr><td>zip</td><td>压缩工具。</td></tr></tbody></table><h3 id="信息显示命令（11-个）"><a href="#信息显示命令（11-个）" class="headerlink" title="信息显示命令（11 个）"></a>信息显示命令（11 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>uname</td><td>显示操作系统相关信息的命令。</td></tr><tr><td>hostname</td><td>显示或者设置当前系统的主机名。</td></tr><tr><td>dmesg</td><td>显示开机信息，用于诊断系统故障。</td></tr><tr><td>uptime</td><td>显示系统运行时间及负载。</td></tr><tr><td>stat</td><td>显示文件或文件系统的状态。</td></tr><tr><td>du</td><td>计算磁盘空间使用情况。</td></tr><tr><td>df</td><td>报告文件系统磁盘空间的使用情况。</td></tr><tr><td>top</td><td>实时显示系统资源使用情况。</td></tr><tr><td>free</td><td>查看系统内存。</td></tr><tr><td>date</td><td>显示与设置系统时间。</td></tr><tr><td>cal</td><td>查看日历等时间信息。</td></tr></tbody></table><h3 id="搜索文件命令（4-个）"><a href="#搜索文件命令（4-个）" class="headerlink" title="搜索文件命令（4 个）"></a>搜索文件命令（4 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>which</td><td>查找二进制命令，按环境变量 PATH 路径查找。</td></tr><tr><td>find</td><td>从磁盘遍历查找文件或目录。</td></tr><tr><td>whereis</td><td>查找二进制命令，按环境变量 PATH 路径查找。</td></tr><tr><td>locate</td><td>从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。</td></tr></tbody></table><h3 id="用户管理命令（10-个）"><a href="#用户管理命令（10-个）" class="headerlink" title="用户管理命令（10 个）"></a>用户管理命令（10 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>useradd</td><td>添加用户。</td></tr><tr><td>usermod</td><td>修改系统已经存在的用户属性。</td></tr><tr><td>userdel</td><td>删除用户。</td></tr><tr><td>groupadd</td><td>添加用户组。</td></tr><tr><td>passwd</td><td>修改用户密码。</td></tr><tr><td>chage</td><td>修改用户密码有效期限。</td></tr><tr><td>id</td><td>查看用户的 uid,gid 及归属的用户组。</td></tr><tr><td>su</td><td>切换用户身份。</td></tr><tr><td>visudo</td><td>编辑 / etc/sudoers 文件的专属命令。</td></tr><tr><td>sudo</td><td>以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。</td></tr></tbody></table><h3 id="基础网络操作命令（11-个）"><a href="#基础网络操作命令（11-个）" class="headerlink" title="基础网络操作命令（11 个）"></a>基础网络操作命令（11 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>telnet</td><td>使用 TELNET 协议远程登录。</td></tr><tr><td>ssh</td><td>使用 SSH 加密协议远程登录。</td></tr><tr><td>scp</td><td>全拼 secure copy，用于不同主机之间复制文件。</td></tr><tr><td>wget</td><td>命令行下载文件。</td></tr><tr><td>ping</td><td>测试主机之间网络的连通性。</td></tr><tr><td>route</td><td>显示和设置 linux 系统的路由表。</td></tr><tr><td>ifconfig</td><td>查看、配置、启用或禁用网络接口的命令。</td></tr><tr><td>ifup</td><td>启动网卡。</td></tr><tr><td>ifdown</td><td>关闭网卡。</td></tr><tr><td>netstat</td><td>查看网络状态。</td></tr><tr><td>ss</td><td>查看网络状态。</td></tr></tbody></table><h3 id="深入网络操作命令（9-个）"><a href="#深入网络操作命令（9-个）" class="headerlink" title="深入网络操作命令（9 个）"></a>深入网络操作命令（9 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>nmap</td><td>网络扫描命令。</td></tr><tr><td>lsof</td><td>全名 list open files，也就是列举系统中已经被打开的文件。</td></tr><tr><td>mail</td><td>发送和接收邮件。</td></tr><tr><td>mutt</td><td>邮件管理命令。</td></tr><tr><td>nslookup</td><td>交互式查询互联网 DNS 服务器的命令。</td></tr><tr><td>dig</td><td>查找 DNS 解析过程。</td></tr><tr><td>host</td><td>查询 DNS 的命令。</td></tr><tr><td>traceroute</td><td>追踪数据传输路由状况。</td></tr><tr><td>tcpdump</td><td>命令行的抓包工具。</td></tr></tbody></table><h3 id="有关磁盘与文件系统的命令（16-个）"><a href="#有关磁盘与文件系统的命令（16-个）" class="headerlink" title="有关磁盘与文件系统的命令（16 个）"></a>有关磁盘与文件系统的命令（16 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>mount</td><td>挂载文件系统。</td></tr><tr><td>umount</td><td>卸载文件系统。</td></tr><tr><td>fsck</td><td>检查并修复 Linux 文件系统。</td></tr><tr><td>dd</td><td>转换或复制文件。</td></tr><tr><td>dumpe2fs</td><td>导出 ext2/ext3/ext4 文件系统信息。</td></tr><tr><td>dump</td><td>ext2/3/4 文件系统备份工具。</td></tr><tr><td>fdisk</td><td>磁盘分区命令，适用于 2TB 以下磁盘分区。</td></tr><tr><td>parted</td><td>磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。</td></tr><tr><td>mkfs</td><td>格式化创建 Linux 文件系统。</td></tr><tr><td>partprobe</td><td>更新内核的硬盘分区表信息。</td></tr><tr><td>e2fsck</td><td>检查 ext2/ext3/ext4 类型文件系统。</td></tr><tr><td>mkswap</td><td>创建 Linux 交换分区。</td></tr><tr><td>swapon</td><td>启用交换分区。</td></tr><tr><td>swapoff</td><td>关闭交换分区。</td></tr><tr><td>sync</td><td>将内存缓冲区内的数据写入磁盘。</td></tr><tr><td>resize2fs</td><td>调整 ext2/ext3/ext4 文件系统大小。</td></tr></tbody></table><h3 id="系统权限及用户授权相关命令（4-个）"><a href="#系统权限及用户授权相关命令（4-个）" class="headerlink" title="系统权限及用户授权相关命令（4 个）"></a>系统权限及用户授权相关命令（4 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>chmod</td><td>改变文件或目录权限。</td></tr><tr><td>chown</td><td>改变文件或目录的属主和属组。</td></tr><tr><td>chgrp</td><td>更改文件用户组。</td></tr><tr><td>umask</td><td>显示或设置权限掩码。</td></tr></tbody></table><h3 id="查看系统用户登陆信息的命令（7-个）"><a href="#查看系统用户登陆信息的命令（7-个）" class="headerlink" title="查看系统用户登陆信息的命令（7 个）"></a>查看系统用户登陆信息的命令（7 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>whoami</td><td>显示当前有效的用户名称，相当于执行 id -un 命令。</td></tr><tr><td>who</td><td>显示目前登录系统的用户信息。</td></tr><tr><td>w</td><td>显示已经登陆系统的用户列表，并显示用户正在执行的指令。</td></tr><tr><td>last</td><td>显示登入系统的用户。</td></tr><tr><td>lastlog</td><td>显示系统中所有用户最近一次登录信息。</td></tr><tr><td>users</td><td>显示当前登录系统的所有用户的用户列表。</td></tr><tr><td>finger</td><td>查找并显示用户信息。</td></tr></tbody></table><h3 id="内置命令及其它（19-个）"><a href="#内置命令及其它（19-个）" class="headerlink" title="内置命令及其它（19 个）"></a>内置命令及其它（19 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>echo</td><td>打印变量，或直接输出指定的字符串</td></tr><tr><td>printf</td><td>将结果格式化输出到标准输出。</td></tr><tr><td>rpm</td><td>管理 rpm 包的命令。</td></tr><tr><td>yum</td><td>自动化简单化地管理 rpm 包的命令。</td></tr><tr><td>watch</td><td>周期性的执行给定的命令，并将命令的输出以全屏方式显示。</td></tr><tr><td>alias</td><td>设置系统别名。</td></tr><tr><td>unalias</td><td>取消系统别名。</td></tr><tr><td>date</td><td>查看或设置系统时间。</td></tr><tr><td>clear</td><td>清除屏幕，简称清屏。</td></tr><tr><td>history</td><td>查看命令执行的历史纪录。</td></tr><tr><td>eject</td><td>弹出光驱。</td></tr><tr><td>time</td><td>计算命令执行时间。</td></tr><tr><td>nc</td><td>功能强大的网络工具。</td></tr><tr><td>xargs</td><td>将标准输入转换成命令行参数。</td></tr><tr><td>exec</td><td>调用并执行指令的命令。</td></tr><tr><td>export</td><td>设置或者显示环境变量。</td></tr><tr><td>unset</td><td>删除变量或函数。</td></tr><tr><td>type</td><td>用于判断另外一个命令是否是内置命令。</td></tr><tr><td>bc</td><td>命令行科学计算器</td></tr></tbody></table><h3 id="系统管理与性能监视命令-9-个"><a href="#系统管理与性能监视命令-9-个" class="headerlink" title="系统管理与性能监视命令 (9 个)"></a>系统管理与性能监视命令 (9 个)</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>chkconfig</td><td>管理 Linux 系统开机启动项。</td></tr><tr><td>vmstat</td><td>虚拟内存统计。</td></tr><tr><td>mpstat</td><td>显示各个可用 CPU 的状态统计。</td></tr><tr><td>iostat</td><td>统计系统 IO。</td></tr><tr><td>sar</td><td>全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。</td></tr><tr><td>ipcs</td><td>用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。</td></tr><tr><td>ipcrm</td><td>用来删除一个或更多的消息队列、信号量集或者共享内存标识。</td></tr><tr><td>strace</td><td>用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</td></tr><tr><td>ltrace</td><td>命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。</td></tr></tbody></table><h3 id="关机-重启-注销和查看系统信息的命令（6-个）"><a href="#关机-重启-注销和查看系统信息的命令（6-个）" class="headerlink" title="关机 / 重启 / 注销和查看系统信息的命令（6 个）"></a>关机 / 重启 / 注销和查看系统信息的命令（6 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>shutdown</td><td>关机。</td></tr><tr><td>halt</td><td>关机。</td></tr><tr><td>poweroff</td><td>关闭电源。</td></tr><tr><td>logout</td><td>退出当前登录的 Shell。</td></tr><tr><td>exit</td><td>退出当前登录的 Shell。</td></tr><tr><td>Ctrl+d</td><td>退出当前登录的 Shell 的快捷键。</td></tr></tbody></table><h3 id="进程管理相关命令（15-个）"><a href="#进程管理相关命令（15-个）" class="headerlink" title="进程管理相关命令（15 个）"></a>进程管理相关命令（15 个）</h3><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>bg</td><td>将一个在后台暂停的命令，变成继续执行  （在后台执行）。</td></tr><tr><td>fg</td><td>将后台中的命令调至前台继续运行。</td></tr><tr><td>jobs</td><td>查看当前有多少在后台运行的命令。</td></tr><tr><td>kill</td><td>终止进程。</td></tr><tr><td>killall</td><td>通过进程名终止进程。</td></tr><tr><td>pkill</td><td>通过进程名终止进程。</td></tr><tr><td>crontab</td><td>定时任务命令。</td></tr><tr><td>ps</td><td>显示进程的快照。</td></tr><tr><td>pstree</td><td>树形显示进程。</td></tr><tr><td>nice/renice</td><td>调整程序运行的优先级。</td></tr><tr><td>nohup</td><td>忽略挂起信号运行指定的命令。</td></tr><tr><td>pgrep</td><td>查找匹配条件的进程。</td></tr><tr><td>runlevel</td><td>查看系统当前运行级别。</td></tr><tr><td>init</td><td>切换运行级别。</td></tr><tr><td>service</td><td>启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</td></tr></tbody></table><p>Linux，全称GNU/Linux，是一套免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年第一次释出，它主要受到Minix和Unix思想的启发，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://z.itpub.net/article/detail/E8C122A4CA07F3EC5952EE9F0B233DD4" target="_blank" rel="noopener">Linux_运维必会的150个常用命令，你都会用吗？</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium超级详细的教程</title>
      <link href="/2022/06/09/Selenium%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%99%E7%A8%8B/"/>
      <url>/2022/06/09/Selenium%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信搞过Python的人绝大部分都会一点点爬虫技能，但是很多时候爬虫也不是万能的，这个时候就需要我们的自动化测试框架了，于是Selenium就应运而生了，它可以算的上是自动化测试框架中的佼佼者，因为它解决了大多数用来爬取页面的模块的一个永远的痛，那就是Ajax异步加载，今天小编就带大家来好好了解下这个Selenium 。</p><h2 id="一、安装与导入"><a href="#一、安装与导入" class="headerlink" title="一、安装与导入"></a>一、安装与导入</h2><p>这里我们需要安装三个东西，一个是Selenium框架，还有一个浏览器，最后就是驱动。这里小编选择了谷歌浏览器。然后Selenium框架嘛，大家都会下的啦，PIP就搞定了，最后就是要下载个Chrome浏览器的驱动程序，为了让Selenium和浏览器之间产生关联的一个东西，下载地址：<a href="https://registry.npmmirror.com/binary.html?path=chromedriver/" target="_blank" rel="noopener">https://registry.npmmirror.com/binary.html?path=chromedriver/</a>。安装好浏览器后，将浏览器驱动放在浏览器同级目录下，这样前期工作就算都预备好了。<br>注：不要随便乱下浏览器和驱动，每个浏览器和驱动器的版本都必须是一一对应的，不是通用的。</p><h2 id="二、与浏览器建立连接"><a href="#二、与浏览器建立连接" class="headerlink" title="二、与浏览器建立连接"></a>二、与浏览器建立连接</h2><p>做好前面的准备工作，我们只需要写入几行Python代码即可与浏览器进行交互，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的驱动，并启动Chrome浏览器c.get(&#39;https://www.baidu.com&#39;)#打开百度</code></pre><h2 id="三、查找元素"><a href="#三、查找元素" class="headerlink" title="三、查找元素"></a>三、查找元素</h2><p>对于操作浏览器中的页面的自动化测试框架来说，肯定少不了 去发现网页中的元素，你只有发现那些元素实时存在了才能做出下一步的操作。Selenium中提供了众多的方法供我们去找到网页中的元素，这给我们带来了很大的便利，那么都有哪些方法了，我们可以通过Python快速获取到这些方法：</p><pre><code class="python">find_element                         #通过指定方法查找指定的一个元素(需指定两个参数)find_element_by_class_name           #通过Class name查找指定的一个元素find_element_by_css_selector         #通过CSS选择器查找指定的一个元素find_element_by_id                   #通过ID查找指定的一个元素find_element_by_link_text            #通过链接文本获取指定的一个超链接(精确匹配)find_element_by_name                 #通过Name查找指定的一个元素find_element_by_partial_link_text    #通过链接文本获取指定的一个超链接(模糊匹配)find_element_by_tag_name             #通过标签名查找指定的一个元素find_element_by_xpath                #通过Xpath语法来指定的一个元素find_elements                        #通过指定方法查找所有元素(需指定两个参数)find_elements_by_class_name          #通过Class name查找所有元素find_elements_by_css_selector        #通过CSS选择器查找所有元素find_elements_by_id                  #通过ID查找所有元素find_elements_by_link_text           #通过链接文本获取所有超链接(精确匹配)find_elements_by_name                #通过Name查找所有元素find_elements_by_partial_link_text   #通过链接文本获取所有超链接(模糊匹配)find_elements_by_tag_name            #通过标签名查找所有元素find_elements_by_xpath               #通过Xpath语法来查找所有元素</code></pre><p>可以看到输入框的ID为KW，Name为WD，这里我们选择ID，选择ID有三种方法，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byc=webdriver.Chrome(executable_path=r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)c.get(&#39;https://www.baidu.com&#39;)kw1=c.find_element(By.ID,&#39;kw&#39;)kw2=c.find_element_by_id(&#39;kw&#39;)kw3=c.find_elements_by_id(&#39;kw&#39;)[0]print(kw1)print(kw2)print(kw3)</code></pre><p>可以看到我们成功使用三种方法获取到了这个元素，其它方法差不多，都是一通百通，喜欢哪种方法就使用哪种方法。</p><h2 id="四、浏览器操作"><a href="#四、浏览器操作" class="headerlink" title="四、浏览器操作"></a>四、浏览器操作</h2><h3 id="1-获取本页面URL"><a href="#1-获取本页面URL" class="headerlink" title="1.获取本页面URL"></a>1.获取本页面URL</h3><pre><code class="python">c.current_url</code></pre><h3 id="2-获取日志"><a href="#2-获取日志" class="headerlink" title="2.获取日志"></a>2.获取日志</h3><pre><code class="python">c.log_types  #获取当前日志类型c.get_log(&#39;browser&#39;)#浏览器操作日志c.get_log(&#39;driver&#39;) #设备日志c.get_log(&#39;client&#39;) #客户端日志c.get_log(&#39;server&#39;) #服务端日志</code></pre><h3 id="3-窗口操作"><a href="#3-窗口操作" class="headerlink" title="3.窗口操作"></a>3.窗口操作</h3><pre><code class="python">c.maximize_window()#最大化c.fullscreen_window() #全屏c.minimize_window() #最小化c.get_window_position() #获取窗口的坐标c.get_window_rect()#获取窗口的大小和坐标c.get_window_size()#获取窗口的大小c.set_window_position(100,200)#设置窗口的坐标c.set_window_rect(100,200,32,50)    #设置窗口的大小和坐标c.set_window_size(400,600)#设置窗口的大小c.current_window_handle   #返回当前窗口的句柄c.window_handles         #返回当前会话中的所有窗口的句柄</code></pre><h3 id="4-设置延时"><a href="#4-设置延时" class="headerlink" title="4.设置延时"></a>4.设置延时</h3><pre><code class="python">c.set_script_timeout(5) #设置脚本延时五秒后执行c.set_page_load_timeout(5)#设置页面读取时间延时五秒</code></pre><h3 id="5-关闭"><a href="#5-关闭" class="headerlink" title="5.关闭"></a>5.关闭</h3><pre><code class="python">c.close() #关闭当前标签页c.quit() #关闭浏览器并关闭驱动</code></pre><h3 id="6-打印网页源代码"><a href="#6-打印网页源代码" class="headerlink" title="6.打印网页源代码"></a>6.打印网页源代码</h3><pre><code class="python">c.page_source</code></pre><h3 id="7-屏幕截图操作"><a href="#7-屏幕截图操作" class="headerlink" title="7.屏幕截图操作"></a>7.屏幕截图操作</h3><pre><code class="python">c.save_screenshot(&#39;1.png&#39;)#截图，只支持PNG格式c.get_screenshot_as_png() #获取当前窗口的截图作为二进制数据c.get_screenshot_as_base64() #获取当前窗口的截图作为base64编码的字符串</code></pre><h3 id="8-前进后退刷新"><a href="#8-前进后退刷新" class="headerlink" title="8.前进后退刷新"></a>8.前进后退刷新</h3><pre><code class="python">c.forward() #前进c.back()  #后退c.refresh()#刷新</code></pre><h3 id="9-执行JS代码"><a href="#9-执行JS代码" class="headerlink" title="9.执行JS代码"></a>9.执行JS代码</h3><p>在Selenium中也可以自定义JS代码并带到当前页面中去执行，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.get(&#39;https://www.baidu.com&#39;)kw1=c.find_element(By.ID,&#39;kw&#39;)c.execute_script(&quot;alert(&#39;hello&#39;)&quot;)time.sleep(3)c.quit()</code></pre><p>这里我使用一个JS中的函数来执行屏幕提示的功能，成功被执行。</p><h3 id="10-Cookies操作"><a href="#10-Cookies操作" class="headerlink" title="10.Cookies操作"></a>10.Cookies操作</h3><pre><code class="python">c.get_cookie(&#39;BAIDUID&#39;) #获取指定键的Cookiesc.get_cookies()         #获取所有的Cookiesfor y in c.get_cookies():   x=y   if x.get(&#39;expiry&#39;):       x.pop(&#39;expiry&#39;)        c.add_cookie(x) #添加Cookies  c.delete_cookie(&#39;BAIDUID&#39;) #删除指定键的Cookies内容c.delete_all_cookies() #删除所有cookies</code></pre><h3 id="11-获取标题内容"><a href="#11-获取标题内容" class="headerlink" title="11.获取标题内容"></a>11.获取标题内容</h3><pre><code class="python">c.title</code></pre><h3 id="12-获取当前浏览器名"><a href="#12-获取当前浏览器名" class="headerlink" title="12.获取当前浏览器名"></a>12.获取当前浏览器名</h3><pre><code class="python">c.name</code></pre><h3 id="13-全局超时时间"><a href="#13-全局超时时间" class="headerlink" title="13.全局超时时间"></a>13.全局超时时间</h3><pre><code class="python">c.implicitly_wait(5)</code></pre><h2 id="五、元素操作"><a href="#五、元素操作" class="headerlink" title="五、元素操作"></a>五、元素操作</h2><p>对我们找到的元素进行二次操作，不仅可以再次选择子元素还可以进行其它操作。如下：</p><pre><code class="python">kw1.clear()        #清除元素的值kw1.click()        #点击元素kw1.id             #Selenium所使用的内部IDkw1.get_property(&#39;background&#39;) #获取元素的属性的值kw1.get_attribute(&#39;id&#39;) #获取元素的属性的值kw1.location       #不滚动获取元素的坐标kw1.location_once_scrolled_into_view  #不滚动且底部对齐并获取元素的坐标kw1.parent         #父元素kw1.send_keys(&#39;&#39;)  #向元素内输入值kw1.size           #大小kw1.submit         #提交kw1.screenshot(&#39;2.png&#39;) #截取元素形状并保存为图片kw1.tag_name       #标签名kw1.text           #内容，如果是表单元素则无法获取kw1.is_selected()  #判断元素是否被选中kw1.is_enabled()   #判断元素是否可编辑kw1.is_displayed   #判断元素是否显示kw1.value_of_css_property(&#39;color&#39;) #获取元素属性的值kw1._upload(&#39;2.png&#39;) #上传文件</code></pre><h2 id="六、键盘鼠标操作"><a href="#六、键盘鼠标操作" class="headerlink" title="六、键盘鼠标操作"></a>六、键盘鼠标操作</h2><h3 id="1-模拟键盘输入和按键"><a href="#1-模拟键盘输入和按键" class="headerlink" title="1.模拟键盘输入和按键"></a>1.模拟键盘输入和按键</h3><pre><code class="python">from selenium.webdriver.common.keys import Keysc.find_element(By.ID,&#39;kw&#39;).send_keys(&#39;python&#39;)#输出Pythonc.find_element(By.ID,&#39;kw&#39;).send_keys(Keys.ENTER)#回车键c.find_element(By.ID,&#39;kw&#39;).click()#点击</code></pre><p>这里列举出了一个最简单的键盘输入和鼠标点击的例子，不过我们在Selenium中可以使用更为高逼格的操作，那么是什么了？当然是咱们的鼠标键盘监听事件来触发事件啦，而且它里面的方法的确也很多样化，满足小编日常的骚操作不在话下，如下所示：</p><pre><code class="python">click(on_element=None)                 #鼠标左键单击click_and_hold(on_element=None)        #单击鼠标左键，不松开context_click(on_element=None)         #单击鼠标右键double_click(on_element=None)          #双击鼠标左键drag_and_drop(source,target)           #拖拽到某个元素然后松开drag_and_drop_by_offset(source,xoffset,yoffset) #拖拽到某个坐标然后松开key_down(value,element=None)     #按下键盘上的某个键key_up(value, element=None)      #松开键盘上的某个键move_by_offset(xoffset, yoffset)  #鼠标从当前位置移动到某个坐标move_to_element(to_element)        #鼠标移动到某个元素move_to_element_with_offset(to_element, xoffset, yoffset) #移动到距某个元素（左上角坐标）多少距离的位置pause(seconds)                  #暂停所有输入(指定持续时间以秒为单位)perform()                       #执行所有操作reset_actions()                 #结束已经存在的操作并重置release(on_element=None)       #在某个元素位置松开鼠标左键send_keys(*keys_to_send)        #发送某个键或者输入文本到当前焦点的元素send_keys_to_element(element, *keys_to_send) #发送某个键到指定元素</code></pre><p>以上就是咱们鼠标和键盘的全部操作了，小编将用一个例子带大家零基础入门。如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.common.action_chains import ActionChainsc=webdriver.Chrome(executable_path=r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)c.get(&#39;https://www.baidu.com&#39;)a=ActionChains(c)kw1=c.find_element(By.ID,&#39;kw&#39;)tj=c.find_element(By.ID,&#39;su&#39;)tj.send_keys(Keys.CONTROL,&#39;c&#39;) #复制a.drag_and_drop(kw1,tj).perform()#从输入框拖动到搜索按钮kw1.send_keys(Keys.CONTROL,&#39;v&#39;)#粘贴tj.send_keys(Keys.ENTER)time.sleep(3)c.close()c.quit()</code></pre><p>这里我们通过对事件的监控，进行复制和粘贴，这里涉及到一个组合键的知识，大家注意。</p><h2 id="七、选项操作"><a href="#七、选项操作" class="headerlink" title="七、选项操作"></a>七、选项操作</h2><p>我们可以通过给当前操作的对象一些选项来增强交互能力，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.chrome.options import Optionso=Options()o.add_argument(&#39;--headless&#39;)#无界面浏览from selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;),options=o) #获取chrome浏览器的c.get(&#39;https://www.baidu.com&#39;)kw1=c.find_element(By.ID,&#39;kw&#39;)print(c.title)time.sleep(3)c.close()c.quit()</code></pre><p>这个时候就实现了咱们的无界面浏览了，也就是不用打开浏览器即可自动返回执行的结果。不过你可别以为选项就那么一两个，那可是多到你怀疑人生的，例如：</p><pre><code class="python">o.add_argument(&#39;--window-size=600,600&#39;) #设置窗口大小o.add_argument(&#39;--incognito&#39;) #无痕模式o.add_argument(&#39;--disable-infobars&#39;) #去掉chrome正受到自动测试软件的控制的提示o.add_argument(&#39;user-agent=&quot;XXXX&quot;&#39;) #添加请求头o.add_argument(&quot;--proxy-server=http://200.130.123.43:3456&quot;)#代理服务器访问o.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])#开发者模式o.add_experimental_option(&quot;prefs&quot;,{&quot;profile.managed_default_content_settings.images&quot;: 2})#禁止加载图片o.add_experimental_option(&#39;prefs&#39;,{&#39;profile.default_content_setting_values&#39;:{&#39;notifications&#39;:2}}) #禁用浏览器弹窗o.add_argument(&#39;blink-settings=imagesEnabled=false&#39;)  #禁止加载图片o.add_argument(&#39;lang=zh_CN.UTF-8&#39;) #设置默认编码为utf-8o.add_extension(create_proxyauth_extension(           proxy_host=&#39;host&#39;,           proxy_port=&#39;port&#39;,           proxy_username=&quot;username&quot;,           proxy_password=&quot;password&quot;       ))# 设置有账号密码的代理o.add_argument(&#39;--disable-gpu&#39;)  # 这个属性可以规避谷歌的部分bugo.add_argument(&#39;--disable-javascript&#39;)  # 禁用javascripto.add_argument(&#39;--hide-scrollbars&#39;)  # 隐藏滚动条o.binary_location=r&quot;C:\Users\Administrator\AppData\Local\Google\Chrome\Application&quot; #指定浏览器位置o.add_argument(&#39;--no-sandbox&#39;)  #解决DevToolsActivePort文件不存在的报错</code></pre><p>其实选项的添加无非就是分为以下这几种，如下：</p><pre><code class="python">o.set_headless()          #设置启动无界面化o.binary_location(value)  #设置chrome二进制文件位置o.add_argument(arg)               #添加启动参数o.add_extension(path)                #添加指定路径下的扩展应用o.add_encoded_extension(base64)      #添加经过Base64编码的扩展应用o.add_experimental_option(name,value)         #添加实验性质的选项o.debugger_address(value)                #设置调试器地址 o.to_capabilities()                    #获取当前浏览器的所有信息</code></pre><p>虽然选项很多，但是我们真正能用到的不多，一般就是无痕模式或者禁用JavaScript和图片来快速获取到相关信息。虽然我们上面使用的是Options方法，但是在实际应用中建议大家使用的ChromeOptions方法。</p><h2 id="八、框架操作-Frame-IFrame"><a href="#八、框架操作-Frame-IFrame" class="headerlink" title="八、框架操作(Frame/IFrame)"></a>八、框架操作(Frame/IFrame)</h2><p>我们还可以操作框架里的东西，比如IFrame，Frame等等，虽然都是框架，但是这两者操作起来还是有很大差别的。下面我们就来看看吧，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;https://hao.360.com/?a1004&#39;)#ss=c.find_element(By.CLASS_NAME,&#39;NEWS_FEED_VIDEO_1595850774217HPA70&#39;)#不容易找到标签c.switch_to.frame(0)#索引c.switch_to.frame(&#39;NEWS_FEED_VIDEO_1595850774217HPA70-VideoIframe&#39;) #IDc.switch_to.frame(&#39;NEWS_FEED_VIDEO_1595850774217HPA70&#39;)#Classc.switch_to.frame(c.find_element_by_tag_name(&quot;iframe&quot;))#标签time.sleep(3)c.close()c.quit()</code></pre><p>这里小编是以360浏览器的主页为例子，对它里面的IFrame进行访问，最有效的方法一般就是我上面提到的四种了。这里我们有时候因为这个框架需要加载才可以出来，所以很多时候是无法获取到的，因此我们只有使用滑动加载到出现这个标签或者ID，Class为可以获取到，这在刚才小编是说了的，大家可以往前看看，不过这个方法不推荐使用，为啥？因为开发者文档上是这样写的。我们的Frame由于是IFrame里的子集，所以上面的方法便是可以层层遍历的好方法，但是如果我们遍历到最后了如何返回主框架了，可以这样做，如下所示：</p><pre><code class="python">c.switch_to.default_content()</code></pre><p>这样就可以回到主框架继续进行操作了。如果我们由里往外遍历的话，那么可以这样来做，如下：</p><pre><code class="python">c.switch_to.parent_frame()</code></pre><h2 id="九、Alert"><a href="#九、Alert" class="headerlink" title="九、Alert"></a>九、Alert</h2><p>在弹窗处理中，我们会遇到三种情况，如下：<br>浏览器弹出框</p><ul><li>新窗口弹出框</li><li>人为弹出框<br>那么我们该怎么分辨了？下面跟我一起看看吧。</li></ul><h3 id="1-浏览器弹出框"><a href="#1-浏览器弹出框" class="headerlink" title="1.浏览器弹出框"></a>1.浏览器弹出框</h3><p>首先说说浏览器弹出框，想必大家对JavaScript中的Alert，Confirm，Prompt应该不是很陌生，就是弹出框，确认框，输入框；基本方法我们来看下，如下：</p><pre><code class="python">from selenium.webdriver.common.alert import Alertfrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;https://www.baidu.com&#39;)a1=Alert(c)a1.accept() #确定a1.dismiss() #取消a1.authenticate(username,password) #用户身份验证a1.send_keys(&#39;&#39;) #输入文本或按键a1.text  #获取弹窗内容</code></pre><p>这里我们应对每种情况它上面的方法的对应位置都是会有所变化的，所以我们需要根据具体情况来进行操作，而且还可以使用另一种方法，如下：</p><pre><code class="python">from selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;https://www.baidu.com&#39;)a1=c.switch_to_alert()a1.accept() #确定a1.dismiss() #取消a1.authenticate(username,password) #用户身份验证a1.send_keys(&#39;&#39;) #输入文本或按键a1.text  #获取弹窗内容</code></pre><p>注：该类方法必须在有弹框的情况下才有作用，如没有会报错。</p><h3 id="2-新窗口弹出框"><a href="#2-新窗口弹出框" class="headerlink" title="2.新窗口弹出框"></a>2.新窗口弹出框</h3><p>上面就是浏览器弹出框的处理方法了，如果是新窗口弹出的话那么就不一样了，我们需要通过句柄来定位，前面我们提到过这两个方法。下面我们来看看它们的具体用法，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;https://www.baidu.com&#39;)kw1=c.find_element(By.ID,&#39;kw&#39;)tj=c.find_element(By.ID,&#39;su&#39;)hwnd=c.window_handles #所有窗口句柄for h in hwnd:   if h !=c.current_window_handle:  #如果句柄不是当前窗口句柄则切换                          c.switch_to_window(h)  #切换窗口   else:       print(&#39;无需切换窗口&#39;) time.sleep(3)c.close()c.quit()</code></pre><p>注：如果有多个窗口，当你关闭了当前窗口想切换到另一个窗口，你需要把没关闭的窗口切换成当前活动窗口，因为Selenium是不会为你做这件事的。</p><h3 id="3-人为弹出框"><a href="#3-人为弹出框" class="headerlink" title="3.人为弹出框"></a>3.人为弹出框</h3><p>这类弹出框是我们自己开发的，一般都是使用Div包裹一些其它的元素标签然后形成一个整体，当我们触发某个事件的时候就会出现，否则消失。这种弹出框使用我们的众多Find前缀的方法就能遍历到，很方便，这里不一一细说。</p><h2 id="十、判断"><a href="#十、判断" class="headerlink" title="十、判断"></a>十、判断</h2><p>在Selenium中我们在做自动化测试时常无法判断一个元素是否真的显示出来了，因此会各种报错，接下来我们对这些操作进行判断，如果显示出了我们预期的值，那么就进行下一步操作，否则就关闭或者暂停几秒然后再判断，这里我要跟大家说Selenium中的一个模块—–Expected_Conditions，简称为EC，如下所示：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;https://baidu.com&#39;)t=EC.title_is(&#39;百度一下，你就知道&#39;)print(t(c))time.sleep(3)c.close()c.quit()</code></pre><p>这里其实就是判断当前页面的标题是否是我们给定的文本，可以看出这里为True，说明是。它不光就一个方法哦，还有其它的，小编在这里大致说下，如下所示：</p><pre><code class="python">EC.title_contains(&#39;&#39;)(c)#判断页面标题是否包含给定的字符串EC.presence_of_element_located(&#39;&#39;)(c) #判断某个元素是否加载到dom树里，该元素不一定可见EC.url_contains(&#39;&#39;)(c) #判断当前url是否包含给定的字符串EC.url_matches(&#39;&#39;)(c) #匹配URLEC.url_to_be(&#39;&#39;)(c)  #精确匹配EC.url_changes(&#39;&#39;)(c) #不完全匹配EC.visibility_of_element_located(&#39;&#39;)(c) #判断某个元素是否可见,可见代表元素非隐藏元素EC.visibility_of(&#39;&#39;)(c)   #跟上面一样，不过是直接传定位到的elementEC.presence_of_all_elements_located(&#39;&#39;)(c) #判断是否至少有1个元素存在于dom树中EC.visibility_of_any_elements_located(&#39;&#39;)(c) #判断是否至少一个元素可见，返回列表EC.visibility_of_all_elements_located(&#39;&#39;)(c) #判断是否所有元素可见，返回列表EC.text_to_be_present_in_element(&#39;&#39;)(c) #判断元素中的text是否包含了预期的字符串EC.text_to_be_present_in_element_value(&#39;&#39;)(c)#判断元素中value属性是否包含预期的字符串EC.frame_to_be_available_and_switch_to_it(&#39;&#39;)(c) # 判断该frame是否可以switch进去EC.invisibility_of_element_located(&#39;&#39;)(c) #判断某个元素是否不存在于dom树或不可见EC.element_to_be_clickable(&#39;&#39;)(c) #判断某个元素中是否可见并且可点击EC.staleness_of(&#39;&#39;)(c)  #等某个元素从dom树中移除EC.element_to_be_selected(&#39;&#39;)(c)  #判断某个元素是否被选中了,一般用在下拉列表EC.element_located_to_be_selected(&#39;&#39;)(c) #判断元组中的元素是否被选中EC.element_selection_state_to_be(&#39;&#39;)(c) #判断某个元素的选中状态是否符合预期EC.element_located_selection_state_to_be(&#39;&#39;)(c) #跟上面一样，只不过是传入locatedEC.number_of_windows_to_be(&#39;&#39;)(c)  #判断窗口中的数字是否符合预期EC.new_window_is_opened(&#39;&#39;)(c)  #判断新的窗口是否打开EC.alert_is_present(&#39;&#39;)(c)  #判断页面上是否存在alert</code></pre><p>这就是它全部的方法了，简直不要多简单。</p><h2 id="十一、选择"><a href="#十一、选择" class="headerlink" title="十一、选择"></a>十一、选择</h2><p>刚刚讲过判断，现在我们来说说选择，选择无非就是挑好的扔烂的，顺着思路来不会错，总体来讲还是挺简单的，如下：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.select import Selectimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.implicitly_wait(10)c.get(&#39;http://www.juliwz.cn/forum.php&#39;)s=Select(c.find_element_by_id(&#39;ls_fastloginfield&#39;))#实例化res=s.all_selected_options#全部选中子项res1=s.options#全部子项print(res)print(res1)time.sleep(3)c.close()c.quit()</code></pre><p>发觉主流网站都没有Select这个标签，于是找了个很冷门的网站，就一个Select。Select里面的方法也是相当多的，如下：</p><pre><code class="python">s.first_selected_option  #第一个选中的子项s.select_by_index(index) #根据索引选择s.select_by_value(value)   #根据值来选择s.select_by_visible_text(text)  #根据选项可见文本s.deselect_by_index(index)   #根据索引来取消选择s.deselect_by_value(value)   #根据值来取消选择s.deselect_by_visible_text(text)  #根据可见文本来取消选择s.deselect_all()                #取消所有选择</code></pre><h2 id="十二、显示等待和隐式等待"><a href="#十二、显示等待和隐式等待" class="headerlink" title="十二、显示等待和隐式等待"></a>十二、显示等待和隐式等待</h2><p>想必大家应该听过这个概念，显示等待就是浏览器在我们设置的时间内不断寻找，等到元素后才继续执行，如果没在规定时间内找到，也会抛异常；而隐式等待则是我们设置时间，然后程序去找元素，期间会不断刷新页面，到了时间仍然没找到就抛异常。这里有个常用的模块专门用来实现显示等待和隐式等待的，它就是”wait“,我们来看看吧。如下：</p><pre><code class="python">from selenium.webdriver.support.ui import WebDriverWaitfrom selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.chrome.service import Servicec=webdriver.Chrome(service=Service(r&#39;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&#39;)) #获取chrome浏览器的c.get(&#39;https://www.baidu.com/&#39;)su=WebDriverWait(c,10).until(lambda x:x.find_element_by_id(&#39;su&#39;)) su.location_once_scrolled_into_viewprint(su.get_attribute(&#39;value&#39;))time.sleep(3)c.close()c.quit()</code></pre><p>隐式等待很简单，就一行代码，如下：</p><pre><code class="python">c.implicitly_wait(10)</code></pre><p>它的等待时间适用于全局的环境，也就是任何地方找不到某个元素，它都将发挥作用，如果找得到，则不会产生作用。</p><h2 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h2><p>Selenium的内容其实还是挺丰富的，它还有手机端的自动化测试框架，不过小编先把WEB端讲完就可以了，毕竟也写了这么多了，日后有时间再慢慢了解。大家如果是对触摸活动事件感兴趣的也可以看看“touch_actions”这个模块。这个模块里集成的都是关于触摸屏的操作，里面也有很多的方法，小编之所以能把Selenium一天学完，还是Selenium模块中的文档比较给力，主要是介绍的比较好，让人能轻松联想到方法的使用，感激开源作者的无私奉献。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/343948620" target="_blank" rel="noopener">Selenium超级详细的教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议的基础</title>
      <link href="/2022/06/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/06/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>小编是一个非典型面试官，对于HTTP协议的第一个问题，一般人会问常用的状态码有哪些。小编不这么问，小编的问题是HTTP的全称是什么，把英语给我说出来！</p><h3 id="HTTP的全称是什么？"><a href="#HTTP的全称是什么？" class="headerlink" title="HTTP的全称是什么？"></a>HTTP的全称是什么？</h3><p>超文本传输协议，HyperText Transfer Protocol，这几个单词可别发走音了。所谓的超文本就是带标记的文本，刚开始的时候是指HTML。现在HTTP协议传输的东西可不只是HTML了，什么表单啊JSON啊XML啊文件啊都可以传输。</p><h3 id="HTTP常用的状态码有哪些？"><a href="#HTTP常用的状态码有哪些？" class="headerlink" title="HTTP常用的状态码有哪些？"></a>HTTP常用的状态码有哪些？</h3><p>大部分同学都知道200、404、500、302状态码。如果连404都不知道，是要被小编鄙视的。500错误为什么这么常见呢，因为在开发的时候老是出bug，一个大异常抛出来，浏览器就500了。500表示InternalServerError，也就是内部服务器错误，如果不是bug，一般就是数据库挂了。</p><p>再多问几个状态码很多人就不知道了，因为大多数公司的软件服务没有走标准的HTTP状态码，很多状态码从来就不会出现，同学们自然也不会知道。</p><p>400 Bad Request 用于参数验证，少了一个参数或者参数类型错误之类的。</p><p>502 Bad Gateway 后端服务挂掉或者压力过大的时候， Nginx接到的请求无法及时传递给后端的服务进行处理，这个时候就会出现502错误。这个也非常常见，知乎豆瓣网站经常开小差的时候发生的错误就是这个。</p><p>304 Not Modified 极少人知道这个状态码，因为大部分后端开发者的前端Javascript开发经验都严重不足。当你用Chrome打开一个经常访问的网站，看看Network传输的静态资源就可以看到很多304状态码。它表示该资源被浏览器缓存了不需要重新请求服务器。</p><p>401 Unauthorized 权限不足，这个很好理解，就是资源存在但是不让你访问。</p><p>403 Forbidden 资源禁止访问，如果你的IP列为黑名单了，就会发生这种错误。</p><p>其实还有很多状态码，小编也没去好好研究了，因为实在不会在工作中用到。感兴趣的请继续阅读维基百科</p><h3 id="HTTP有哪些Method？"><a href="#HTTP有哪些Method？" class="headerlink" title="HTTP有哪些Method？"></a>HTTP有哪些Method？</h3><p>GET 不解释，如果读者不知道，建议别在IT圈混了。</p><p>POST 一般用于创建或者修改资源，在RESTFUL规范里面POST只用来创建资源，并返回201 Created状态码表示创建成功。不过大多数网站都不遵循严格的RESTFUL规范，POST拿来做修改资源的事也是非常常见的。</p><p>PUT 对应于POST表示创建资源，PUT用于修改资源，PUT的参数必须是对象的全部属性，修改是覆盖式全部修改。</p><p>PATCH 对应于PUT的参数是对象的全部属性，PATCH的参数是部分属性，修改是局部字段修改。</p><p>DELETE 用于删除资源。</p><p>HEAD 不常用，跟GET差不多，区别就是不返回Body内容，只返回HTTP头信息。一般用于获取资源的元信息，比如长度，修改时间等</p><p>OPTIONS 跨域相关，后面再讲。</p><p>TRACE 小编没用过。</p><p>CONNECT 小编没用过。</p><p>后面三个感兴趣的去阅读一下RPC规范。小编大概看了一下，表示没怎么看懂，你行你上去挑战一下。</p><h3 id="HTTP协议格式是怎样的？"><a href="#HTTP协议格式是怎样的？" class="headerlink" title="HTTP协议格式是怎样的？"></a>HTTP协议格式是怎样的？</h3><p>HTTP的请求和响应的消息协议是一样的，分为三个部分，起始行、消息头和消息体。这三个部分以CRLF作为分隔符。最后一个消息头有两个CRLF，用来表示消息头部的结束。</p><p><img src="/images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/1654942891.695849.webp"></p><p>HTTP请求的起始行称为请求行，形如GET /index.html HTTP/1.1</p><p>HTTP响应的起始行称为状态行，形如200 ok</p><p>消息头部有很多键值对组成，多个键值对之间使用CRLF作为分隔符，也可以完全没有键值对。形如Content-Encoding: gzip</p><p>消息体是一个字符串，字符串的长度是由消息头部的Content-Length键指定的。如果没有Content-Length字段说明没有消息体，譬如GET请求就是没有消息体的，POST请求的消息体一般用来放置表单数据。GET请求的响应返回的页面内容也是放在消息体里面的。我们平时调用API返回的JSON内容都是放在消息体里面的。</p><h3 id="什么是分块传送？"><a href="#什么是分块传送？" class="headerlink" title="什么是分块传送？"></a>什么是分块传送？</h3><p>当浏览器向服务器请求一个资源时，这个资源是一个动态资源，服务器无法提前预知资源的大小，这个时候就可以使用分块传输。</p><p>服务器先生成一个thunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到全部资源传送完成。</p><p>分块传送需要在请求头增加一个特殊的键值对transfer-encoding: thunked，那么消息体的内容便是分块传送的。</p><p><img src="/images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/1654942891.876003.webp"><br>chunked传输格式如图所示，由一段一段的分块组合而成，每个块由一个长度行和一个分块体组成，最后一个分块长度为0表示结束。</p><h3 id="持久连接的机制是怎样的？"><a href="#持久连接的机制是怎样的？" class="headerlink" title="持久连接的机制是怎样的？"></a>持久连接的机制是怎样的？</h3><p>HTTP早期版本中每个请求都会发起一个连接，一个网页除了页面的HTML之外还会有很多静态资源以及诸多的API调用，如果每个请求都一个连接，势必网页的一次加载就会和服务器创建多次连接，这是非常浪费服务器资源的，同时也让客户端的访问速度慢了不少。HTTP1.0之后引入了Keep-Alive持久连接，在HTTP1.1版本中成为默认选项。它使得HTTP的一个连接可以连续服务多个请求，有效节省了资源，增加了客户端页面的加载速度。</p><p>持久连接也不宜一直保持，毕竟每个连接都会占用服务器资源，如果打开网页的人太多，那服务器资源也会紧张，所以一般服务器都会配置一个KeepAlive Timeout参数和KeepAlive Requests参数限制单个连接持续时长和最多服务的请求次数。</p><p>如果服务器设置的timeout时长为0，就退化到非持久连接。非持久连接会在响应头部增加一个头信息Connection: Close通知客户端在接受完当前响应后连接需要立即关闭。</p><p>同样浏览器也不会因为服务器将KeepAlive Timeout配置了无限长就不管不问一直持续保持连接。每个浏览器都有它自己的内置限制，具体限制浏览器厂商各有不同。</p><h3 id="什么叫Pipeline管线化？"><a href="#什么叫Pipeline管线化？" class="headerlink" title="什么叫Pipeline管线化？"></a>什么叫Pipeline管线化？</h3><p>HTTP1.0不支持管线化，同一个连接处理请求的顺序是逐个应答模式，处理一个请求就需要耗费一个TTL，也就是客户端到服务器的往返时间，处理N个请求就是N个TTL时长。当页面的请求非常多时，页面加载速度就会非常缓慢。</p><p><img src="/images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/1654942892.10225.webp"></p><p>从HTTP1.1开始要求服务器支持管线化，可以同时将多个请求发送到服务器，然后逐个读取响应。这个管线化和Redis的管线化原理是一样的，响应的顺序必须和请求的顺序保持一致。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/HTTP协议的基础/1654942892.30924.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="如何理解HTTP协议的无状态性？"><a href="#如何理解HTTP协议的无状态性？" class="headerlink" title="如何理解HTTP协议的无状态性？"></a>如何理解HTTP协议的无状态性？</h3><p>所谓HTTP协议的无状态性是指服务器的协议层无需为不同的请求之间建立任何相关关系，它特指的是协议层的无状态性。但是这并不代表建立在HTTP协议之上的应用程序就无法维持状态。应用层可以通过会话Session来跟踪用户请求之间的相关性，服务器会为每个会话对象绑定一个唯一的会话ID，浏览器可以将会话ID记录在本地缓存LocalStorage或者Cookie，在后续的请求都带上这个会话ID，服务器就可以为每个请求找到相应的会话状态。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/6844903581431103502" target="_blank" rel="noopener">天下无难试之HTTP协议面试刁难大全（上）</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鲜为人知的HTTP协议头字段详解大全「原创」</title>
      <link href="/2022/06/09/%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE%E5%A4%B4%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3%E5%A4%A7%E5%85%A8%E3%80%8C%E5%8E%9F%E5%88%9B%E3%80%8D/"/>
      <url>/2022/06/09/%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE%E5%A4%B4%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3%E5%A4%A7%E5%85%A8%E3%80%8C%E5%8E%9F%E5%88%9B%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>继上篇讲了<a href="/2022/06/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80/">HTTP协议的基础</a>之后，本篇重点介绍一下HTTP常用的Header。</p><p>HTTP Header非常之多，很少有人能完全分清这些Header到底是干什么的。鉴于RFC文件规范艰深晦涩难懂，本文对协议规范中列出的HTTP Header进行了梳理，用通俗的语言进行表达，便于读者吃透HTTP协议。</p><p>作者在阅读RFC文档的时候发现了很多以前没注意到的知识，估计做web开发的小伙伴们也大多忽视了这些知识，阅读文本会给你们带来很多意外的惊喜。</p><p>免责声明：如果下面有那句话有不对的地方，还请喷少点口水。</p><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p>表示客户端期望服务器返回的媒体格式。客户端期望的资源类型服务器可能没有，所以客户端会期望多种类型，并且设置优先级，服务器根据优先级寻找相应的资源返回给客户端。</p><pre><code class="bash">### 注意：先逗号分割类型，再分号分割属性Accept: audio/*; q=0.2, audio/basic</code></pre><p>表示audio/basic类型的资源优先，如果没有，就随便其它什么格式的audio资源都可以。q的取值范围是(0-1]，其具体值并没有意义，它仅用来排序优先级，如果没有q，默认q=1，也就是最高优先级。</p><h3 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h3><p>表示客户端期望服务器返回的内容的编码格式。它同Accept头一样，也可以指定多个编码，以q值代表优先级。</p><pre><code class="bash">### 注意：先逗号分割类型，再分号分割属性Accept-Charset: utf8, gbk; q=0.6</code></pre><p>表示utf8编码优先，如果不行，就拿gbk编码返回.</p><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p>Content-Type是服务器向客户端发送的头，代表内容的媒体类型和编码格式，是对Accept头和Accept-Charset头的统一应答。</p><pre><code class="bash">Content-Type: text/html; charset=utf8</code></pre><p>表示返回的Body是个html文本，编码为utf8</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/162586bc251399fb~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h3><p>表示客户端期望服务器返回的内容的语言。很多大型互联网公司是全球化的，它的技术文档一般有有多种语言，通过这个字段可以实现文档的本地化，对国内用户呈现简体中文文档，对英语系用户呈现英文文档。</p><pre><code class="bash">Accept-Language:zh-CN,en-US;q=0.8,zh-TW;q=0.6</code></pre><p>表示大陆简体中文优先，其次英语，再其次台湾繁体中文</p><h3 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h3><p>这个头字段内容是对Accept-Language的应答。服务器通过此字段告知客户端返回的Body信息的语言是什么。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/162586d170635751~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><p>表示传输的请求／响应的Body的长度。GET请求因为没有Body，所以不需要这个头。携带Body的并且可以提前知道Body长度的请求／响应必须带上这个字段，以便对方可以方便的分辨出报文的边界，也就是Body数据何时结束。如果Body太大，需要边计算边传输，不到最后计算结束是无法知道整个Body大小的，这个时候可以使用http分块传输，这个时候也是不需要Content-Length字段的。</p><h3 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h3><p>当客户端请求的资源在服务器有多个地址时，服务器可以通过Content-Location字段告知客户端其它的可选地址。这个字段比较少见。</p><h3 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h3><p>在Header中提供这个信息是用来做Body内容校验。它表示Body信息被md5算法处理后的base64字符串。这个字段也比较少见。因为校验机制在TCP层已经有实现了，再来一层校验并没有多大意义。另外资源的md5值往往用来放在后面的ETag头信息中作为资源的唯一标识来使用。</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>如果服务器没有缓存，那么Date就是响应的即时生成时间。如果服务器设有缓存，那么Date就是响应内容被缓存的时间。它必须符合规范里定义的特定格式，这种格式叫着HTTP-Date，不支持随意定义自己的时间格式。</p><pre><code class="bash">Date: Tue, 15 Nov 1994 08:12:31 GMT</code></pre><h3 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h3><p>表示资源缓存的年龄，也就是资源自缓存以来到现在已经过去了多少时间，单位是秒。</p><pre><code class="bash">Age: 86400</code></pre><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>服务器使用Expect头来告知对方资源何时失效。如果它的值等于Date头的值，就表示资源已经实效。</p><pre><code class="bash">Expires: Thu, 01 Dec 1994 16:00:00 GMT</code></pre><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>资源标签，每个资源可以提供多个标签信息。它一般用来和下面的If-Match和If-None-Match配合使用，用来判断缓存资源的有效性。比较常见的标签是资源的版本号，比如可以拿资源数据的md5校验码作为版本号。</p><h3 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h3><p>If-Match的值一般是上面提到的ETag的值，它常用于HTTP的乐观锁。所谓HTTP乐观锁，是指客户端先GET这个资源得到ETag中的版本号，然后发起一个资源修改请求PUT|PATCH时通过If-Match头来指定资源的版本号，如果服务器资源满足If-Match中指定的版本号，请求就会被执行。如果不满足，说明资源被并发修改了，就需要返回状态码为412 Precondition failed 的错误。客户端可以选择放弃或者重试整个过程。</p><h3 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h3><p>类似于If-Match，只是条件相反。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/162586e758846bfa~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h3><p>表示资源支持访问的HTTP Method类型。它是服务器对客户端的建议，告知对方请使用Allow中提到的Method来访问资源。</p><pre><code class="bash">Allow: GET, HEAD, PUT</code></pre><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>当客户端和服务器需要协商连接的属性时，可以使用Connection头部。比较常用的一个值是close，用来通知对方在当前请求结束后关闭连接。</p><pre><code class="bash">Connection: close</code></pre><h3 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h3><p>用于请求发送之前向服务器询问许可。譬如要向服务器发送一个很大的文件而不确定是否超出限制，就可以在请求头里携带一个Expect头部</p><pre><code class="bash">Expect: 100-continue</code></pre><p>如果服务器说不行，就会返回417 Expectation Failed错误告知客户端放弃。如果可以那就返回100 continue状态码告知客户端放马过来吧，于是客户端就会继续上传Body内容。如果服务器提前收到Body内容就会放弃返回100 continue响应。</p><h3 id="From"><a href="#From" class="headerlink" title="From"></a>From</h3><p>该字段一般用来标记请求发起者的邮件地址，相当于给请求赋予一个责任人。如果服务器发现请求存在问题，就会通过此字段联系到发起人进行处理。因为邮件地址涉及到隐私信息，所以请求携带From头需要征得用户的同意。RFC协议建议所有的机器人代理发起的请求应该携带此头部，以免遇到问题时可以找到责任人。不过如果是恶意的机器人，估计这样的建议也只是耳边风而已。</p><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>RFC协议规定所有的HTTP请求必须携带Host头，即使Host没有值，也必须带上这个Host头附加一个空串，如果不满足，应用服务器应该抛出400 Bad Request。协议虽然这样规定，不过大部分网关或者服务器都比较仁慈，既然没有指定Host字段，那就给你默认加上一个。<br>网关代理可以根据不同的Host值转发到不同的upstream服务节点，它常用于虚拟主机服务业务。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/162586f22829c30a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>标记资源的最近修改时间，它和Date比较类似，区别是Last-Modified代表修改时间，而Date是创建时间。</p><h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p>浏览器向服务器请求静态资源时，如果浏览器本地已经有了缓存，就会携带If-Modified-Since头，值为资源的Last-Modified时间，询问服务器该资源自从这个Last-Modified时间之后有没有被修改。如果没有修改过，就会向浏览器返回304 Not Modified通知浏览器可以放心使用缓存内的资源。如果资源修改过，那就像正常的GET请求一样，携带资源的内容返回200 OK。</p><h3 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h3><p>类似于If-Modified-Since，意义相反。区别是当服务器资源条件不满足时，不是返回304 Not Modified，而是返回412 Precondition Failed。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/162586fbf1ce6825~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>支持断点续传的服务器必须处理Range头，它表示客户端请求资源的一部分时指定的请求字节范围。它是客户端向服务器发送的请求头。</p><pre><code class="bash">Range: bytes=500-999</code></pre><h3 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h3><p>针对上面的Range头，服务器响应客户端时也需提供相应的Content-Range头，表示传输的Body数据在整体资源块中的字节范围。比如下面的例子表示该资源总共有47022字节，当前响应的内容是21010-47021字节之间的内容。</p><pre><code class="bash">Content-Range: bytes 21010-47021/47022</code></pre><p>之所以是47021而不是47022是因为offset是以0开始的，47021就是最后一个字节。</p><h3 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h3><p>在断点续传时，为确保连续2个请求之间服务器资源本身没有发生变化，需要If-Range头带上ETag的资源版本号。服务器资源根据这个版本号来判定资源是否改变了。如果没变，就返回206 Partial Content将部分资源返回。如果资源变了，那就相当于一个普通的GET请求，返回200 OK和整个资源内容。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/16258703f0d9dbfe~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>服务器向客户端发送302跳转的时候，总会携带Location头信息，它的值为目标URL。</p><pre><code class="bash">HTTP/1.1 302 Temporary RedirectLocation: https://www-temp.example.org/</code></pre><h3 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h3><p>用来限定网关或者代理的层数，也就是最大转发次数。HTTP每经过一个网关或者代理层，Max-Forwards值就要减1。如果nginx接收到前端请求的时候Max-Forwards已经等于0，那么它就不应该再将请求转发到upstream指定的服务节点上。</p><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>这个头是比较常见的，在前端开发模式下经常会加上这个头部。</p><pre><code class="bash">Pragma: no-cache</code></pre><p>当网关收到一个带有这样请求的头部时，即使内部存在该请求资源的缓存并且有效也不可以直接发送给客户端，而必须转发给后面的upstream进行处理。<br>不过如果真的所有的网关都遵循这个协议的话，攻击是很容易构造的，所以它一般仅用于开发模式，防止静态资源修改后前端得不到即时更新。其它值的pragma值没有遇到过。</p><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><p>Referer是非常常用的头，它表示请求的发起来源URI，也就是当前页面资源的父页面。如果你从A页面跳转到B页面，那么请求B页面的请求头里面就会有Referer信息，它的值就是A页面的访问地址。通过追踪Referer，可得出资源页面之间复杂的跳转链，它非常适合用于网页的数据分析和路径优化。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/16257fe9b60eb4c0~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h3><p>服务器升级时，来自客户端的请求会直接给予503(Service Unavailable)错误，通过在返回头里面加入Retry-After字段告知客户端何时服务可以恢复正常访问。Retry-After的头可以是HTTP-Date，也可以是整数，表示多少秒后服务可以恢复正常访问。浏览器在拿到这个值之后可以考虑增加一个定时器在未来的某个时间进行重试。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>用于返回服务器相关的软件信息，来告知客户端当前的HTTP服务是由某某软件提供的，可以看成是一种软件广告。<br>RFC协议里对这个头信息做了警告：暴露出服务器信息可能会导致黑客更易于攻击你的服务，建议谨慎使用。</p><h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><p>携带当前的用户代理信息，一般包含浏览器、浏览器内核和操作系统的版本型号信息。它和Server头是对应的，一个是表达服务器信息，一个是表达客户端信息。服务器可以根据用户代理信息统计出网页服务的浏览器、操作系统的使用占比情况，服务器也可以根据UA的信息来定制不一样的内容。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/16257d74bf4f123a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h3><p>传送Body信息时需要对Body数据采取何种变换。当HTTP对Body进行分块传送时，需要增加下面的头部信息才可以进行分块传送。其它类型目前没有遇到过。</p><pre><code class="bash">Transfer-Encoding: chunked</code></pre><h3 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h3><p>服务器建议客户端升级传输协议。比如当客户端使用HTTP/1.0发送请求时，服务器就可以建议客户端升级到HTTP/1.1。<br>这个时候就可以使用Upgrade头。客户端收到这个Upgrade后就会将后续请求转成HTTP/1.1格式继续进行交流。可以支持多个参数，使用逗号分割即可。</p><pre><code class="bash">Upgrade: HTTP/1.1</code></pre><p>当客户端要和服务器进行Websocket进行通讯时，在握手阶段服务器也会向客户端发送Upgrade头部信息，提示客户端将协议切换到Websocket。</p><pre><code class="bash">Upgrade: WebSocket</code></pre><h3 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h3><p>该头部用于缓存控制。对于一些缓存服务器，我们在请求里加入Vary参数可以告知缓存服务器对不同的Vary参数的响应使用不同的缓存单元。比如Vary参数里放入编码参数，那么不同编码的网页就会有不同的缓存。Vary的值可以有多个，只要任意一个值不一样就会有不同的缓存。<br>比如下面的这个例子告知缓存服务器对不同语言和不同编码的网页响应使用不同的缓存单元。</p><pre><code class="bash">Vary: Accept-Encoding,Accept-Language</code></pre><h3 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h3><p>该字段用来标识一个请求经过的网关路由节点。如果这个请求经过了多个代理层，Via头部就会有多个网关信息。</p><h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><p>用于在响应中添加一些附加的警告信息，警告信息包含一个错误码和错误说明。通用的一些错误码在RFC协议中有具体规定。比如111号错误码表示缓存服务器的缓存项目已经过期，并且尝试reload资源，但是reload失败了，所以只好返回了旧的已经过期的内容，这个时候就需要通过warning头反馈客户端。</p><pre><code class="bash">Warning: 111 Revalidation failed</code></pre><h3 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h3><p>WWW-Authenticate是401 Unauthorized错误码返回时必须携带的头，该头会携带一个问题Challenge给客户端，告知客户端需要携带这个问题的答案来请求服务器才可以继续访问目标资源。这种问题Challenge可以自定义，比较常见的是Basic认证。</p><pre><code class="bash">WWW-Authenticate: Basic realm=xxx</code></pre><p>Basic指代base64加密算法(不安全)，realm指代认证范围/场合/情景名称。</p><h3 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h3><p>对于某些需要特殊权限才能访问的资源需要客户端在请求里提供用户名密码的认证信息。它是对WWW-Authenticate的应答。</p><pre><code class="bash">### value = base64(user_name:password)Authorization: Basic YWRtaW46YWRtaW4xMjM=</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/24/1625870c7cc549fb~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h3 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h3><p>同WWW-Authorization头部，用于代理服务器认证。</p><h3 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h3><p>同Authorization头部，用于代理服务器认证。</p><h3 id="ETag-vs-Last-Modified-vs-Expires"><a href="#ETag-vs-Last-Modified-vs-Expires" class="headerlink" title="ETag vs Last-Modified vs Expires"></a>ETag vs Last-Modified vs Expires</h3><p>ETag一般携带的是资源的版本号，协议没有具体规定版本号是什么。它可以是资源的md5校验码，也可以是uuid，甚至可以是自增的数字，也可以是资源的修改时间。它的匹配方式是相等/不相等。因为服务器需要维护版本号，取决的版本号是什么，这可能是一个存储和计算的负担。</p><p>Last-Modified携带的资源的修改时间。它的匹配方式是大于/小于。如果是静态资源文件，一般就是操作系统记录的文件修改时间。</p><p>Expires是服务器告知客户端资源的过期时间。客户端缓存的资源在这个时间之后自动过期，而不需要非得向服务器确认一下是不是304 Not Modified才认为没过期。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>这可能是HTTP头里面最复杂的一个头了。这个头既可以用于请求，也可以用于响应。在请求和响应的取值不一样，分别代表了不同的意思。</p><ul><li><p>no-cache 如果no-cache没有指定值，那就表示不允许缓存。对于请求来说，服务器不得使用缓存内容直接返回。对于响应来说，客户端不得缓存响应的资源内容。如果no-cache指定了值，那就表示值对应的头信息不得使用缓存，其它的信息还是可以缓存的。告知对方我只要新鲜刚出浴的数据。</p></li><li><p>no-store 告知对方不要持久化请求/响应数据到其它地方，这种信息是敏感的，要保持它的易失性。告知对方记在心里(memory)就行，别写在纸上(disk)。</p></li><li><p>no-transform 告知对方不要转换数据。比如客户端上传了raw图像数据，服务器一般都会选择性压缩图像数据进行存储。no-transform告知对方保留原始数据信息，不要进行任何转换。告知对方不要乱动我发过来的东西。</p></li><li><p>only-if-cached 用于请求头，告知服务器只要那些已经缓存的内容，不要去reload。如果没有缓存内容就返回504 Gateway Timeout错误。表示客户端不想太麻烦服务器，有就给，没就算了。</p></li><li><p>max-age 用于请求头。限制缓存内容的年龄，如果超过max-age年龄的，需要服务器去reload内容资源。这叫客户端的年龄歧视。</p></li><li><p>max-stale 用于请求头。客户端允许服务器返回缓存已过期的资源内容，但是限定了最大过期时间。表示客户端虽然很宽容，那是也是有限度的。</p></li><li><p>min-fresh 用于请求头。客户端限制服务器不要那些即将过期的资源内容。就好比我们去超市买牛奶，如果牛奶快过期了虽然还在保质期内咱们也就不会考虑。</p></li><li><p>public 用于响应头。表示允许客户端缓存响应信息，并可以给别人使用。比如代理服务器缓存静态资源供所有代理用户使用。</p></li><li><p>private 用于响应头。表示仅允许客户端缓存响应信息给自己使用，不得分享给别人。这样是为了禁止代理服务器进行缓存，而允许客户端自己缓存资源内容。意思是你个人留着用就行，别借给别人用。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>virtualenvwrapper：Python_环境管理工具</title>
      <link href="/2022/06/08/virtualenvwrapper%EF%BC%9APython_%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/06/08/virtualenvwrapper%EF%BC%9APython_%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>在使用 Python 开发的过程中，工程一多，难免会碰到不同的工程依赖不同版本的库的问题；亦或者是在开发过程中不想让物理环境里充斥各种各样的库，引发未来的依赖灾难。如果我们要同时开发多个应用程序，那这些应用程序都会共用一个 Python，就是安装在系统的 Python 3。如果应用 A 需要  jinja 2.7，而应用 B 需要 jinja 2.6 怎么办？此时，我们需要对于不同的工程使用不同的虚拟环境来保持开发环境以及宿主环境的清洁。为了不污染全局环境，通常都会使用环境隔离管理工具 <code>virtualenv</code> 与 <code>virtualenvwrapper</code>。<br><code>virtualenv</code> 是在项目底下执行生成 <code>venv</code> 环境目录以此来进行管理，这非常适合使用诸如 <code>VSCode</code> 这种集成环境配置的开发工具；那么当通过 shell 来运行 <code>virtualenv</code> 时便会显得非常麻烦，因为每次 shell 关闭再打开后都需要重新配置环境参数。<br><code>virtualenv</code> 需要每次使用 source 命令导入虚拟机运行环境，这一点非常麻烦，另外开发者还有可能忘记虚拟环境目录的建立位置，<code>virtualenvwrapper</code> 这一命令行工具就是通过对 <code>virtualenv</code> 进行封装，解决了上述问题。<code>virtualenvwrapper</code> 是将所有的 Python 项目虚拟环境环境都存放在一起，在使用 shell 配合小型开发工具就会非常方便。</p><h2 id="virtualenvwrapper-安装配置（Mac）"><a href="#virtualenvwrapper-安装配置（Mac）" class="headerlink" title="virtualenvwrapper 安装配置（Mac）"></a>virtualenvwrapper 安装配置（Mac）</h2><p>使用 pip3 安装，<code>virtualenv</code> 也会在此期间安装完毕</p><pre><code class="bash">$ sudo pip3 install virtualenvwrapper</code></pre><p>新建存放环境目录</p><pre><code class="bash">$ mkdir -p ~/.virtualenvs</code></pre><p>配置 <code>virtualenvwrapper</code> 环境（使用 python 3），打开 .zshrc，执行 <code>vim ~/.zshrc</code> 并写入(如果有安装<code>item2</code>与<code>oh-my-zsh</code>)</p><pre><code class="bash"># 设置virtualenvwrapper    export WORKON_HOME=&quot;~/.virtualenvs&quot;    export VIRTUALENVWRAPPER_PYTHON=&quot;/usr/local/bin/python3&quot;    # 打开终端自动启用    source /usr/local/bin/virtualenvwrapper.sh</code></pre><p>使配置生效</p><pre><code class="bash">$ source ~/.zshrc</code></pre><h2 id="virtualenvwrapper-使用"><a href="#virtualenvwrapper-使用" class="headerlink" title="virtualenvwrapper 使用"></a>virtualenvwrapper 使用</h2><p>新建虚拟环境 <code>Test</code> 并指定 Python 版本为 Python3：</p><pre><code class="bash">$ mkvirtualenv Test --python=python3</code></pre><p>执行 <code>lsvirtualenv</code> 指令查看所有环境，环境 <code>Test</code> 位于 ~/Envs/test</p><pre><code class="bash">$ lsvirtualenv    Test    ==== </code></pre><p>在项目底下激活虚拟环境 <code>Test</code>：</p><pre><code class="bash">$ workon Test</code></pre><p>其他指令：</p><pre><code class="bash">## 退出环境 Test    deactivate    ## 删除环境 Test    rmvirtualenv test    ## 更多指令可以在 shell 中输入 virtualenv 回车会有提示</code></pre><h2 id="在-VSCode-中使用虚拟环境"><a href="#在-VSCode-中使用虚拟环境" class="headerlink" title="在 VSCode 中使用虚拟环境"></a>在 VSCode 中使用虚拟环境</h2><p>进入工作环境设置文件 <code>settings.json</code>，加入如下配置： </p><pre><code class="bash">&quot;python.venvPath&quot;: &quot;~/.virtualenvs&quot;</code></pre><p>具体操作界面如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/virtualenvwrapper：Python_环境管理工具/1654943943.082001.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>重启 <code>VSCode</code> 即可看到配置已经成功被识别，便可以选择刚才新建的虚拟环境 <code>Test</code>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/virtualenvwrapper：Python_环境管理工具/1654943943.202436.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/70389886" target="_blank" rel="noopener">virtualenvwrapper：Python_环境管理工具</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux用netstat查看服务及监听端口详解</title>
      <link href="/2022/06/07/Linux%E7%94%A8netstat%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%8F%8A%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/07/Linux%E7%94%A8netstat%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%8F%8A%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在Linux使用过程中，需要了解当前系统开放了哪些端口，并且要查看开放这些端口的具体进程和用户，可以通过netstat命令进行简单查询</p><h3 id="netstat命令各个参数说明如下："><a href="#netstat命令各个参数说明如下：" class="headerlink" title="netstat命令各个参数说明如下："></a>netstat命令各个参数说明如下：</h3><ul><li>-a   或–all                             显示所有连线中的Socket。</li><li> -A                                       &lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。</li><li> -c   或–continuous               持续列出网络状态。</li><li> -C 或–cache                       显示路由器配置的快取信息。</li><li> -e  或–extend                     显示网络其他相关信息。</li><li> -F  或 –fib                          显示FIB。</li><li> -g  或–groups                     显示多重广播功能群组组员名单。</li><li> -h  或–help                        在线帮助。</li><li> -i   或–interfaces                 显示网络界面信息表单。</li><li> -l  或–listening                    显示监控中的服务器的Socket。</li><li> -M   或–masquerade           显示伪装的网络连线。</li><li> -n  或–numeric                   直接使用IP地址，而不通过域名服务器。</li><li> -N   或–netlink或–symbolic  显示网络硬件外围设备的符号连接名称。</li><li> -o  或–timers                      显示计时器。</li><li> -p   或–programs                显示正在使用Socket的程序识别码和程序名称。</li><li> -r  或–route                        显示 Routing Table。</li><li> -s  或–statistice 显示网络工作信息统计表。</li><li> -t  或–tcp 显示TCP 传输协议的连线状况。</li><li> -u或–udp 显示UDP传输协议的连线状况。</li><li> -v或–verbose 显示指令执行过程。</li><li> -V 或–version 显示版本信息。</li><li> -w或–raw 显示RAW传输协议的连线状况。</li><li> -x或–unix 此参数的效果和指定”-A unix”参数相同。</li><li> –ip或–inet 此参数的效果和指定”-A inet”参数相同。</li></ul><p>即可显示当前服务器上所有端口及进程服务，于grep结合可查看某个具体端口及服务情况：</p><pre><code class="bash">[root@localhost ~]# netstat -ntlp   //查看当前所有tcp端口·[root@localhost ~]# netstat -ntulp |grep 80   //查看所有80端口使用情况·[root@localhost ~]# netstat -an | grep 3306   //查看所有3306端口使用情况·[root@localhost ~]# netstat -nlp |grep LISTEN   //查看当前所有监听端口·</code></pre><h3 id="查看当前所有tcp端口使用情况："><a href="#查看当前所有tcp端口使用情况：" class="headerlink" title="查看当前所有tcp端口使用情况："></a>查看当前所有tcp端口使用情况：</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Linux用netstat查看服务及监听端口详解/1654944231.708832.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里解释一下：</p><ul><li>1、0.0.0.0代表本机上可用的任意地址。 比如0.0.0.0:135 表示本机上所有地址的135端口，这样多ip计算机就不用重复显示了。</li><li> 2、TCP 0.0.0.0:80表示在所有的可用接口上监听TCP80端口 </li><li> 3、0.0.0.0为默认路由，即要到达不再路由表里面的网段的包都走0.0.0.0这条规则</li></ul><p>然后127.0.0.1就是表示你本机ip地址的意思了。</p><p>然后[::]:21这又是什么鬼？</p><p>这个表示ipv6的21号端口的意思。</p><p>还有UDP的外部链接怎么都是*:*呢？</p><p><em>：</em>是网址的通配符，就是192.168.15.12，这个类型的整体描述。</p><p>解释一下状态（state）了</p><ul><li>LISTEN：(Listening for a connection.)侦听来自远方的TCP端口的连接请求</li><li>SYN-SENT：(Active; sent SYN. Waiting for a matching connection request after having sent a connection request.)再发送连接请求后等待匹配的连接请求</li><li>SYN-RECEIVED：(Sent and received SYN. Waiting for a confirming connection request acknowledgment after having both received and sent connection requests.)再收到和发送一个连接请求后等待对方对连接请求的确认</li><li>ESTABLISHED：(Connection established.)代表一个打开的连接</li><li>FIN-WAIT-1：(Closed; sent FIN.)等待远程TCP连接中断请求，或先前的连接中断请求的确认</li><li>FIN-WAIT-2：(Closed; FIN is acknowledged; awaiting FIN.)从远程TCP等待连接中断请求</li><li>CLOSE-WAIT：(Received FIN; waiting to receive CLOSE.)等待从本地用户发来的连接中断请求</li><li>CLOSING：(Closed; exchanged FIN; waiting for FIN.)等待远程TCP对连接中断的确认</li><li>LAST-ACK：(Received FIN and CLOSE; waiting for FIN ACK.)等待原来的发向远程TCP的连接中断请求的确认</li><li>TIME-WAIT：(In 2 MSL (twice the maximum segment length) quiet wait after close. )等待足够的时间以确保远程TCP接收到连接中断请求的确认</li><li>CLOSED：(Connection is closed.)没有任何连接状态</li></ul><p>例如要查看当前Mysql默认端口80是否启动可以做如下操作</p><p><img src="/images/Linux%E7%94%A8netstat%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%8F%8A%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E8%AF%A6%E8%A7%A3/1654944231.880319.jpg"></p><p>netstat -ano来显示协议统计信息和TCP/IP网络连接</p><p>netstat -t/-u/-l/-r/-n【显示网络相关信息,-t:TCP协议,-u:UDP协议,-l:监听,-r:路由,-n:显示IP地址和端口号】</p><p>netstat -tlun【查看本机监听的端口】</p><p>netstat -an【查看本机所有的网络】</p><p>netstat -rn【查看本机路由表】</p><p>列出所有端口：netstat -a </p><p>列出所有的TCP端口：netstat -at </p><p>列出所有的UDP端口：netstat -au </p><p>列出所有处于监听状态的socket：netstat -l </p><p>列出所有监听TCP端口的socket：netstat -lt </p><p>列出所有监听UDP端口的socket：netstat -lu </p><p>找出程序运行的端口：netstat -ap | grep ssh </p><p>找出运行在指定端口的进程：netstat -an | grep ‘:80’</p><p>几个有用查找：</p><pre><code class="bash">1.查找请求数前20个IP（常用于查找攻来源）：netstat -anlp|grep 80|grep tcp|awk &#39;{print $5}&#39;|awk -F: &#39;{print $1}&#39;|sort|uniq -c|sort -nr|head -n20 netstat -ant |awk &#39;/:80/{split($5,ip,”:”);++A[ip[1]]}END{for(i in A) print A[i],i}&#39; |sort -rn|head -n20 2.用tcpdump嗅探80端口的访问看看谁最高tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F”.” &#39;{print $1″.”$2″.”$3″.”$4}&#39; | sort | uniq -c | sort -nr |head -20 3.查找较多time_wait连接netstat -n|grep TIME_WAIT|awk &#39;{print $5}&#39;|sort|uniq -c|sort -rn|head -n20 4.找查较多的SYN连接netstat -an | grep SYN | awk &#39;{print $5}&#39; | awk -F: &#39;{print $1}&#39; | sort | uniq -c | sort -nr | more 5.根据端口列进程netstat -ntlp | grep 80 | awk &#39;{print $7}&#39; | cut -d/ -f1</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/wade3015/article/details/90779669" target="_blank" rel="noopener">Linux用netstat查看服务及监听端口详解</a></p><p> </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>systemctl命令介绍和使用</title>
      <link href="/2022/06/06/systemctl%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/06/systemctl%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Systemd程序"><a href="#Systemd程序" class="headerlink" title="Systemd程序"></a>Systemd程序</h3><p>Systemd其实是Linux系统用来管理系统的一个程序，用来代替原来的init进程(用来管理启动系统其它的服务进程)，现在很多Linux发行版都已经自带Systemd程序了。</p><h3 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h3><h4 id="1-Unit"><a href="#1-Unit" class="headerlink" title="1. Unit"></a>1. Unit</h4><p>systemctl命令是Systemd中最重要的一个命令，用于对服务进行启动，停止等操作，在Systemd中有Unit的概念，每个进程都是一个Unit，总共有十二种Unit类型。</p><ul><li>Service unit，系统服务</li><li>Target unit，多个 Unit 构成的一个组</li><li>Device Unit，硬件设备</li><li>Mount Unit，文件系统的挂载点</li><li>Automount Unit，自动挂载点</li><li>Path Unit，文件或路径</li><li>Scope Unit，不是由 Systemd 启动的外部进程</li><li>Slice Unit，进程组</li><li>Snapshot Unit，Systemd 快照，可以切回某个快照</li><li>Socket Unit，进程间通信的 socket</li><li>Swap Unit，swap 文件</li><li>Timer Unit，定时器</li></ul><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><pre><code class="bash"># 列出正在运行的Unitsystemctl list-units，可以直接使用systemctl# 列出所有Unit，包括没有找到配置文件的或者启动失败的systemctl list-units --all# 列出所有没有运行的 Unitsystemctl list-units --all --state=inactive# 列出所有加载失败的 Unitsystemctl list-units --failed# 列出所有正在运行的、类型为service的Unitsystemctl list-units --type=service# 显示某个 Unit 是否正在运行systemctl is-active application.service# 显示某个 Unit 是否处于启动失败状态systemctl is-failed application.service# 显示某个 Unit 服务是否建立了启动链接systemctl is-enabled application.service# 立即启动一个服务sudo systemctl start apache.service# 立即停止一个服务sudo systemctl stop apache.service# 重启一个服务sudo systemctl restart apache.service# 重新加载一个服务的配置文件sudo systemctl reload apache.service# 重载所有修改过的配置文件sudo systemctl daemon-reload</code></pre><h3 id="systemctl中Unit的配置文件"><a href="#systemctl中Unit的配置文件" class="headerlink" title="systemctl中Unit的配置文件"></a>systemctl中Unit的配置文件</h3><p>上面说了每个服务都是一个Unit，那每个Unit都会有它的配置文件，这样启动的时候才知道要按照什么方式去启动。Systemd默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在那个目录。</p><h4 id="1-查看Unit的配置文件"><a href="#1-查看Unit的配置文件" class="headerlink" title="1. 查看Unit的配置文件"></a>1. 查看Unit的配置文件</h4><p>可以使用<code>systemctl cat</code>命令来查看服务的配置文件，下面是Mysql的配置文件，很多软件已经支持Systemd程序了，安装的时候会自动配置它的Unit配置文件，例如Mysql和Nginx等等。</p><pre><code class="bash">[root@VM_0_11_centos ~]# systemctl cat mysqld# /usr/lib/systemd/system/mysqld.service[Unit]Description=MySQL ServerDocumentation=man:mysqld(8)Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.htmlAfter=network.targetAfter=syslog.target[Install]WantedBy=multi-user.target[Service]User=mysqlGroup=mysqlType=forkingPIDFile=/var/run/mysqld/mysqld.pid# Disable service start and stop timeout logic of systemd for mysqld service.TimeoutSec=0# Execute pre and post scripts as rootPermissionsStartOnly=true# Needed to create system tablesExecStartPre=/usr/bin/mysqld_pre_systemd# Start main serviceExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS# Use this to switch malloc implementationEnvironmentFile=-/etc/sysconfig/mysql# Sets open_files_limitLimitNOFILE = 5000Restart=on-failureRestartPreventExitStatus=1PrivateTmp=false</code></pre><h4 id="2-Unit配置文件的含义"><a href="#2-Unit配置文件的含义" class="headerlink" title="2. Unit配置文件的含义"></a>2. Unit配置文件的含义</h4><pre><code class="bash">可以看到Unit配置文件有很多标签，不同的标签都代表了不同的意思，这里只列出部分介绍，可以去官网查看Unit配置文件文档介绍，https://www.freedesktop.org/software/systemd/man/systemd.unit.html。- Unit   - Description，服务的描述   - Documentation，文档介绍   - After，该服务要在什么服务启动之后启动，比如Mysql需要在network和syslog启动之后再启动- Install   - WantedBy，值是一个或多个Target，当前Unit激活时(enable)符号链接会放入/etc/systemd/system目录下面以Target名+.wants后缀构成的子目录中   - RequiredBy，它的值是一个或多个Target，当前Unit激活(enable)时，符号链接会放入/etc/systemd/system目录下面以Target名+.required后缀构成的子目录中   - Alias，当前Unit可用于启动的别名   - Also，当前Unit激活(enable)时，会被同时激活的其他Unit- Service   - Type，定义启动时的进程行为。它有以下几种值。   - Type=simple，默认值，执行ExecStart指定的命令，启动主进程   - Type=forking，以 fork 方式从父进程创建子进程，创建后父进程会立即退出   - Type=oneshot，一次性进程，Systemd 会等当前服务退出，再继续往下执行   - Type=dbus，当前服务通过D-Bus启动   - Type=notify，当前服务启动完毕，会通知Systemd，再继续往下执行   - Type=idle，若有其他任务执行完毕，当前服务才会运行   - ExecStart，启动当前服务的命令   - ExecStartPre，启动当前服务之前执行的命令   - ExecStartPost，启动当前服务之后执行的命令   - ExecReload，重启当前服务时执行的命令   - ExecStop，停止当前服务时执行的命令   - ExecStopPost，停止当其服务之后执行的命令   - RestartSec，自动重启当前服务间隔的秒数   - Restart，定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog   - TimeoutSec，定义 Systemd 停止当前服务之前等待的秒数   - Environment，指定环境变量</code></pre><h3 id="自定义服务启动"><a href="#自定义服务启动" class="headerlink" title="自定义服务启动"></a>自定义服务启动</h3><p>既然Systemd的作用就是控制服务的启动，那么就可以把自己的服务添加进去，就可以直接使用systemctl命令来控制服务的启动，或者是设置开机自动启动等等。</p><h4 id="1-创建Unit配置文件"><a href="#1-创建Unit配置文件" class="headerlink" title="1. 创建Unit配置文件"></a>1. 创建Unit配置文件</h4><p>在<code>/usr/lib/systemd/system</code>目录中创建自己的配置文件，一般都是<code>.service</code>结尾，例如这里创建了一个<code>test-sh.service</code>配置文件，这个Unit是为了启动我们自己的一个shell脚本。</p><pre><code class="bash"># /usr/lib/systemd/system/test-sh.service[Unit]Description= test sh log[Service]ExecStart=/opt/dev/shell/test.shType=forkingKillMode=processRestart=on-failureRestartSec=30s[Install]WantedBy=multi-user.target</code></pre><h4 id="2-创建脚本"><a href="#2-创建脚本" class="headerlink" title="2. 创建脚本"></a>2. 创建脚本</h4><pre><code class="bash">在上面配置文件指定的启动路径`/opt/dev/shell/`下创建shell脚本，这里只是每秒打印当前时间，并输出到一个文本中。#!/bin/bashwhile truedosleep 1 date=`date -d today +&quot;%Y-%m-%d %T&quot;` echo ${date} &gt;&gt; /opt/dev/shell/test.txtdone</code></pre><h4 id="3-载入配置文件并启动"><a href="#3-载入配置文件并启动" class="headerlink" title="3. 载入配置文件并启动"></a>3. 载入配置文件并启动</h4><pre><code class="bash">使用`systemctl daemon-reload`命令来载入新添加的配置文件，然后使用`systemctl start test-sh.service`命令启动，再使用`systemctl status test-sh.service`命令来查看状态，可以看到已经启动，`/opt/dev/shell/test.txt`也确实在不停的写入内容，最后使用`systemctl stop test-sh.service`命令停止服务，可以看到状态也是停止了。注意的是修改配置文件后一定要使用`systemctl daemon-reload`命令来载入新添加的配置文件，然后再启动服务。[root@VM_0_11_centos ~]# systemctl start test-sh.service^C[root@VM_0_11_centos ~]# systemctl status test-sh.service● test-sh.service - test sh log   Loaded: loaded (/usr/lib/systemd/system/test-sh.service; enabled; vendor preset: disabled)   Active: activating (start) since Fri 2020-06-26 05:46:45 CST; 11s ago   Control: 9295 (test.sh)   CGroup: /system.slice/test-sh.service       ├─9295 /bin/bash /opt/dev/shell/test.sh       └─9343 sleep 1Jun 26 05:46:45 VM_0_11_centos systemd[1]: Starting test sh log...[root@VM_0_11_centos ~]# systemctl stop test-sh.service[root@VM_0_11_centos ~]# systemctl status test-sh.service● test-sh.service - test sh log   Loaded: loaded (/usr/lib/systemd/system/test-sh.service; enabled; vendor preset: disabled)   Active: inactive (dead) since Fri 2020-06-26 05:47:52 CST; 2s ago  Process: 9295 ExecStart=/opt/dev/shell/test.sh (code=killed, signal=TERM)Jun 26 05:46:45 VM_0_11_centos systemd[1]: Starting test sh log...Jun 26 05:47:52 VM_0_11_centos systemd[1]: Stopped test sh log.</code></pre><h3 id="查看Unit启动日志"><a href="#查看Unit启动日志" class="headerlink" title="查看Unit启动日志"></a>查看Unit启动日志</h3><p>Systemd统一管理了所有Unit的启动日志，因此只需要使用journalctl命令就可以查看到服务的日志</p><pre><code class="bash"># 查看所有日志（默认情况下 ，只保存本次启动的日志）journalctl# 查看指定时间的日志journalctl --since=&quot;2012-10-30 18:17:16&quot;journalctl --since &quot;20 min ago&quot;journalctl --since yesterdayjournalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;journalctl --since 09:00 --until &quot;1 hour ago&quot;# 显示尾部的最新10行日志journalctl -n# 显示尾部指定行数的日志journalctl -n 20# 实时滚动显示最新日志journalctl -f# 查看指定服务的日志journalctl /usr/lib/systemd/systemd# 查看指定进程的日志journalctl _PID=1# 查看某个路径的脚本的日志journalctl /usr/bin/bash# 查看指定用户的日志journalctl _UID=33 --since today# 查看某个 Unit 的日志journalctl -u nginx.servicejournalctl -u nginx.service --since today# 实时滚动显示某个 Unit 的最新日志journalctl -u nginx.service -f# 合并显示多个 Unit 的日志$ journalctl -u nginx.service -u php-fpm.service --since today</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 系统管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm 自定义文件和代码模板</title>
      <link href="/2021/11/23/PyCharm%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E5%92%8C%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
      <url>/2021/11/23/PyCharm%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E5%92%8C%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>　　PyCharm提供了文件和代码模板功能，可以利用此模板来快捷新建代码或文件。比如在PyCharm中新建一个html文件，新的文件并不是空的，而是会自动填充了一些基础的必备的内容，就像这样:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>　　系统自带的模板内容可能并不是想要的，自己可以修改增加个性化的内容，比如我新建一个名为main.py的Python文件，会自动填充这些内容:</p><pre><code class="python"># !/usr/bin/env python3# -*- encoding: utf-8 -*-&#39;&#39;&#39;@项目 :  ${PROJECT_NAME}@文件 :  ${NAME}.py@时间 :  ${YEAR}/${MONTH}/${DAY} ${HOUR}:${MINUTE}@作者 :  ${USER}@版本 :  1.0@说明 :   &#39;&#39;&#39;</code></pre><p>　　File Name为文件名， Author是登录系统的用户名, 日期为当前系统日期。是不是感觉比默认的空白文件好多了。具体的修改步骤是: 【文件(File)】 → 【设置(Settings)】如图操作, 在【编辑器(Editor)】中找到【文件和代码模板(File and Code Templates)】，选择你想要设置的文件类型进行编辑即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/1039209/201706/1039209-20170605125127575-2038114546.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>　　<br>　　附上模板变量:</p><pre><code> ${PROJECT_NAME} - 当前Project名称; ${NAME} - 在创建文件的对话框中指定的文件名; ${USER} - 当前用户名; ${DATE} - 当前系统日期; ${TIME} - 当前系统时间; ${YEAR} - 年; ${MONTH} - 月; ${DAY} - 日; ${HOUR} - 小时; ${MINUTE} - 分钟； ${PRODUCT_NAME} - 创建文件的IDE名称; ${MONTH_NAME_SHORT} - 英文月份缩写, 如: Jan, Feb, etc; ${MONTH_NAME_FULL} - 英文月份全称, 如: January, February, etc；</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyCharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中查看各文件夹大小命令du -h --max-depth=1</title>
      <link href="/2021/11/21/Linux%E4%B8%AD%E6%9F%A5%E7%9C%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%91%BD%E4%BB%A4du%20-h%20--max-depth=1/"/>
      <url>/2021/11/21/Linux%E4%B8%AD%E6%9F%A5%E7%9C%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%91%BD%E4%BB%A4du%20-h%20--max-depth=1/</url>
      
        <content type="html"><![CDATA[<p>du [-abcDhHklmsSx] [-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;] [–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]<br>常用参数：<br>-a或-all 为每个指定文件显示磁盘使用情况，或者为目录中每个文件显示各自磁盘使用情况。<br>-b或-bytes 显示目录或文件大小时，以byte为单位。<br>-c或–total 除了显示目录或文件的大小外，同时也显示所有目录或文件的总和。<br>-D或–dereference-args 显示指定符号连接的源文件大小。<br>-h或–human-readable 以K，M，G为单位，提高信息的可读性。<br>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位,而不是以1024为换算单位。<br>-k或–kilobytes 以1024 bytes为单位。<br>-l或–count-links 重复计算硬件连接的文件。<br>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。<br>-m或–megabytes 以1MB为单位。<br>-s或–summarize 仅显示总计，即当前目录的大小。<br>-S或–separate-dirs 显示每个目录的大小时，并不含其子目录的大小。<br>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<br>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。<br>–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。<br>–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。<br>–help 显示帮助。<br>–version 显示版本信息。</p><p><strong>1&gt; 要显示一个目录树及其每个子树的磁盘使用情况</strong><br>du /home/linux<br>这在/home/linux目录及其每个子目录中显示了磁盘块数。  </p><p><strong>2&gt; 要通过以1024字节为单位显示一个目录树及其每个子树的磁盘使用情况</strong><br>du -k /home/linux<br>这在/home/linux目录及其每个子目录中显示了 1024 字节磁盘块数。  </p><p><strong>3&gt; 以MB为单位显示一个目录树及其每个子树的磁盘使用情况</strong><br>du -m /home/linux<br>这在/home/linux目录及其每个子目录中显示了 MB 磁盘块数。  </p><p><strong>4&gt; 以GB为单位显示一个目录树及其每个子树的磁盘使用情况</strong><br>du -g /home/linux<br>这在/home/linux目录及其每个子目录中显示了 GB 磁盘块数。  </p><p><strong>5&gt;查看当前目录下所有目录以及子目录的大小：</strong><br>du -h .<br>“.”代表当前目录下。也可以换成一个明确的路径<br>-h表示用K、M、G的人性化形式显示  </p><p><strong>6&gt;查看当前目录下user目录的大小，并不想看其他目录以及其子目录：</strong><br>du -sh user<br>-s表示总结的意思，即只列出一个总结的值<br>du -h –max-depth=0 user<br>–max-depth=n表示只深入到第n层目录，此处设置为0，即表示不深入到子目录。  </p><p><strong>7&gt;列出user目录及其子目录下所有目录和文件的大小：</strong><br>du -ah user<br>-a表示包括目录和文件  </p><p><strong>8&gt;列出当前目录中的目录名不包括xyz字符串的目录的大小：</strong><br>du -h –exclude=’<em>xyz</em>‘  </p><p><strong>9&gt;想在一个屏幕下列出更多的关于user目录及子目录大小的信息：</strong><br>du -0h user<br>-0（杠零）表示每列出一个目录的信息，不换行，而是直接输出下一个目录的信息。  </p><p><strong>10&gt;只显示一个目录树的全部磁盘使用情况</strong><br>du -s /home/linux</p><p><strong>11&gt;查看各文件夹大小:du -h –max-depth=1</strong><br> 查看指定目录：<br> 代码如下：  其中 /path表示路径</p><pre><code class="bash">du -h --max-depth=1 /path</code></pre><p> 具体如下所示：</p><pre><code class="bash">root@ubuntu4146:~# du -h --max-depth=1 /data/1.1G    /data/gitlabDataa8.0K    /data/test241G    /data/gitlabData809G    /data/home15G    /data/OpenGrok16K    /data/lost+found1.1T    /data/</code></pre><p> 我们发现  /data/home/ 目录占用最多，因此我们可以继续看那个目录占用的最多，如下所示：</p><pre><code class="bash">root@ubuntu4146:/data/home# du -h --max-depth=1 /data/home/141G    /data/home/wzm62G    /data/home/lwc421G    /data/home/hcy16K    /data/home/zzp16K    /data/home/zl54G    /data/home/drj122G    /data/home/sjq4.1G    /data/home/ljs6.7G    /data/home/ywm809G    /data/home/root@ubuntu4146:/data/home# </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 文件管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij IDEA破解补丁FineAgent，可破解至2099</title>
      <link href="/2021/11/18/Intellij%20IDEA%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B%EF%BC%8CIDEA%E7%A0%B4%E8%A7%A3%E8%A1%A5%E4%B8%81FineAgent%EF%BC%8C%E5%8F%AF%E7%A0%B4%E8%A7%A3%E8%87%B3%202099%20%E5%B9%B4/"/>
      <url>/2021/11/18/Intellij%20IDEA%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B%EF%BC%8CIDEA%E7%A0%B4%E8%A7%A3%E8%A1%A5%E4%B8%81FineAgent%EF%BC%8C%E5%8F%AF%E7%A0%B4%E8%A7%A3%E8%87%B3%202099%20%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<p>有网友问我，IDEA 产品能否永久激活呢？目前，我在网上逛了一圈，又发现某大佬开发了一款新的破解补丁，叫<strong>FineAgent</strong>，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812172447.png" alt="IDEA破解成功" title="IDEA破解成功">                </div>                <div class="image-caption">IDEA破解成功</div>            </figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li>本教程适用于**JetBrains 全系列产品，可放心使用；</li><li>本教程适用于 <strong>Windows</strong>/<strong>Mac</strong>/<strong>Linux</strong> 系统；</li><li>本教程适用于 <strong>JetBrains 全系列产品</strong>，包括 <strong>IntelliJ IDEA</strong>、<strong>APPCode</strong>、<strong>CLion</strong>、<strong>DataGrip</strong>、<strong>GoLand</strong>、<strong>PhpStorm</strong>、<strong>PyCharm</strong>、<strong>Rider</strong>、<strong>RubyMine</strong> 和 <strong>WebStorm</strong>。</li></ul><h1 id="教程演示"><a href="#教程演示" class="headerlink" title="教程演示"></a>教程演示</h1><p>下面的教程演示使用的是 <strong>Windows</strong> 系统，安装的 <strong>IDEA 版本为 2021.2</strong>。</p><h3 id="1、下载自己需要的IDEA"><a href="#1、下载自己需要的IDEA" class="headerlink" title="1、下载自己需要的IDEA"></a>1、下载自己需要的IDEA</h3><p>IDEA 老版本下载地址：<a href="https://www.jetbrains.com/zh-cn/idea/download/other.html" target="_blank" rel="noopener">https://www.jetbrains.com/zh-cn/idea/download/other.html</a></p><h3 id="2、安装IDEA"><a href="#2、安装IDEA" class="headerlink" title="2、安装IDEA"></a>2、安装IDEA</h3><p>这个操作就easy了，我们按照常规的安装方式安装就行，我就不详细说了。<br>如果你真的不会的话，那说明你确实不太适合做程序员~</p><h3 id="3、重置IDEA并点击试用"><a href="#3、重置IDEA并点击试用" class="headerlink" title="3、重置IDEA并点击试用"></a>3、重置IDEA并点击试用</h3><p>1）如果你的IDEA是新安装的，可以直接点击 <strong>试用</strong>，跳过这一步接下来的操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210424231958.png" alt="IDEA试用" title="IDEA试用">                </div>                <div class="image-caption">IDEA试用</div>            </figure><p>2）如果你的电脑之前安装过IDEA且超过试用期（还在试用期的可以忽略该步骤），可以直接通过我这里提供的重置脚本进行重置就行，其原理是删除jetbrains全系列产品软件试用相关目录（其他配置不受影响）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210423185059.png" alt="IDEA重置脚本" title="IDEA重置脚本">                </div>                <div class="image-caption">IDEA重置脚本</div>            </figure><p>IDEA重置脚本安全可靠，大家可以看看下面的源码哈：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210423185142.png" alt="IDEA重置脚本" title="IDEA重置脚本">                </div>                <div class="image-caption">IDEA重置脚本</div>            </figure><p>重置IDEA之后，打开IDEA，点击试用，按照图示选择试用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210424231958.png" alt="IDEA试用" title="IDEA试用">                </div>                <div class="image-caption">IDEA试用</div>            </figure><p><strong>说明：最新的 IDEA 2021.2.3 版本 IDEA 界面发生了变化，取消了直接试用 30 天的按钮，需要我们先注册一个 JetBrains（这里我用的 GitHub 账号注册的）</strong>，如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.javatiku.cn/usr/img/4816dd4fc758afa9e0e4e717059ed162.png" alt="IDEA试用" title="IDEA试用">                </div>                <div class="image-caption">IDEA试用</div>            </figure><p>注册账号并登录后，就可以试用 IDEA 了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.javatiku.cn/usr/img/96f2e7b62949112c63fe5eb498bd2d64.png" alt="IDEA试用" title="IDEA试用">                </div>                <div class="image-caption">IDEA试用</div>            </figure><h3 id="4、下载破解补丁"><a href="#4、下载破解补丁" class="headerlink" title="4、下载破解补丁"></a>4、下载破解补丁</h3><p>该破解方法需要用到的文件都准备好了，通过下方的网盘链接下载就行。</p><h6 id="蓝奏云下载"><a href="#蓝奏云下载" class="headerlink" title="蓝奏云下载"></a><a href="https://wwe.lanzoui.com/iWZ0Nwm96od" target="_blank" rel="noopener">蓝奏云下载</a></h6><p>压缩包目录结构：</p><pre><code>FineAgent.zip|---激活码|---FineAgent.jarreset_script.zip</code></pre><h3 id="5、安装破解补丁"><a href="#5、安装破解补丁" class="headerlink" title="5、安装破解补丁"></a>5、安装破解补丁</h3><p>如果你之前安装过 IDEA, 那么修改过的 hosts 文件要还原回去、引用过的补丁要移除掉等, 不然可能会有各种奇奇怪怪的问题。<br>打开IDEA，你可以在Help -&gt; Eidt Custom VM Options… ，参考如下图所示:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812172939.png" alt="安装破解补丁" title="安装破解补丁">                </div>                <div class="image-caption">安装破解补丁</div>            </figure><p>由于我把压缩包内的<code>FineAgent.jar</code>直接放在D盘的根目录，所以一定要先清除vmoptions文件内其它的<code>-javaagent:xxx</code>配置（否则会存在IDEA打不开的情况），然后再在最后一行加上如下代码：</p><pre><code>-javaagent:d:/FineAgent.jar</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812173210.png" alt="IDEA破解教程" title="IDEA破解教程">                </div>                <div class="image-caption">IDEA破解教程</div>            </figure><h3 id="6、重启IDEA"><a href="#6、重启IDEA" class="headerlink" title="6、重启IDEA"></a>6、重启IDEA</h3><p>安装完成后，重启 idea。</p><h3 id="7、通过指定的注册码来激活IDEA"><a href="#7、通过指定的注册码来激活IDEA" class="headerlink" title="7、通过指定的注册码来激活IDEA"></a>7、通过指定的注册码来激活IDEA</h3><p>重启后，便会提示你输入激活码，激活码在压缩包内 <code>ActivationCode.txt</code> ，这时，你可以用压缩包内的激活码进行激活，如下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812173504.png" alt="IDEA激活码" title="IDEA激活码">                </div>                <div class="image-caption">IDEA激活码</div>            </figure><p>此时，点击Activate，便激活成功了。</p><h3 id="8、如何验证是否激活成功呢？"><a href="#8、如何验证是否激活成功呢？" class="headerlink" title="8、如何验证是否激活成功呢？"></a>8、如何验证是否激活成功呢？</h3><p>你直接进入 IDEA 主界面，在上方的菜单栏点击 <code>Help</code> -&gt; <code>Register</code> 查看当前激活状态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812173753.png" alt="IDEA破解教程" title="IDEA破解教程">                </div>                <div class="image-caption">IDEA破解教程</div>            </figure><p>这时候你就可以看到，已经激活至 2099 年啦，爽歪歪~</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.javatiku.cn/20210812173856.png" alt="IDEA破解教程" title="IDEA破解教程">                </div>                <div class="image-caption">IDEA破解教程</div>            </figure><h3 id="为何IDEA打不开？"><a href="#为何IDEA打不开？" class="headerlink" title="为何IDEA打不开？"></a>为何IDEA打不开？</h3><p>一个最主要的原因是：你在<code>vmoptions</code>文件配置的路径不对。<br>如果你想打开IDEA，那么需要找到以<code>vmoptions</code>后缀结尾的文件(一般位于<code>C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2021.2</code>目录下)，找到 <code>idea64.exe.vmoptions</code>，打开之后，删除 -javaagent:xxx的信息，即可打开，虽然IDEA能打开了，但是很不幸你未破解成功！<br>要想重新破解，那么请重复上述步骤！！！<br>希望本教程对你有所帮助！</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="http://www.javatiku.cn/idea/5.html" target="_blank" rel="noopener">http://www.javatiku.cn/idea/5.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 破解 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下PyCharm快捷键大全</title>
      <link href="/2021/11/17/Mac%E4%B8%8BPyCharm%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
      <url>/2021/11/17/Mac%E4%B8%8BPyCharm%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a>Mac键盘符号和修饰键说明</h2><ul><li><code>⌘</code> Command</li><li><code>⇧</code> Shift</li><li><code>⌥</code> Option</li><li><code>⌃</code> Control</li><li><code>↩︎</code> Return/Enter</li><li><code>⌫</code> Delete</li><li><code>⌦</code> 向前删除键（Fn+Delete）</li><li><code>↑</code> 上箭头</li><li><code>↓</code> 下箭头</li><li><code>←</code> 左箭头</li><li><code>→</code> 右箭头</li><li><code>⇞</code> Page Up（Fn+↑）</li><li><code>⇟</code> Page Down（Fn+↓）</li><li><code>Home</code> Fn + ←</li><li><code>End</code> Fn + →</li><li><code>⇥</code> 右制表符（Tab键）</li><li><code>⇤</code> 左制表符（Shift+Tab）</li><li><code>⎋</code> Escape (Esc)</li></ul><h2 id="Editing（编辑）"><a href="#Editing（编辑）" class="headerlink" title="Editing（编辑）"></a>Editing（编辑）</h2><ul><li><code>⌃Space</code> 基本的代码补全（补全任何类、方法、变量）</li><li><code>⌃⇧Space</code> 智能代码补全（过滤器方法列表和变量的预期类型）</li><li><code>⌘⇧↩</code> 自动结束代码，行末自动添加分号</li><li><code>⌘P</code> 显示方法的参数信息</li><li><code>⌃J, Mid. button click</code> 快速查看文档</li><li><code>⇧F1</code> 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li><li><code>⌘+鼠标放在代码上</code> 显示代码简要信息</li><li><code>⌘F1</code> 在错误或警告处显示具体描述信息</li><li><code>⌘N, ⌃↩, ⌃N</code> 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li><code>⌃O</code> 覆盖方法（重写父类方法）</li><li><code>⌃I</code> 实现方法（实现接口中的方法）</li><li><code>⌘⌥T</code> 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码）</li><li><code>⌘/</code> 注释/取消注释与行注释</li><li><code>⌘⌥/</code> 注释/取消注释与块注释</li><li><code>⌥↑</code> 连续选中代码块</li><li><code>⌥↓</code> 减少当前选中的代码块</li><li><code>⌃⇧Q</code> 显示上下文信息</li><li><code>⌥↩</code> 显示意向动作和快速修复代码</li><li><code>⌘⌥L</code> 格式化代码</li><li><code>⌃⌥O</code> 优化import</li><li><code>⌃⌥I</code> 自动缩进线</li><li><code>⇥ / ⇧⇥</code> 缩进代码 / 反缩进代码</li><li><code>⌘X</code> 剪切当前行或选定的块到剪贴板</li><li><code>⌘C</code> 复制当前行或选定的块到剪贴板</li><li><code>⌘V</code> 从剪贴板粘贴</li><li><code>⌘⇧V</code> 从最近的缓冲区粘贴</li><li><code>⌘D</code> 复制当前行或选定的块</li><li><code>⌘⌫</code> 删除当前行或选定的块的行</li><li><code>⌃⇧J</code> 智能的将代码拼接成一行</li><li><code>⌘↩</code> 智能的拆分拼接的行</li><li><code>⇧↩</code> 开始新的一行</li><li><code>⌘⇧U</code> 大小写切换</li><li><code>⌘⇧] / ⌘⇧[</code> 选择直到代码块结束/开始</li><li><code>⌥⌦</code> 删除到单词的末尾（⌦键为Fn+Delete）</li><li><code>⌥⌫</code> 删除到单词的开头</li><li><code>⌘+ / ⌘-</code> 展开 / 折叠代码块</li><li><code>⌘⇧+</code> 展开所以代码块</li><li><code>⌘⇧-</code> 折叠所有代码块</li><li><code>⌘W</code> 关闭活动的编辑器选项卡</li></ul><h2 id="Search-Replace（查询-替换）"><a href="#Search-Replace（查询-替换）" class="headerlink" title="Search/Replace（查询/替换）"></a>Search/Replace（查询/替换）</h2><ul><li><code>Double ⇧</code> 查询任何东西</li><li><code>⌘F</code> 文件内查找</li><li><code>⌘G</code> 查找模式下，向下查找</li><li><code>⌘⇧G</code> 查找模式下，向上查找</li><li><code>⌘R</code> 文件内替换</li><li><code>⌘⇧F</code> 全局查找（根据路径）</li><li><code>⌘⇧R</code> 全局替换（根据路径）</li><li><code>⌘⇧S</code> 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）</li><li><code>⌘⇧M</code> 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）</li></ul><h2 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h2><ul><li><code>⌥F7 / ⌘F7</code> 在文件中查找用法 / 在类中查找用法</li><li><code>⌘⇧F7</code> 在文件中突出显示的用法</li><li><code>⌘⌥F7</code> 显示用法<br>Compile and Run（编译和运行）</li><li><code>⌘F9</code> 编译Project</li><li><code>⌘⇧F9</code> 编译选择的文件、包或模块</li><li><code>⌃⌥R</code> 弹出 Run 的可选择菜单</li><li><code>⌃⌥D</code> 弹出 Debug 的可选择菜单</li><li><code>⌃R</code> 运行</li><li><code>⌃D</code> 调试</li><li><code>⌃⇧R, ⌃⇧D</code> 从编辑器运行上下文环境配置<br>Debugging（调试）</li><li><code>F8</code> 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</li><li><code>F7</code> 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</li><li><code>⇧F7</code> 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</li><li><code>⇧F8</code> 跳出</li><li><code>⌥F9</code> 运行到光标处，如果光标前有其他断点会进入到该断点</li><li><code>⌥F8</code> 计算表达式（可以更改变量值使其生效）</li><li><code>⌘⌥R</code> 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</li><li><code>⌘F8</code> 切换断点（若光标当前行有断点则取消断点，没有则加上断点）</li><li><code>⌘⇧F8</code> 查看断点信息<br>Navigation（导航）</li><li><code>⌘O</code> 查找类文件</li><li><code>⌘⇧O</code> 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠<code>/</code></li><li><code>⌘⌥O</code> 前往指定的变量 / 方法</li><li><code>⌃← / ⌃→</code> 左右切换打开的编辑tab页</li><li><code>F12</code> 返回到前一个工具窗口</li><li><code>⎋</code> 从工具窗口进入代码文件窗口</li><li><code>⇧⎋</code> 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li><code>⌘⇧F4</code> 关闭活动run/messages/find/… tab</li><li><code>⌘L</code> 在当前文件跳转到某一行的指定处</li><li><code>⌘E</code> 显示最近打开的文件记录列表</li><li><code>⌘⌥← / ⌘⌥→</code> 退回 / 前进到上一个操作的地方</li><li><code>⌘⇧⌫</code> 跳转到最后一个编辑的地方</li><li><code>⌥F1</code> 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</li><li><code>⌘B / ⌘ 鼠标点击</code> 进入光标所在的方法/变量的接口或是定义处</li><li><code>⌘⌥B</code> 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li><li><code>⌥ Space, ⌘Y</code> 快速打开光标所在方法、类的定义</li><li><code>⌃⇧B</code> 跳转到类型声明处</li><li><code>⌘U</code> 前往当前光标所在方法的父类的方法 / 接口定义</li><li><code>⌃↓ / ⌃↑</code> 当前光标跳转到当前文件的前一个/后一个方法名位置</li><li><code>⌘] / ⌘[</code> 移动光标到当前所在代码的花括号开始/结束位置</li><li><code>⌘F12</code> 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li><li><code>⌃H</code> 显示当前类的层次结构</li><li><code>⌘⇧H</code> 显示方法层次结构</li><li><code>⌃⌥H</code> 显示调用层次结构</li><li><code>F2 / ⇧F2</code> 跳转到下一个/上一个突出错误或警告的位置</li><li><code>F4 / ⌘↓</code> 编辑/查看代码源</li><li><code>⌥ Home</code> 显示到当前文件的导航条</li><li><code>F3</code>选中文件/文件夹/代码行，添加/取消书签</li><li><code>⌥F3</code> 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li><code>⌃0...⌃9</code> 定位到对应数值的书签位置</li><li><code>⌘F3</code> 显示所有书签</li></ul><h2 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h2><ul><li><code>F5</code> 复制文件到指定目录</li><li><code>F6</code> 移动文件到指定目录</li><li><code>⌘⌫</code> 在文件上为安全删除文件，弹出确认框</li><li><code>⇧F6</code> 重命名文件</li><li><code>⌘F6</code> 更改签名</li><li><code>⌘⌥N</code> 一致性</li><li><code>⌘⌥M</code> 将选中的代码提取为方法</li><li><code>⌘⌥V</code> 提取变量</li><li><code>⌘⌥F</code> 提取字段</li><li><code>⌘⌥C</code> 提取常量</li><li><code>⌘⌥P</code> 提取参数</li></ul><h2 id="VCS-Local-History（版本控制-本地历史记录）"><a href="#VCS-Local-History（版本控制-本地历史记录）" class="headerlink" title="VCS/Local History（版本控制/本地历史记录）"></a>VCS/Local History（版本控制/本地历史记录）</h2><ul><li><code>⌘K</code> 提交代码到版本控制器</li><li><code>⌘T</code> 从版本控制器更新代码</li><li><code>⌥⇧C</code> 查看最近的变更记录</li><li><code>⌃C</code> 快速弹出版本控制器操作面板</li></ul><h2 id="Live-Templates（动态代码模板）"><a href="#Live-Templates（动态代码模板）" class="headerlink" title="Live Templates（动态代码模板）"></a>Live Templates（动态代码模板）</h2><ul><li><code>⌘⌥J</code> 弹出模板选择窗口，将选定的代码使用动态模板包住</li><li><code>⌘J</code> 插入自定义动态代码模板</li></ul><h2 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h2><ul><li><code>⌘1...⌘9</code> 打开相应编号的工具窗口</li><li><code>⌘S</code> 保存所有</li><li><code>⌘⌥Y</code> 同步、刷新</li><li><code>⌃⌘F</code> 切换全屏模式</li><li><code>⌘⇧F12</code> 切换最大化编辑器</li><li><code>⌥⇧F</code> 添加到收藏夹</li><li><code>⌥⇧I</code> 检查当前文件与当前的配置文件</li><li>`§⌃, ⌃“ 快速切换当前的scheme（切换主题、代码样式等）</li><li><code>⌘,</code> 打开IDEA系统设置</li><li><code>⌘;</code> 打开项目结构对话框</li><li><code>⇧⌘A</code> 查找动作（可设置相关选项）</li><li><code>⌃⇥</code> 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）</li></ul><h2 id="Other（一些官方文档上没有体现的快捷键）"><a href="#Other（一些官方文档上没有体现的快捷键）" class="headerlink" title="Other（一些官方文档上没有体现的快捷键）"></a>Other（一些官方文档上没有体现的快捷键）</h2><ul><li><code>⌘⇧8</code> 竖编辑模式</li></ul><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ul><li><code>⌘O</code> 查找类文件 <code>Ctrl + N</code></li><li><code>⌘⌥O</code> 前往指定的变量 / 方法 <code>Ctrl + Shift + Alt + N</code></li><li><code>⌃←</code> / <code>⌃→</code> 左右切换打开的编辑tab页<code>Alt←</code>/<code>Alt→</code></li><li><code>⎋</code> 从工具窗口进入代码文件窗口 <code>ESC</code></li><li><code>⌘L</code> 在当前文件跳转到某一行的指定处 <code>Ctrl + G</code></li><li><code>⌘E</code> 显示最近打开的文件记录列表 <code>Ctrl + E</code></li><li><code>⌘⌥←</code>/ <code>⌘⌥→</code>退回 / 前进到上一个操作的地方 <code>Ctrl + Alt + ←</code>/<code>Ctrl + Alt + →</code></li><li><code>⌘⇧⌫</code> 跳转到最后一个编辑的地方</li><li><code>⌃H</code> 显示当前类的层次结构<code>Ctrl + H</code></li><li><code>⌘⇧H</code> 显示方法层次结构</li><li><code>⌃⌥H</code> 显示调用层次结构</li><li><code>F4</code> /<code>⌘↓</code> 编辑/查看代码源</li><li><code>⌘⌥U</code> 显示类UML图</li><li><code>⌃J</code> 查看注释</li></ul><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><ul><li><code>⌥⌦</code> 删除到单词的末尾（<code>⌦</code>键为<code>Fn+Delete</code>）</li><li><code>⌥⌫</code> 删除到单词的开头</li><li><code>⌘+</code> /<code>⌘-</code> 展开 / 折叠代码块</li><li><code>⌘F1</code> 在错误或警告处显示具体描述信息</li><li><code>⌘⌥L</code> 格式化代码</li><li><code>⌃⌥O</code> 优化import</li><li><code>⇧↩</code> 开始新的一行</li><li><code>⌘⇧↩</code> 自动结束代码，行末自动添加分号</li><li><code>⌃I</code> 实现方法（实现接口中的方法）</li><li><code>⇧F6</code> 重命名文件或者变量</li><li><code>⌘N</code>,<code>⌃↩</code>,<code>⌃N</code> 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li><code>⌘P</code> 显示方法的参数信息</li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li><code>Double⇧</code> 查找任何东西</li><li><code>⌘⇧F</code> 全局查找（根据路径）</li><li><code>⌘F</code> 文件内查找</li><li><code>⌘G</code> 查找模式下，向下查找</li><li><code>⌘⇧G</code> 查找模式下，向上查找</li></ul><h2 id="导航-1"><a href="#导航-1" class="headerlink" title="导航"></a>导航</h2><ul><li><code>⌘⌥B</code> 跳转到接口的实现</li><li><code>⌘U</code> 查看接口定义</li><li><code>⌘⌥←</code> /<code>⌘⌥→</code> 退回 / 前进到上一个操作的地方</li><li><code>⌘B</code> /<code>⌘ 鼠标点击</code> 进入光标所在的方法/变量的接口或是定义处</li><li><code>⌃⇧B</code> 跳转到类型声明处</li><li><code>⌥ Space</code>,<code>⌘Y</code> 快速打开光标所在方法、类的定义</li><li><code>⌘O</code> 查找类文件</li><li><code>⌘⇧O</code> 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/</li><li><code>F12</code> 返回到前一个工具窗口</li><li><code>⎋</code> 从工具窗口进入代码文件窗口</li><li><code>⇧⎋</code> 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li><code>F3选中文件/文件夹/代码行</code>，添加/取消书签</li><li><code>⌥F3 选中文件/文件夹/代码行</code>，使用助记符添加/取消书签</li><li><code>⌃0…⌃9</code> 定位到对应数值的书签位置</li><li><code>⌘F3</code> 显示所有书签</li><li><code>⌥F1</code> 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</li><li><code>⌘F12</code> 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li></ul><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><ul><li><code>⌃⌘F</code> 切换全屏模式</li></ul><h2 id="自动代码"><a href="#自动代码" class="headerlink" title="自动代码"></a>自动代码</h2><p> ⚠注：<code>⌘</code>+<code>J</code>可以调出所有提供的代码补全<code>↩</code>即可，下面仅列举常用的几个<br> 原文地址：<a href="https://linmi.cc/836" target="_blank" rel="noopener">https://linmi.cc/836</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> PyCharm </tag>
            
            <tag> 工具 </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS提示“打不开xxx,因为Apple无法检查其是否包含恶意软件...”</title>
      <link href="/2021/11/15/MacOS%E6%8F%90%E7%A4%BA%E2%80%9C%E6%89%93%E4%B8%8D%E5%BC%80xxx,%E5%9B%A0%E4%B8%BAApple%E6%97%A0%E6%B3%95%E6%A3%80%E6%9F%A5%E5%85%B6%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6...%E2%80%9D/"/>
      <url>/2021/11/15/MacOS%E6%8F%90%E7%A4%BA%E2%80%9C%E6%89%93%E4%B8%8D%E5%BC%80xxx,%E5%9B%A0%E4%B8%BAApple%E6%97%A0%E6%B3%95%E6%A3%80%E6%9F%A5%E5%85%B6%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6...%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当你的mac提示“打不开xxx,因为Apple无法检查其是否包含恶意软件…”时，一般是由于你下载了非App Store且不受苹果信任的开发者的软件，怎么解决呢？</p></blockquote><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/05/09/dl7ghqj4ranTvwF.png" alt="](https://i.loli.net/2020/05/09/dl7ghqj4ranTvwF.png "MacOS提示“打不开xxx,因为Apple无法检查其是否包含恶意软件...”")" title="">                </div>                <div class="image-caption">](https://i.loli.net/2020/05/09/dl7ghqj4ranTvwF.png "MacOS提示“打不开xxx,因为Apple无法检查其是否包含恶意软件...”")</div>            </figure></p><blockquote><p>其实很简单，只需要在设置-安全性与隐私-通用-允许从以下位置下载的应用-勾选“任何来源”，这时候有朋友就会说了，只有前两项怎么办？</p></blockquote><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/05/09/KqWfNwoO7RlDvs9.png" alt="](https://i.loli.net/2020/05/09/KqWfNwoO7RlDvs9.png "MacOS提示“打不开xxx,因为Apple无法检查其是否包含恶意软件...”")" title="">                </div>                <div class="image-caption">](https://i.loli.net/2020/05/09/KqWfNwoO7RlDvs9.png "MacOS提示“打不开xxx,因为Apple无法检查其是否包含恶意软件...”")</div>            </figure></p><blockquote><p>其实这个选项在最近几个macOS版本中被隐藏了（具体版本未考究），只需要通过命令就可以打开</p></blockquote><h3 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h3><p>1、在启动台-其他文件夹-终端，打开<br>2、输入命令：</p><pre><code class="bash">sudo spctl --master-disable #复制粘贴进去</code></pre><p>执行回车，然后输入电脑密码再回车即可（输密码是看不到的，直接输入就可以了）<br>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/05/09/QWvHcPUFT1IizGY.png" alt="](https://i.loli.net/2020/05/09/QWvHcPUFT1IizGY.png "MacOS提示“打不开xxx,因为Apple无法检查其是否包含恶意软件...”")" title="">                </div>                <div class="image-caption">](https://i.loli.net/2020/05/09/QWvHcPUFT1IizGY.png "MacOS提示“打不开xxx,因为Apple无法检查其是否包含恶意软件...”")</div>            </figure><br>之后就可以看到“任何来源”选项已经勾选，此时软件已经可以正常打开了。<br><strong>PS：关闭显示“任何来源”的命令是</strong></p><pre><code class="bash">sudo spctl --master-enable</code></pre><p>操作方法与上面同</p>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客备份与恢复</title>
      <link href="/2021/11/15/Hexo%20%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>/2021/11/15/Hexo%20%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-博客备份与恢复"><a href="#Hexo-博客备份与恢复" class="headerlink" title="Hexo 博客备份与恢复"></a>Hexo 博客备份与恢复</h1><p>本文旨在解决在不同电脑上都能维护博客或配置、发布的内容丢失可恢复的问题。<br>观察部署到仓库的内容，我们可以看到上传的内容是 <code>public</code> 文件夹下的所有内容。事实上 <code>hexo-deploy-git</code> 插件是通过拷贝 <code>public</code> 文件夹内容到 <code>.deploy_git</code> 文件夹下，然后提交推送到远程分支上实现了网站文件的部署。<br>那我们的备份思路也可以这样，上传目录下的其他所有文件就可以了，同时我们不能修改博客的发布分支，因此考虑备份其他所有文件到新分支中。<br>最简单直接的方法就是在仓库创建一个新的分支，把本地所有的内容都上传到该分支上。但这样会备份一部分不必要的文件，例如 <code>public</code> 文件夹内容，它可以再次生成，就没有必要备份。<br>那具体要备份哪些文件呢？</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="备份的文件列表"><a href="#备份的文件列表" class="headerlink" title="备份的文件列表"></a>备份的文件列表</h3><p>我们先看下，现在博客文件夹都有什么内容：</p><pre><code>.├──_config.yml├── db.json├── node_modules├── package.json├── package-lock.json├── public├── scaffolds├── source└── themes     ├── next     └── landscape</code></pre><p>这几个文件或文件夹的内容分别是：</p><ol><li><code>_config.yml</code> 文件：站点配置文件，很多功能、插件需要修改该配置文件应用生效。</li><li><code>node_modules</code> 文件夹：包含依赖的模块。</li><li><code>package.json</code> 文件：依赖的模块列表。说明见：<a href="https://www.npmjs.cn/files/package.json/" target="_blank" rel="noopener">package.json:Specifics of npm’s package.json handling</a></li><li><code>package-lock.json</code> 文件：依赖的模块安装记录。说明见：<a href="https://www.npmjs.cn/files/package-locks/" target="_blank" rel="noopener">npm-package-locks:An explanation of npm lockfiles</a></li><li><code>public</code> 文件夹：包含生成的网页静态文件。</li><li><code>scaffolds</code> 文件夹：包含创建的文章、分类、标签界面的模板。博客的定制修改会对模板进行修改。</li><li><code>source</code> 文件夹：包含生成网页所需要的源文件，包括包含我们心血的 Markdown 文稿，这也是最重要的内容。</li><li><code>themes</code> 文件夹：其中 <code>landscape</code> 是默认的主题，其他文件夹是克隆下来时的主题。<br>我们可以参考 Hexo 初始化使用的仓库的备份列表，它的仓库是 <a href="https://github.com/hexojs/hexo-starter" target="_blank" rel="noopener">hexojs/hexo-starter</a>。我们看下它备份了哪些内容：</li></ol><pre><code>scaffoldssourcethemes.gitignore.gitmodules_config.ymlpackage.json</code></pre><p>比对一下，它抛弃了：</p><ol><li><code>node_modules</code> &amp; <code>package-lock.json</code>：这两部分内容，只要保留 <code>package.json</code>，执行 <code>npm install</code> 就可以下载、生成。</li><li><code>public</code>：执行 <code>hexo g</code> 即可根据源文件生成网页内容。<br>这些可重新生成的文件都可以不上传，因为它们只要使用特定的命令操作即可恢复。<br>它增加了 <code>.gitmodules</code>，那它的作用又是什么呢？其实 <code>hexojs/hexo-starter</code> 是通过 Git 的 Submodule 功能来下载主题模块，本身仓库并不备份主题文件。考虑下我们需要如何备份主题文件目录，有两个方案：</li><li>一个方案是将其内容全部上传进行备份，这样可以保证原主题的更新不会影响你原先配置的效果。</li><li>另一个方案是像 <code>hexo-starter</code> 仓库一样通过 Git 的 Submodule 功能来管理，这样可以进行主题的更新。<br>这里我选择和 Hexo 初始化仓库一样使用 Git 子模块的方式进行主题的备份处理。不过通过子模块管理的方式我们恢复时仅会同步到 Next 主题的原文件，没法直接同步我们对主题配置文件或其他文件的修改，因为我们没有权限提交修改到 Next 仓库中。因此我创建了了个 <code>themes_custom</code> 文件夹来存放对应主题的修改的备份，这样子我们同步之后，只需要对比一下内容手动把这些配置应用过去就可以快速完成对主题的配置。<br>最终备份文件列表如下：</li></ol><pre><code>scaffoldssourcethemesthemes_custom/next.gitignore.gitmodules_config.ymlpackage.json</code></pre><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>有了方案之后，我们备份的具体操作如下：</p><ol><li>先修改 <code>.gitignore</code> 文件，查看之后由于原文件已经忽略了 <code>public</code> 和 <code>node_modules</code> 文件夹，因此仅需要添加 <code>package-lock.json</code> 到忽略清单中。</li><li>我们可以删除不使用的主题 <code>landscape</code> 或者把主题路径添加到忽略列表中。</li><li>创建 <code>themes_custom/next</code> 文件夹，将对主题进行的配件修改的文件拷贝一份到这里</li><li>执行以下命令，在本地创建备份仓库：</li></ol><pre><code class="bash">$ cd blog$ git init#已初始化空的 Git 仓库于 blog/.git/$ git submodule add https://github.com/theme-next/hexo-theme-next.git themes/next#添加位于 &#39;themes/next&#39; 的现存仓库到索引$ git add .$ git commit -m &quot;init blog backup&quot;</code></pre><ol><li>将备份内容 push 到远程仓库的备份分支 <code>hexo</code> 上：</li></ol><pre><code class="bash">$ git branch -m master hexo$ git remote add origin https://github.com/Mupceet/mupceet.github.io.git$ git push -u origin hexo:hexo</code></pre><p> 这里，我对分支进行了重命名以减少记忆负担<br>经过以上步骤，我们就备份了所有必要的文件。后续更新博客也要及时地将这些文件进行提交并上传完成备份。</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>有了备份之后，在另一台电脑上创建博客，或者是恢复备份时，就可以直接使用我们备份的内容进行操作。</p><ol><li>环境准备<br>具体见 <a href="https://mupceet.com/2019/08/build-blog-based-on-hexo/" target="_blank" rel="noopener">Hexo 博客搭建与主题配置（零基础版）</a>一文。</li><li>克隆备份的内容</li></ol><pre><code class="bash">$ git clone --recursive -b hexo https://github.com/Mupceet/mupceet.github.io.git blog</code></pre><ol><li>下载 npm 依赖模块</li></ol><pre><code class="bash">$ cd blog$ npm install</code></pre><ol><li>恢复主题配置<br>将 <code>themes_custom</code> 文件夹中对主题的配置的修改恢复到对应的主题文件夹中，这里建议使用对比的方式对其进行修改，而不是直接覆盖，这样就完成了主题的配置。</li><li>克隆原博客内容</li></ol><pre><code class="bash">$ cd blog$ git clone https://github.com/Mupceet/mupceet.github.io.git .deploy\_git</code></pre><ol><li>正常更新博客</li></ol><pre><code class="bash">$ hexo g$ hexo s$ hexo d</code></pre><p>可以看到，使用备份文件恢复博客的环境是非常简单的，强烈建议大家搭建好博客之后增加一个备份操作。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python图像处理库PIL中图像格式转换（一）</title>
      <link href="/2021/11/07/Python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%BA%93PIL%E4%B8%AD%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/11/07/Python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%BA%93PIL%E4%B8%AD%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在数字图像处理中，针对不同的图像格式有其特定的处理算法。所以，在做图像处理之前，我们需要考虑清楚自己要基于哪种格式的图像进行算法设计及其实现。本文基于这个需求，使用python中的图像处理库PIL来实现不同图像格式的转换。</p><p>对于彩色图像，不管其图像格式是PNG，还是BMP，或者JPG，在PIL中，使用Image模块的open()函数打开后，返回的图像对象的模式都是“RGB”。而对于灰度图像，不管其图像格式是PNG，还是BMP，或者JPG，打开后，其模式为“L”。</p><p>通过之前的博客对Image模块的介绍，对于PNG、BMP和JPG彩色图像格式之间的互相转换都可以通过Image模块的open()和save()函数来完成。具体说就是，在打开这些图像时，PIL会将它们解码为三通道的“RGB”图像。用户可以基于这个“RGB”图像，对其进行处理。处理完毕，使用函数save()，可以将处理结果保存成PNG、BMP和JPG中任何格式。这样也就完成了几种格式之间的转换。同理，其他格式的彩色图像也可以通过这种方式完成转换。当然，对于不同格式的灰度图像，也可通过类似途径完成，只是PIL解码后是模式为“L”的图像。</p><p>这里，我想详细介绍一下Image模块的convert()函数，用于不同模式图像之间的转换。</p><p>Convert()函数有三种形式的定义，它们定义形式如下：</p><p>im.convert(mode) ⇒ image</p><p>im.convert(“P”, **options)  ⇒ image</p><p>im.convert(mode, matrix)  ⇒ image</p><p>使用不同的参数，将当前的图像转换为新的模式，并产生新的图像作为返回值。</p><p>通过博客“<a href="http://blog.csdn.net/icamera0/article/details/50647465" target="_blank" rel="noopener">Python图像处理库PIL的基本概念介绍</a>”，我们知道PIL中有九种不同模式。分别为1，L，P，RGB，RGBA，CMYK，YCbCr，I，F。</p><p>本文我采用的示例图像是图像处理中经典的lena照片。分辨率为512x512的lena图片如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160310080807668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一、模式“RGB”转换为其他不同模式</p><h2 id="模式“1”"><a href="#模式“1”" class="headerlink" title="模式“1”"></a>模式“1”</h2><p>模式“1”为二值图像，非黑即白。但是它每个像素用8个bit表示，0表示黑，255表示白。下面我们将lena图像转换为“1”图像。</p><p>例子：</p><pre><code class="python">    &gt;&gt;&gt;from PIL import Image        &gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)        &gt;&gt;&gt; lena.mode        &#39;RGB&#39;        &gt;&gt;&gt; lena.getpixel((0,0))        (197, 111, 78)        &gt;&gt;&gt; lena_1 = lena.convert(&quot;1&quot;)        &gt;&gt;&gt; lena_1.mode        &#39;1&#39;        &gt;&gt;&gt; lena_1.size        (512, 512)        &gt;&gt;&gt;lena_1.getpixel((0,0))        255        &gt;&gt;&gt; lena_1.getpixel((10,10))        255        &gt;&gt;&gt;lena_1.getpixel((10,120))        0        &gt;&gt;&gt;lena_1.getpixel((130,120))        255</code></pre><p>图像lena_1的模式为“1”，分辨率为512x512，如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160310080929507?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="模式“L”"><a href="#模式“L”" class="headerlink" title="模式“L”"></a>模式“L”</h2><p>模式“L”为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。在PIL中，从模式“RGB”转换为“L”模式是按照下面的公式转换的：</p><p>L = R * 299/1000 + G * 587/1000+ B * 114/1000</p><p>下面我们将lena图像转换为“L”图像。</p><p>例子：</p><pre><code class="python">    &gt;&gt;&gt; from PIL importImage        &gt;&gt;&gt; lena = Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)        &gt;&gt;&gt; lena.mode        &#39;RGB&#39;        &gt;&gt;&gt; lena.getpixel((0,0))        (197, 111, 78)        &gt;&gt;&gt; lena_L =lena.convert(&quot;L&quot;)        &gt;&gt;&gt; lena_L.mode        &#39;L&#39;        &gt;&gt;&gt; lena_L.size        (512, 512)        &gt;&gt;&gt;lena.getpixel((0,0))        (197, 111, 78)        &gt;&gt;&gt;lena_L.getpixel((0,0))        132</code></pre><p>对于第一个像素点，原始图像lena为(197, 111, 78)，其转换为灰色值为：</p><p>197 *299/1000 + 111 * 587/1000 + 78 * 114/1000 = 132.952，PIL中只取了整数部分，即为132。</p><p>转换后的图像lena_L如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160310081028211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="模式“P”"><a href="#模式“P”" class="headerlink" title="模式“P”"></a>模式“P”</h2><p>模式“P”为8位彩色图像，它的每个像素用8个bit表示，其对应的彩色值是按照调色板查询出来的。</p><p>下面我们使用默认的调色板将lena图像转换为“P”图像。</p><p>例子：</p><pre><code class="python">    &gt;&gt;&gt; from PIL importImage        &gt;&gt;&gt; lena = Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)        &gt;&gt;&gt; lena.mode        &#39;RGB&#39;        &gt;&gt;&gt; lena.getpixel((0,0))        (197, 111, 78)        &gt;&gt;&gt; lena_P =lena.convert(&quot;P&quot;)        &gt;&gt;&gt; lena_P.mode        &#39;P&#39;        &gt;&gt;&gt;lena_P.getpixel((0,0))        62</code></pre><p>转换后的图像lena_P如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160310081127075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="模式“RGBA”"><a href="#模式“RGBA”" class="headerlink" title="模式“RGBA”"></a>模式“RGBA”</h2><p>模式“RGBA”为32位彩色图像，它的每个像素用32个bit表示，其中24bit表示红色、绿色和蓝色三个通道，另外8bit表示alpha通道，即透明通道。</p><p>下面我们将模式为“RGB”的lena图像转换为“RGBA”图像。</p><p>例子：</p><pre><code class="python">    &gt;&gt;&gt; from PIL import Image        &gt;&gt;&gt;lena = Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)        &gt;&gt;&gt;lena.mode        &#39;RGB&#39;        &gt;&gt;&gt;lena.getpixel((0,0))        (197,111, 78)        &gt;&gt;&gt;lena_rgba = lena.convert(&quot;RGBA&quot;)        &gt;&gt;&gt;lena_rgba.mode        &#39;RGBA&#39;        &gt;&gt;&gt;lena_rgba.getpixel((0,0))        (197,111, 78, 255)        &gt;&gt;&gt;lena_rgba.getpixel((0,1))        (196,110, 77, 255)        &gt;&gt;&gt;lena.getpixel((0,0))        (197,111, 78)        &gt;&gt;&gt;lena.getpixel((0,1))        (196,110, 77)</code></pre><p>从实例中可以看到，使用当前这个方式将“RGB”图像转为“RGBA”图像时，alpha通道全部设置为255，即完全不透明。</p><p>转换后的图像lena_rgba如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160310081249935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="模式“CMYK”"><a href="#模式“CMYK”" class="headerlink" title="模式“CMYK”"></a>模式“CMYK”</h2><p>模式“CMYK”为32位彩色图像，它的每个像素用32个bit表示。模式“CMYK”就是印刷四分色模式，它是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”。</p><p>四种标准颜色是：C：Cyan = 青色，又称为‘天蓝色’或是‘湛蓝’M：Magenta = 品红色，又称为‘洋红色’；Y：Yellow = 黄色；K：Key<br>Plate(blacK) = 定位套版色（黑色）。</p><p>下面我们将模式为“RGB”的lena图像转换为“CMYK”图像。</p><p>例子：</p><pre><code class="python">    &gt;&gt;&gt;from PIL import Image        &gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)        &gt;&gt;&gt; lena_cmyk =lena.convert(&quot;CMYK&quot;)        &gt;&gt;&gt; lena_cmyk.mode        &#39;CMYK&#39;        &gt;&gt;&gt;lena_cmyk.getpixel((0,0))        (58, 144, 177, 0)        &gt;&gt;&gt; lena_cmyk.getpixel((0,1))        (59, 145, 178, 0)        &gt;&gt;&gt;lena.getpixel((0,0))        (197, 111, 78)        &gt;&gt;&gt;lena.getpixel((0,1))        (196, 110, 77)</code></pre><p>从实例中可以得知PIL中“RGB”转换为“CMYK”的公式如下：</p><p>C = 255 - R<br>M = 255 - G<br>Y = 255 - B<br>K = 0</p><p>由于该转换公式比较简单，转换后的图像颜色有些失真。</p><p>转换后的图像lena_cmyk如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160310081334545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="模式“YCbCr”"><a href="#模式“YCbCr”" class="headerlink" title="模式“YCbCr”"></a>模式“YCbCr”</h2><p>模式“YCbCr”为24位彩色图像，它的每个像素用24个bit表示。YCbCr其中Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。人的肉眼对视频的Y分量更敏感，因此在通过对色度分量进行子采样来减少色度分量后，肉眼将察觉不到的图像质量的变化。</p><p>模式“RGB”转换为“YCbCr”的公式如下：</p><p>Y= 0.257<em>R+0.504</em>G+0.098<em>B+16<br>Cb = -0.148</em>R-0.291<em>G+0.439</em>B+128<br>Cr = 0.439<em>R-0.368</em>G-0.071*B+128</p><p>下面我们将模式为“RGB”的lena图像转换为“YCbCr”图像。</p><p>例子：</p><pre><code class="python">    &gt;&gt;&gt;from PIL import Image        &gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)        &gt;&gt;&gt; lena_ycbcr =lena.convert(&quot;YCbCr&quot;)        &gt;&gt;&gt;lena_ycbcr.mode        &#39;YCbCr&#39;        &gt;&gt;&gt;lena_ycbcr.getpixel((0,0))        (132, 97, 173)        &gt;&gt;&gt;lena.getpixel((0,0))        (197, 111, 78)</code></pre><p>按照公式，Y = 0.257<em>197+0.564</em>111+0.098*78+16= 136.877</p><p>Cb= -0.148<em>197-0.291</em>111+0.439<em>78+128= 100.785<br>Cr = 0.439</em>197-0.368<em>111-0.071</em>78+128 = 168.097</p><p>由此可见，PIL中并非按照这个公式进行“RGB”到“YCbCr”的转换。</p><p>转换后的图像lena_ycbcr如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160310081415264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="模式“I”"><a href="#模式“I”" class="headerlink" title="模式“I”"></a>模式“I”</h2><p>模式“I”为32位整型灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式“RGB”转换为“I”模式是按照下面的公式转换的：</p><p>I = R * 299/1000 + G * 587/1000 + B * 114/1000</p><p>下面我们将模式为“RGB”的lena图像转换为“I”图像。</p><p>例子：</p><pre><code class="python">    &gt;&gt;&gt; from PIL import Image        &gt;&gt;&gt;lena = Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)        &gt;&gt;&gt;lena.getpixel((0,0))        (197,111, 78)        &gt;&gt;&gt;lena.getpixel((0,1))        (196,110, 77)        &gt;&gt;&gt; lena_I =lena.convert(&quot;I&quot;)        &gt;&gt;&gt; lena_I.mode        &#39;I&#39;        &gt;&gt;&gt;lena_I.getpixel((0,0))        132        &gt;&gt;&gt;lena_I.getpixel((0,1))        131        &gt;&gt;&gt; lena_L =lena.convert(&quot;L&quot;)        &gt;&gt;&gt;lena_L.getpixel((0,0))        132        &gt;&gt;&gt;lena_L.getpixel((0,1))        131</code></pre><p>从实验的结果看，模式“I”与模式“L”的结果是完全一样，只是模式“L”的像素是8bit，而模式“I”的像素是32bit。</p><h2 id="模式“F”"><a href="#模式“F”" class="headerlink" title="模式“F”"></a>模式“F”</h2><p>模式“F”为32位浮点灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式“RGB”转换为“F”模式是按照下面的公式转换的：</p><p>F = R * 299/1000+ G * 587/1000 + B * 114/1000</p><p>下面我们将模式为“RGB”的lena图像转换为“F”图像。</p><p>例子：</p><pre><code class="python">    &gt;&gt;&gt;from PIL import Image        &gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)        &gt;&gt;&gt;lena.getpixel((0,0))        (197, 111, 78)        &gt;&gt;&gt;lena.getpixel((0,1))        (196, 110, 77)        &gt;&gt;&gt; lena_F =lena.convert(&quot;F&quot;)        &gt;&gt;&gt; lena_F.mode        &#39;F&#39;        &gt;&gt;&gt;lena_F.getpixel((0,0))        132.95199584960938        &gt;&gt;&gt;lena_F.getpixel((0,1))        131.95199584960938</code></pre><p>模式“F”与模式“L”的转换公式是一样的，都是RGB转换为灰色值的公式，但模式“F”会保留小数部分，如实验中的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> PIL从入门到精通 </tag>
            
            <tag> PIL </tag>
            
            <tag> 格式转换 </tag>
            
            <tag> 模式转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 定时计划任务设置</title>
      <link href="/2021/11/07/CentOS7-%E5%AE%9A%E6%97%B6%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE/"/>
      <url>/2021/11/07/CentOS7-%E5%AE%9A%E6%97%B6%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>就像再windows上有计划任务一样，centos7 自然也有计划任务，而且设置更为灵活，好用。再centos7 上可以利用crontab 来执行计划任务，<br>依赖与 crond 的系统服务，这个服务是系统自带的，可以直接查看状态，启动，停止。  </p><h2 id="安装-crontabs服务并设置开机自启"><a href="#安装-crontabs服务并设置开机自启" class="headerlink" title="安装 crontabs服务并设置开机自启"></a>安装 crontabs服务并设置开机自启</h2><pre><code class="bash">yum install crontabs  systemctl enable crond （设为开机启动）  systemctl start crond（启动crond服务）  systemctl status crond （查看状态） </code></pre><h2 id="设置用户自定义定时任务"><a href="#设置用户自定义定时任务" class="headerlink" title="设置用户自定义定时任务"></a>设置用户自定义定时任务</h2><pre><code class="bash">vi /etc/crontab</code></pre><p>可以看到： </p><pre><code class="bash">Example of job definition:  .---------------- minute (0 - 59)  | .------------- hour (0 - 23)  | | .---------- day of month (1 - 31)  | | | .------- month (1 - 12) OR jan,feb,mar,apr ...  | | | | .---- day of week (0 - 6) (Sunday=0 or 7) ORsun,mon,tue,wed,thu,fri,sat  | | | | |  * * * * * user-name command to be executed  即：  分钟(0-59) 小时(0-23) 日(1-31) 月(11-12) 星期(0-6,0表示周日) 用户名 要执行的命令  * */30 * * * root /usr/local/mycommand.sh (每天，每30分钟执行一次 mycommand命令)  * * 3 * * * root /usr/local/mycommand.sh (每天凌晨三点，执行命令脚本，PS:这里由于第一个的分钟没有设置，那么就会每天凌晨3点的每分钟都执行一次命令)  * 0 3 * * * root /usr/local/mycommand.sh (这样就是每天凌晨三点整执行一次命令脚本)  * */10 11-13 * * * root /usr/local/mycommand.sh (每天11点到13点之间，每10分钟执行一次命令脚本，这一种用法也很常用)  * 10-30 * * * * root /usr/local/mycommand.sh (每小时的10-30分钟，每分钟执行一次命令脚本，共执行20次)  * 10,30 * * * * * root /usr/local/mycommand.sh (每小时的10,30分钟，分别执行一次命令脚本，共执行2次）</code></pre><h3 id="保存生效"><a href="#保存生效" class="headerlink" title="保存生效"></a>保存生效</h3><p>加载任务,使之生效：<code>crontab /etc/crontab</code></p><p>查看任务：<code>crontab -l</code><br>$ crontab -u 用户名 -l （列出用户的定时任务列表）</p><p>PS：特别注意，crond的任务计划，<br>有并不会调用用户设置的环境变量，它有自己的环境变量，当你用到一些命令时，比如mysqldump等需要环境变量的命令，手工执行脚本时是正常的，但用crond执行的时候就会不行，这时你要么写完整的绝对路径，要么将环境变量添加到<br>/etc/crontab 中。</p><p>好了，计划任务就是这么简单了，但是计划任务，执行的语句如果是多条，则需要用药shell脚本，自己先写一个shell脚本，然后在计划任务中，执行这个脚本即可。至于shell脚本的写法，<br>这里不赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS7 </tag>
            
            <tag> 定时任务 </tag>
            
            <tag> Crontabs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS使用yum安装ffmpeg工具</title>
      <link href="/2021/11/07/CentOS%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85ffmpeg%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/11/07/CentOS%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85ffmpeg%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><h3 id="安装ffmpeg"><a href="#安装ffmpeg" class="headerlink" title="安装ffmpeg"></a>安装ffmpeg</h3><pre><code class="bash">yum -y install ffmpeg</code></pre><h3 id="安装yasm"><a href="#安装yasm" class="headerlink" title="安装yasm"></a>安装yasm</h3><pre><code class="bash">yum install -y yasm</code></pre><h3 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h3><pre><code class="bash">ffmpeg -version</code></pre><p><img src="https://img-blog.csdnimg.cn/20200601162219387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b19xaWFuZ3FpYW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><h3 id="升级系统epel-release软件包"><a href="#升级系统epel-release软件包" class="headerlink" title="升级系统epel-release软件包"></a>升级系统epel-release软件包</h3><pre><code class="bash">yum install epel-release -y //安装第三方软件包yum update -y //更新系统软件包shutdown -r now  //也可以不重启  </code></pre><p><strong>EPEL源-是什么?为什么安装？</strong></p><p>EPEL (Extra Packages for Enterprise<br>Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.</p><h3 id="安装Nux-Dextop-Yum-源"><a href="#安装Nux-Dextop-Yum-源" class="headerlink" title="安装Nux Dextop Yum 源"></a>安装Nux Dextop Yum 源</h3><p>由于CentOS没有官方FFmpeg rpm软件包。但是，我们可以使用第三方YUM源（Nux Dextop）完成此工作。</p><h4 id="1-CentOS-7"><a href="#1-CentOS-7" class="headerlink" title="1) CentOS 7"></a>1) CentOS 7</h4><pre><code class="bash">rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rorpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm  </code></pre><h4 id="2-CentOS-6"><a href="#2-CentOS-6" class="headerlink" title="2) CentOS 6"></a>2) CentOS 6</h4><pre><code class="bash">rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rorpm -Uvh http://li.nux.ro/download/nux/dextop/el6/x86_64/nux-dextop-release-0-2.el6.nux.noarch.rpm    </code></pre><h3 id="安装FFmpeg-和-FFmpeg开发包"><a href="#安装FFmpeg-和-FFmpeg开发包" class="headerlink" title="安装FFmpeg 和 FFmpeg开发包"></a>安装FFmpeg 和 FFmpeg开发包</h3><pre><code class="bash">yum install ffmpeg ffmpeg-devel -y</code></pre><h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><pre><code class="bash">ffmpeg 或 ffmpeg -version</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200601172835203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b19xaWFuZ3FpYW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><h3 id="如果你想了解更多关于FFmpeg使用方面的资料"><a href="#如果你想了解更多关于FFmpeg使用方面的资料" class="headerlink" title="如果你想了解更多关于FFmpeg使用方面的资料"></a>如果你想了解更多关于FFmpeg使用方面的资料</h3><pre><code class="bash">ffmpeg -h </code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200601172909584.png?size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 软件 </tag>
            
            <tag> Yum </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA导入/导出Live templates或者其他设置</title>
      <link href="/2021/11/07/IDEA%E5%AF%BC%E5%85%A5-%E5%AF%BC%E5%87%BALive%20templates%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AE/"/>
      <url>/2021/11/07/IDEA%E5%AF%BC%E5%85%A5-%E5%AF%BC%E5%87%BALive%20templates%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA导入-导出live-templates或者其他设置"><a href="#IDEA导入-导出live-templates或者其他设置" class="headerlink" title="IDEA导入/导出live templates或者其他设置"></a>IDEA导入/导出live templates或者其他设置</h1><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><ol><li><p>在菜单栏选择 <code>File</code> | <code>Manage IDE Settings</code> | <code>Export Settings</code></p></li><li><p>在打开的导出弹窗中，选择需要导出的项目，如果我们只需要导出 <strong>Live templates</strong> ，那就只选择 <strong>Live templates</strong> 即可，然后选择一个需要导出的位置并设置一个存储的文件名（默认是settings.zip）</p></li><li><p>点击 <strong>OK</strong> 进行导出，导出的文件可以导入到其他IDEA中进行使用</p></li></ol><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ol><li><p>在菜单栏选择 <code>File</code> | <code>Manage IDE Settings</code> | <code>Import Settings</code></p></li><li><p>选择之前导出的配置文件，点击 <strong>OK</strong></p></li><li><p>在弹出的窗口中选择需要导入的项目，例如 <strong>Live templates</strong> 然后点击 <strong>OK</strong></p></li><li><p>重启IDEA使新配置生效</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>[Share live templates](<a href="https://www.jetbrains.com/help/idea/sharing-live-" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/sharing-live-</a><br>templates.html#export)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Tools </tag>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 yum安装python3.6</title>
      <link href="/2021/11/03/CentOS7-yum%E5%AE%89%E8%A3%85python3-6/"/>
      <url>/2021/11/03/CentOS7-yum%E5%AE%89%E8%A3%85python3-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CentOS7 使用yum 安装Python3 </p></blockquote><h3 id="1-配epel源-阿里"><a href="#1-配epel源-阿里" class="headerlink" title="1.配epel源_阿里"></a>1.配epel源_阿里</h3><pre><code class="bash">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</code></pre><h3 id="2-安装python3-6"><a href="#2-安装python3-6" class="headerlink" title="2.安装python3.6"></a>2.安装python3.6</h3><pre><code class="bash">yum install python36 -y</code></pre><h3 id="3-安装pip3"><a href="#3-安装pip3" class="headerlink" title="3.安装pip3"></a>3.安装pip3</h3><pre><code class="bash"># 搜索pip3的安装包名称yum  whatprovides pip3# 安装pip3yum install python36-pip -y</code></pre><p>依赖：python36-setuptools</p><h3 id="4-验证"><a href="#4-验证" class="headerlink" title="4.验证"></a>4.验证</h3><pre><code class="bash">python3 --version</code></pre><h3 id="5-查看指向"><a href="#5-查看指向" class="headerlink" title="5.查看指向"></a>5.查看指向</h3><pre><code class="bash">ll /usr/bin/pythonll /usr/bin/python3</code></pre><p>由上可知<br>python 代表CentOS7系统默认的 python2.7；<br>python3 代表新安装的 python3.6</p><h3 id="6-安装python开发工具"><a href="#6-安装python开发工具" class="headerlink" title="6.安装python开发工具"></a>6.安装python开发工具</h3><pre><code class="bash">yum install python36-devel -y</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://blog.51cto.com/moerjinrong/2396290" target="_blank" rel="noopener">CentOS7 yum安装python3.6</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 安装Chrome无GUI运行selenium chromedriver</title>
      <link href="/2021/11/03/Centos7-%E5%AE%89%E8%A3%85Chrome%E6%97%A0GUI%E8%BF%90%E8%A1%8Cselenium-chromedriver/"/>
      <url>/2021/11/03/Centos7-%E5%AE%89%E8%A3%85Chrome%E6%97%A0GUI%E8%BF%90%E8%A1%8Cselenium-chromedriver/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装chrome"><a href="#1-安装chrome" class="headerlink" title="1. 安装chrome"></a>1. 安装chrome</h3><p>首先安装google的epel源</p><pre><code class="bash">vi /etc/yum.repos.d/google.repo</code></pre><pre><code>[google]name=Google-x86_64baseurl=http://dl.google.com/linux/rpm/stable/x86_64enabled=1gpgcheck=0gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub </code></pre><pre><code class="bash">yum update &amp;&amp; yum install google-chrome-stable</code></pre><h3 id="2-chromedriver下载"><a href="#2-chromedriver下载" class="headerlink" title="2.chromedriver下载"></a>2.chromedriver下载</h3><p><a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromedriver/</a></p><p>找到chrome对应的chromedriver 版本，并下载</p><pre><code class="bash">wget https://chromedriver.storage.googleapis.com/74.0.3729.6/chromedriver_linux64.zip</code></pre><p>将下载的chromedriver 放到脚本同级目录调用</p><h3 id="3-为chromedriver授权"><a href="#3-为chromedriver授权" class="headerlink" title="3. 为chromedriver授权"></a>3. 为chromedriver授权</h3><pre><code class="bash">chmod 755 chromedriver</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument(&quot;--headless&quot;)chrome_options.add_argument(&#39;--disable-gpu&#39;)chrome_options.add_argument(&#39;--no-sandbox&#39;)    # 禁止沙箱模式，否则肯能会报错遇到chrome异常url=&quot;https://www.west.cn/login.asp&quot;brower=webdriver.Chrome(executable_path=&quot;./chromedriver&quot;, chrome_options=chrome_options)brower.get(url)print(brower.current_url)brower.get(&quot;https://www.west.cn/Manager/&quot;)print(brower.current_url)brower.quit()</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.cnblogs.com/huchong/p/10796823.html" target="_blank" rel="noopener">centos7无GUI运行selenium chromedriver 亲测可用！</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
            <tag> Chrome </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python requests库session会话保存</title>
      <link href="/2021/10/17/Python-requests%E5%BA%93session%E4%BC%9A%E8%AF%9D%E4%BF%9D%E5%AD%98/"/>
      <url>/2021/10/17/Python-requests%E5%BA%93session%E4%BC%9A%E8%AF%9D%E4%BF%9D%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Python爬虫 requests库使用session会话保存cookies继续请求</p></blockquote><pre><code class="python">import requests# 通过Session类新建一个会话session = requests.Session()post_url = &#39;https://passport.weibo.cn/sso/login&#39;# 往下使用requests的地方，直接使用session即可，session就会保存服务器发送过来的cookie信息headers = {    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36&#39;,    &#39;Referer&#39;: &#39;https://passport.weibo.cn/signin/login?entry=mweibo&amp;r=http%3A%2F%2Fweibo.cn%2F&amp;backTitle=%CE%A2%B2%A9&amp;vt=&#39;,}data = {    &#39;username&#39;: &#39;17312345678&#39;, # 账号    &#39;password&#39;: &#39;password&#39;, # 密码    &#39;savestate&#39;: &#39;1&#39;,    &#39;r&#39;: &#39;&#39;,    &#39;ec&#39;: &#39;0&#39;,    &#39;pagerefer&#39;: &#39;http://weibo.cn/&#39;,    &#39;entry&#39;: &#39;mweibo&#39;,    &#39;wentry&#39;: &#39;&#39;,    &#39;loginfrom&#39;: &#39;&#39;,    &#39;client_id&#39;: &#39;&#39;,    &#39;code&#39;: &#39;&#39;,    &#39;qq&#39;: &#39;&#39;,    &#39;mainpageflag&#39;: &#39;1&#39;,    &#39;hff&#39;: &#39;&#39;,    &#39;hfp&#39;: &#39;&#39;,}r = session.post(url=post_url, data=data, headers=headers)# 上面的session会保存会话，往下发送请求，直接使用session即可url = &#39;https://weibo.cn/6388179289/info&#39;headers1 = {    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36&#39;,}r = session.get(url=url, headers=headers1)print(r.text)</code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>原文链接：<a href="https://blog.csdn.net/haeasringnar/article/details/82558729" target="_blank" rel="noopener">https://blog.csdn.net/haeasringnar/article/details/82558729</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Requests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式的【贪婪匹配】和【懒惰匹配】</title>
      <link href="/2021/10/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E3%80%90%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%E3%80%91%E5%92%8C%E3%80%90%E6%87%92%E6%83%B0%E5%8C%B9%E9%85%8D%E3%80%91/"/>
      <url>/2021/10/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E3%80%90%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%E3%80%91%E5%92%8C%E3%80%90%E6%87%92%E6%83%B0%E5%8C%B9%E9%85%8D%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、贪婪匹配"><a href="#一、贪婪匹配" class="headerlink" title="一、贪婪匹配"></a>一、贪婪匹配</h2><p>正则表达式通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。比如这个表达式：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。</p><h2 id="二、懒惰匹配"><a href="#二、懒惰匹配" class="headerlink" title="二、懒惰匹配"></a>二、懒惰匹配</h2><p>懒惰匹配，也就是匹配尽可能少的字符。在能使整个匹配成功的前提下使用最少的重复，只要在它后面加上一个问号?即可。现在看看懒惰版的例子吧：</p><p>a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）</p><p>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有一条比懒惰／贪婪规则优先级更高的规则，就是：最先开始的匹配拥有最高的优先权</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://blog.csdn.net/zhengxiangwen/article/details/53583758" target="_blank" rel="noopener">CSDN-正则表达式的【贪婪匹配】和【懒惰匹配】</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 正则表达式笔记</title>
      <link href="/2021/10/10/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/10/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Python正则表达式"><a href="#Python正则表达式" class="headerlink" title="Python正则表达式"></a>Python正则表达式</h1><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</p><h2 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h2><blockquote><p>re.match只从待匹配的字符串或文本的开头位置开始匹配，即如果匹配的字符串不在开头，而是在中间或结尾，则无法匹配就返回None！ </p></blockquote><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><pre><code class="python">re.match(pattern, string, flags=0)</code></pre><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul><li>pattern : 匹配的正则表达式                     </li><li>string  : 要匹配的字符串。                     </li><li>flags   : 标志位，用于控制正则表达式的匹配方式 </li></ul><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><blockquote><p>match方法在没有匹配的任何内容就返回None，如果有匹配的内容就返回一个Match对象</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="python">import restr = &quot;aabbcceAAAe11442299aabCCbeedsffg&quot;print(re.match(&quot;aa&quot;, str).group())# 输出结果： aaprint(re.match(&quot;AA&quot;, str))# 输出结果： None</code></pre><h2 id="re-search函数"><a href="#re-search函数" class="headerlink" title="re.search函数"></a>re.search函数</h2><blockquote><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p></blockquote><h3 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h3><pre><code class="python">re.search(pattern, string, flags=0)</code></pre><h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul><li>pattern : 匹配的正则表达式                     </li><li>string  : 要匹配的字符串。                     </li><li>flags   : 标志位，用于控制正则表达式的匹配方式 </li></ul><h3 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h3><blockquote><p>search方法在没有匹配的任何内容就返回None，如果有匹配的内容就返回一个Match对象</p></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><pre><code class="python">import restr = &quot;aabbcceAAAe11442299aabCCbeedsffg&quot;print(re.search(&quot;aa&quot;, str).group())# 输出结果： aaprint(re.search(&quot;AA&quot;, str).group())# 输出结果： AA</code></pre><h2 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h2><blockquote><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p></blockquote><h2 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h2><p>Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。</p><h3 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h3><pre><code class="python">re.sub(pattern, repl, string, count=0, flags=0)</code></pre><h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul><li>pattern : 正则中的模式字符串。</li><li>repl : 替换的字符串，也可为一个函数。</li><li>string : 要被查找替换的原始字符串。</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li></ul><h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><blockquote><p>替换后的字符串</p></blockquote><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><pre><code class="python">import restr = &quot;aabbcceAAAe11442299aabCCbeedsffg&quot;# 将小写的bb替换为大写的BBres=re.sub(&quot;bb&quot;,&#39;BB&#39;,str)# 输出结果为替换后的字符串print(res)# 输出结果为：aaBBcceAAAe11442299aabCCbeedsffg</code></pre><h2 id="re-compile-函数"><a href="#re-compile-函数" class="headerlink" title="re.compile 函数"></a>re.compile 函数</h2><blockquote><p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p></blockquote><h3 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h3><pre><code class="python">  re.compile(pattern[, flags])</code></pre><h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul><li>pattern : 一个字符串形式的正则表达式</li><li>flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参见Flags标识位</li></ul><h2 id="pattern-findall-函数"><a href="#pattern-findall-函数" class="headerlink" title="pattern.findall 函数"></a>pattern.findall 函数</h2><blockquote><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。<br>注意： match 和 search 是匹配一次 findall 匹配所有。</p></blockquote><h3 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h3><pre><code class="python">findall(string[, pos[, endpos]])</code></pre><h3 id="参数：-4"><a href="#参数：-4" class="headerlink" title="参数："></a>参数：</h3><ul><li>string : 待匹配的字符串。</li><li>pos : 可选参数，指定字符串的起始位置，默认为 0。</li><li>endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。</li></ul><h3 id="返回结果-1"><a href="#返回结果-1" class="headerlink" title="返回结果"></a>返回结果</h3><blockquote><p>返回一个列表，如果没有匹配到则返回一个空列表</p></blockquote><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><pre><code class="python"># -*- coding:UTF8 -*- import re pattern = re.compile(r&#39;\d+&#39;)   # 查找数字result1 = pattern.findall(&#39;runoob 123 google 456&#39;)result2 = pattern.findall(&#39;run88oob123google456&#39;, 0, 10) print(result1)print(result2)# 输出结果：# [&#39;123&#39;, &#39;456&#39;]# [&#39;88&#39;, &#39;12&#39;]</code></pre><h2 id="re-finditer-函数"><a href="#re-finditer-函数" class="headerlink" title="re.finditer 函数"></a>re.finditer 函数</h2><blockquote><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="python">re.finditer(pattern, string, flags=0)</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>pattern : 匹配的正则表达式                     </li><li>string  : 要匹配的字符串。                     </li><li>flags   : 标志位，用于控制正则表达式的匹配方式 </li></ul><h3 id="返回结果-2"><a href="#返回结果-2" class="headerlink" title="返回结果"></a>返回结果</h3><blockquote><p>finditer函数如果匹配到内容则返回一个迭代器，如果没有匹配到则返回None</p></blockquote><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><pre><code class="python"># -*- coding: UTF-8 -*- import re it = re.finditer(r&quot;\d+&quot;,&quot;12a32bc43jf3&quot;) for match in it:     print (match.group() )# 输出结果：# 12 # 32 # 43 # 3</code></pre><h2 id="re-split函数"><a href="#re-split函数" class="headerlink" title="re.split函数"></a>re.split函数</h2><blockquote><p>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p></blockquote><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code class="python">re.split(pattern, string[, maxsplit=0, flags=0])</code></pre><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li>pattern：匹配的正则表达式</li><li>string：要匹配的字符串。</li><li>maxsplit：分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。</li></ul><h3 id="返回结果-3"><a href="#返回结果-3" class="headerlink" title="返回结果"></a>返回结果</h3><blockquote><p>返回一个列表</p></blockquote><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><pre><code class="python">import restr = &quot;aa-bb-cceAAAe11442299aabCCbeedsffg&quot;res=re.split(&#39;-&#39;,str)print(res)# 运行结果# [&#39;aa&#39;, &#39;bb&#39;, &#39;cceAAAe11442299aabCCbeedsffg&#39;]</code></pre><h2 id="Flags标志位"><a href="#Flags标志位" class="headerlink" title="Flags标志位"></a>Flags标志位</h2><ul><li>re.I:使匹配对大小写不敏感                                          </li><li>re.L:做本地化识别（locale-aware）匹配                               </li><li>re.M:多行匹配，影响 ^ 和 $                                          </li><li>re.S:使 . 匹配包括换行在内的所有字符                                </li><li>re.U:根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.        </li><li>re.X:该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 </li></ul><h2 id="Match对象"><a href="#Match对象" class="headerlink" title="Match对象"></a>Match对象</h2><blockquote><p>Match对象是一个匹配对象，正则表达式匹配到的内容都会存放着这个对象里面，如果没有匹配到任何的内容那就返回None</p></blockquote><h3 id="Match对象的属性"><a href="#Match对象的属性" class="headerlink" title="Match对象的属性"></a>Match对象的属性</h3><ul><li>.string:待匹配的文本                        </li><li>.re:匹配时使用的patter对象（正则表达式） </li><li>.pos:正则表达式搜索文本的开始位置        </li><li>.endpos:正则表达式搜索文本的结束位置        </li></ul><h3 id="Match对象的方法"><a href="#Match对象的方法" class="headerlink" title="Match对象的方法"></a>Match对象的方法</h3><ul><li>.group():获得匹配后的字符串              </li><li>.groups():获得正则表达式中的分组列表           </li><li>.start():匹配字符串在原始字符串的开始位置 </li><li>.end():匹配字符串在原始字符串的结束位置 </li><li>.span():返回(.start(), .end())          </li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.docs4dev.com/docs/zh/python/3.7.2rc1/all/library-re.html" target="_blank" rel="noopener">Python中文文档-re正则表达式运算</a><br><a href="https://www.runoob.com/python/python-reg-expressions.html#flags" target="_blank" rel="noopener">菜鸟教程-Python正则表达式</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Scrapy框架笔记</title>
      <link href="/2021/10/10/Python-Scrapy-%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/10/Python-Scrapy-%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-Scrapy-使用笔记"><a href="#Python-Scrapy-使用笔记" class="headerlink" title="Python Scrapy 使用笔记"></a>Python Scrapy 使用笔记</h1><h2 id="安装-Scrapy"><a href="#安装-Scrapy" class="headerlink" title="安装 Scrapy"></a>安装 Scrapy</h2><p>使用pip安装</p><pre><code class="bash">pip install Scrapy</code></pre><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>scrapy startproject 项目名称</p><pre><code class="bash">scrapy startproject tutorial</code></pre><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><pre><code>tutorial/    scrapy.cfg    tutorial/        __init__.py        items.py        pipelines.py        settings.py        spiders/            __init__.py            ...</code></pre><h5 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h5><ul><li>scrapy.cfg: 项目的配置文件</li><li>tutorial/: 该项目的python模块。之后您将在此加入代码。</li><li>tutorial/items.py: 项目中的item文件.</li><li>tutorial/pipelines.py: 项目中的pipelines文件.</li><li>tutorial/settings.py: 项目的设置文件.</li><li>tutorial/spiders/: 放置spider代码的目录.</li></ul><h3 id="编写爬虫"><a href="#编写爬虫" class="headerlink" title="编写爬虫"></a>编写爬虫</h3><p>为了创建一个Spider，您必须继承 scrapy.Spider 类， 且定义以下三个属性:</p><ul><li>name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。</li><li>start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</li><li>parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。</li></ul><pre><code class="python">import scrapyclass DmozSpider(scrapy.Spider):    name = &quot;dmoz&quot;    allowed_domains = [&quot;dmoz.org&quot;]    start_urls = [        &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;,        &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&quot;    ]    def parse(self, response):        filename = response.url.split(&quot;/&quot;)[-2]        with open(filename, &#39;wb&#39;) as f:            f.write(response.body)</code></pre><h3 id="开始爬虫"><a href="#开始爬虫" class="headerlink" title="开始爬虫"></a>开始爬虫</h3><p>进入项目的根目录，执行下列命令启动spider:<br>scrapy crawl name属性的名字</p><pre><code class="bash">scrapy crawl dmoz</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
